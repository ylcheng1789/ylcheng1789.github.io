<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loong</title>
  
  <subtitle>一个独立开发者的博客</subtitle>
  <link href="http://ylcheng1789.github.io/atom.xml" rel="self"/>
  
  <link href="http://ylcheng1789.github.io/"/>
  <updated>2024-09-02T16:15:05.579Z</updated>
  <id>http://ylcheng1789.github.io/</id>
  
  <author>
    <name>程月龙</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>八股文系列-并发编程</title>
    <link href="http://ylcheng1789.github.io/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://ylcheng1789.github.io/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2024-09-02T15:11:35.000Z</published>
    <updated>2024-09-02T16:15:05.579Z</updated>
    
    <content type="html"><![CDATA[<p><a name="MIJch"></a></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><a name="WPmsd"></a></p><h3 id="1-并行跟并发有什么区别？"><a href="#1-并行跟并发有什么区别？" class="headerlink" title="1.并行跟并发有什么区别？"></a>1.并行跟并发有什么区别？</h3><ul><li>并行是指多个处理器同时执行多个任务，每个核心实际上可以在同一时间独立地执行不同的任务。</li><li>并发是指系统有处理多个任务的能力，但是任意时刻只有一个任务在执行。在单核处理器上，多个任务是通过时间片轮转的方式实现的。但这种切换非常快，给人感觉是在同时执行。<br><a name="r4gnW"></a></li></ul><h4 id="你对线程安全的理解是什么？"><a href="#你对线程安全的理解是什么？" class="headerlink" title="你对线程安全的理解是什么？"></a>你对线程安全的理解是什么？</h4><p>线程安全是并发编程中一个重要的概念，如果一段代码块或者一个方法在多线程环境中被多个线程同时执行时能够正确地处理共享数据，那么这段代码块或者方法就是线程安全的。<br />可以从三个要素来确保线程安全：<br /><strong>①、原子性</strong>：确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。<br />原子性可以通过互斥锁（如 synchronized）或原子操作（如 AtomicInteger 类中的方法）来保证。<br /><strong>②、可见性</strong>：确保一个线程对共享变量的修改可以立即被其他线程看到。<br />volatile 关键字可以保证了变量的修改对所有线程立即可见，并防止编译器优化导致的可见性问题。<br /><strong>③、活跃性问题</strong>：要确保线程不会因为死锁、饥饿、活锁等问题导致无法继续执行。<br><a name="VNztG"></a></p><h3 id="2-说说什么是进程和线程？"><a href="#2-说说什么是进程和线程？" class="headerlink" title="2.说说什么是进程和线程？"></a>2.说说什么是进程和线程？</h3><p>进程说简单点就是我们在电脑上启动的一个个应用，比如我们启动一个浏览器，就会启动了一个浏览器进程。进程是操作系统资源分配的最小单位，它包括了程序、数据和进程控制块等。<br />线程说简单点就是我们在 Java 程序中启动的一个 main 线程，一个进程至少会有一个线程。当然了，我们也可以启动多个线程，比如说一个线程进行 IO 读写，一个线程进行加减乘除计算，这样就可以充分发挥多核 CPU 的优势，因为 IO 读写相对 CPU 计算来说慢得多。线程是 CPU 分配资源的基本单位。<br />一个进程中可以有多个线程，多个线程共用进程的堆和方法区（Java 虚拟机规范中的一个定义，JDK 8 以后的实现为元空间）资源，但是每个线程都会有自己的程序计数器和栈。<br><a name="qkrVq"></a></p><h4 id="如何理解协程？"><a href="#如何理解协程？" class="headerlink" title="如何理解协程？"></a>如何理解协程？</h4><p>协程通常被视为比线程更轻量级的并发单元，它们主要在一些支持异步编程模型的语言中得到了原生支持，如 Kotlin、Go 等。<br />不过，我们可以使用 CompletableFuture 来模拟协程式的异步执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompletableFutureExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 异步执行任务1</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步执行任务2</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个任务的结果并计算</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; resultFuture = future1.thenCombine(future2, Integer::sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待最终结果并打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果: &quot;</span> + resultFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了两个 CompletableFuture 对象来异步执行两个简单的数值返回任务。这两个任务都会休眠 1 秒钟来模拟耗时计算。<br />然后我们使用 thenCombine 方法来合并这两个任务的结果。最后，我们通过 get 方法等待最终结果的完成，并打印出来。<br><a name="mKued"></a></p><h4 id="说说线程的共享内存？"><a href="#说说线程的共享内存？" class="headerlink" title="说说线程的共享内存？"></a>说说线程的共享内存？</h4><p>线程之间想要进行通信，可以通过消息传递和共享内存两种方法来完成。那 Java 采用的是共享内存的并发模型。<br />这个模型被称为 Java 内存模型，也就是 JMM，JMM 决定了一个线程对共享变量的写入何时对另外一个线程可见。<br />线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了共享变量的副本。当然了，本地内存是 JMM 的一个抽象概念，并不真实存在。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240315111143.png"><br />线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ul><li>线程 A 把本地内存 A 中的共享变量副本刷新到主内存中。</li><li>线程 B 到主内存中读取线程 A 刷新过的共享变量，再同步到自己的共享变量副本中。</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240315111130.png"><br><a name="H5LUe"></a></p><h3 id="3-说说线程有几种创建方式？"><a href="#3-说说线程有几种创建方式？" class="headerlink" title="3.说说线程有几种创建方式？"></a>3.说说线程有几种创建方式？</h3><p>Java 中创建线程主要有三种方式，分别为继承 Thread 类、实现 Runnable 接口、实现 Callable 接口。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407172652.png"><br />第一种，继承 Thread 类，重写 <code>run()</code>方法，调用 <code>start()</code>方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看完二哥的 Java 进阶之路，上岸了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTask</span>();</span><br><span class="line">        task.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的缺点是，由于 Java 不支持多重继承，所以如果类已经继承了另一个类，就不能使用这种方法了。<br />第二种，实现 Runnable 接口，重写 <code>run()</code> 方法，然后创建 Thread 对象，将 Runnable 对象作为参数传递给 Thread 对象，调用 <code>start()</code> 方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看完二哥的 Java 进阶之路，上岸了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTask</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的优点是可以避免 Java 的单继承限制，并且更符合面向对象的编程思想，因为 Runnable 接口将任务代码和线程控制的代码解耦了。<br />第三种，实现 Callable 接口，重写 <code>call()</code> 方法，然后创建 FutureTask 对象，参数为 Callable 对象；紧接着创建 Thread 对象，参数为 FutureTask 对象，调用 <code>start()</code> 方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;看完二哥的 Java 进阶之路，上岸了!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">CallableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTask</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的优点是可以获取线程的执行结果。<br><a name="V2Y0u"></a></p><h4 id="一个-8G-内存的系统最多能创建多少线程"><a href="#一个-8G-内存的系统最多能创建多少线程" class="headerlink" title="一个 8G 内存的系统最多能创建多少线程?"></a>一个 8G 内存的系统最多能创建多少线程?</h4><p>推荐阅读：<a href="https://javabetter.cn/jvm/neicun-jiegou.html">深入理解 JVM 的运行时数据区</a><br />在确定一个系统最多可以创建多个线程时，除了需要考虑系统的内存大小外，Java 虚拟机栈的大小也是值得考虑的因素。<br />线程在创建的时候会被分配一个虚拟机栈，在 64 位操作系统中，默认大小为 1M。<br />通过 <code>java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</code> 这个命令可以查看 JVM 栈的默认大小。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/neicun-jiegou-20231225145929.png"><br />其中 ThreadStackSize 的单位是字节，也就是说默认的 JVM 栈大小是 1024 KB，也就是 1M。<br />换句话说，8GB &#x3D; 8 _ 1024 MB &#x3D; 8 _ 1024 _ 1024 KB，所以一个 8G 内存的系统可以创建的线程数为 8 _ 1024 &#x3D; 8192 个。<br />但操作系统本身的运行也需要消耗一定的内存，所以实际上可以创建的线程数肯定会比 8192 少一些。<br />可以通过下面这段代码来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowErrorTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            testStackOverflowError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStackOverflowError</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(count.incrementAndGet());</span><br><span class="line">        testStackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="H0vsw"></a></p><h4 id="启动一个-Java-程序，你能说说里面有哪些线程吗？"><a href="#启动一个-Java-程序，你能说说里面有哪些线程吗？" class="headerlink" title="启动一个 Java 程序，你能说说里面有哪些线程吗？"></a>启动一个 Java 程序，你能说说里面有哪些线程吗？</h4><p>首先是 main 线程，这是程序开始执行的入口。<br />然后是垃圾回收线程，它是一个后台线程，负责回收不再使用的对象。<br />还有编译器线程，在及时编译中（JIT），负责把一部分热点代码编译后放到 codeCache 中，以提升程序的执行效率。<br />可以通过下面这段代码进行检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLister</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取所有线程的堆栈跟踪</span></span><br><span class="line">        Map&lt;Thread, StackTraceElement[]&gt; threads = Thread.getAllStackTraces();</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread: &quot;</span> + thread.getName() + <span class="string">&quot; (ID=&quot;</span> + thread.getId() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread: Monitor Ctrl-Break (ID=5)</span><br><span class="line">Thread: Reference Handler (ID=2)</span><br><span class="line">Thread: main (ID=1)</span><br><span class="line">Thread: Signal Dispatcher (ID=4)</span><br><span class="line">Thread: Finalizer (ID=3)</span><br></pre></td></tr></table></figure><p>简单解释下：</p><ul><li><code>Thread: main (ID=1)</code> - 主线程，Java 程序启动时由 JVM 创建。</li><li><code>Thread: Reference Handler (ID=2)</code> - 这个线程是用来处理引用对象的，如软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference）。负责清理被 JVM 回收的对象。</li><li><code>Thread: Finalizer (ID=3)</code> - 终结器线程，负责调用对象的 finalize 方法。对象在垃圾回收器标记为可回收之前，由该线程执行其 finalize 方法，用于执行特定的资源释放操作。</li><li><code>Thread: Signal Dispatcher (ID=4)</code> - 信号调度线程，处理来自操作系统的信号，将它们转发给 JVM 进行进一步处理，例如响应中断、停止等信号。</li><li><code>Thread: Monitor Ctrl-Break (ID=5)</code> - 监视器线程，通常由一些特定的 IDE 创建，用于在开发过程中监控和管理程序执行或者处理中断。<br><a name="qKC4K"></a></li></ul><h3 id="4-调用-start-方法时会执行-run-方法，那怎么不直接调用-run-方法？"><a href="#4-调用-start-方法时会执行-run-方法，那怎么不直接调用-run-方法？" class="headerlink" title="4.调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？"></a>4.调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？</h3><p>在 Java 中，启动一个新的线程应该调用其<code>start()</code>方法，而不是直接调用<code>run()</code>方法。<br />当调用<code>start()</code>方法时，会启动一个新的线程，并让这个新线程调用<code>run()</code>方法。这样，<code>run()</code>方法就在新的线程中运行，从而实现多线程并发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start(); <span class="comment">// 正确的方式，创建一个新线程，并在新线程中执行 run()</span></span><br><span class="line">        t1.run(); <span class="comment">// 仅在主线程中执行 run()，没有创建新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接调用<code>run()</code>方法，那么<code>run()</code>方法就在当前线程中运行，没有新的线程被创建，也就没有实现多线程的效果。<br />来看输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-0</span><br></pre></td></tr></table></figure><p>也就是说，<code>start()</code> 方法的调用会告诉 JVM 准备好所有必要的新线程结构，分配其所需资源，并调用线程的 <code>run()</code> 方法在这个新线程中执行。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-5.png"><br><a name="cn0nD"></a></p><h3 id="5-线程有哪些常用的调度方法？"><a href="#5-线程有哪些常用的调度方法？" class="headerlink" title="5.线程有哪些常用的调度方法？"></a>5.线程有哪些常用的调度方法？</h3><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-6.png"><br><a name="J9xI2"></a></p><h4 id="说说线程等待与通知？"><a href="#说说线程等待与通知？" class="headerlink" title="说说线程等待与通知？"></a>说说线程等待与通知？</h4><p>在 Object 类中有一些方法可以用于线程的等待与通知。<br />①、<code>wait()</code>：当一个线程 A 调用一个共享变量的 <code>wait()</code> 方法时，线程 A 会被阻塞挂起，直到发生下面几种情况才会返回 ：</p><ul><li>线程 B 调用了共享对象 <code>notify()</code>或者 <code>notifyAll()</code> 方法；</li><li>其他线程调用了线程 A 的 <code>interrupt()</code> 方法，线程 A 抛出 InterruptedException 异常返回。</li></ul><p>②、<code>wait(long timeout)</code> ：这个方法相比 <code>wait()</code> 方法多了一个超时参数，它的不同之处在于，如果线程 A 调用共享对象的 <code>wait(long timeout)</code>方法后，没有在指定的 timeout 时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。<br />③、<code>wait(long timeout, int nanos)</code>，其内部调用的是 <code>wait(long timout)</code> 方法。<br />唤醒线程主要有下面两个方法：<br />①、<code>notify()</code>：一个线程 A 调用共享对象的 <code>notify()</code> 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。<br />一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。<br />②、<code>notifyAll()</code>：不同于在共享变量上调用 <code>notify()</code> 方法会唤醒被阻塞到该共享变量上的一个线程，notifyAll 方法会唤醒所有在该共享变量上调用 wait 系列方法而被挂起的线程。<br />Thread 类还提供了一个 <code>join()</code> 方法，意思是如果一个线程 A 执行了 <code>thread.join()</code>，当前线程 A 会等待 thread 线程终止之后才从 <code>thread.join()</code> 返回。<br><a name="To7O2"></a></p><h4 id="说说线程休眠"><a href="#说说线程休眠" class="headerlink" title="说说线程休眠"></a>说说线程休眠</h4><p><code>sleep(long millis)</code>：Thread 类中的静态方法，当一个执行中的线程 A 调用了 Thread 的 sleep 方法后，线程 A 会暂时让出指定时间的执行权。<br />但是线程 A 所拥有的监视器资源，比如锁，还是持有不让出的。指定的睡眠时间到了后该方法会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。<br><a name="wzAa4"></a></p><h4 id="说说让出优先权"><a href="#说说让出优先权" class="headerlink" title="说说让出优先权"></a>说说让出优先权</h4><p><code>yield()</code>：Thread 类中的静态方法，当一个线程调用 yield 方法时，实际是在暗示线程调度器，当前线程请求让出自己的 CPU，但是线程调度器可能会“装看不见”忽略这个暗示。<br><a name="LxDGO"></a></p><h4 id="说说线程中断"><a href="#说说线程中断" class="headerlink" title="说说线程中断"></a>说说线程中断</h4><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行。被中断的线程会根据中断状态自行处理。</p><ul><li><code>void interrupt()</code> 方法：中断线程，例如，当线程 A 运行时，线程 B 可以调用线程 <code>interrupt()</code> 方法来设置线程的中断标志为 true 并立即返回。设置标志仅仅是设置标志, 线程 B 实际并没有被中断，会继续往下执行。</li><li><code>boolean isInterrupted()</code> 方法： 检测当前线程是否被中断。</li><li><code>boolean interrupted()</code> 方法： 检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li></ul><p>为了响应中断，线程的执行代码应该这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// 线程被中断时的清理代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程结束前的清理代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stop 方法用来强制线程停止执行，目前已经处于废弃状态，因为 stop 方法会导致线程立即停止，可能会在不一致的状态下释放锁，破坏对象的一致性，导致难以发现的错误和资源泄漏。<br><a name="CayJ0"></a></p><h3 id="6-线程有几种状态？"><a href="#6-线程有几种状态？" class="headerlink" title="6.线程有几种状态？"></a>6.线程有几种状态？</h3><p>在 Java 中，线程共有 6 种状态：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>当线程被创建后，如通过<code>new Thread()</code>，它处于新建状态。此时，线程已经被分配了必要的资源，但还没有开始执行。</td></tr><tr><td>RUNNABLE</td><td>当调用线程的<code>start()</code>方法后，线程进入可运行状态。在这个状态下，线程可能正在运行也可能正在等待获取 CPU 时间片，具体取决于线程调度器的调度策略。</td></tr><tr><td>BLOCKED</td><td>线程在试图获取一个锁以进入同步块&#x2F;方法时，如果锁被其他线程持有，线程将进入阻塞状态，直到它获取到锁。</td></tr><tr><td>WAITING</td><td>线程进入等待状态是因为调用了如下方法之一：<code>Object.wait()</code>或<code>LockSupport.park()</code>。在等待状态下，线程需要其他线程显式地唤醒，否则不会自动执行。</td></tr><tr><td>TIME_WAITING</td><td>当线程调用带有超时参数的方法时，如<code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code> 或<code>LockSupport.parkNanos()</code>，它将进入超时等待状态。线程在指定的等待时间过后会自动返回可运行状态。</td></tr><tr><td>TERMINATED</td><td>当线程的<code>run()</code>方法执行完毕后，或者因为一个未捕获的异常终止了执行，线程进入终止状态。一旦线程终止，它的生命周期结束，不能再被重新启动。</td></tr></tbody></table><p>线程在自身的生命周期中，并不是固定地处于某个状态，而是在不同的状态之间进行切换：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-7.png"><br><a name="AUFEw"></a></p><h3 id="7-什么是线程上下文切换？"><a href="#7-什么是线程上下文切换？" class="headerlink" title="7.什么是线程上下文切换？"></a>7.什么是线程上下文切换？</h3><p>使用多线程的目的是为了充分利用 CPU，但是我们知道，并发其实是一个 CPU 来应付多个线程。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-8.png"><br />为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-9.png"><br><a name="Wt7qj"></a></p><h4 id="线程可以被多核调度吗？"><a href="#线程可以被多核调度吗？" class="headerlink" title="线程可以被多核调度吗？"></a>线程可以被多核调度吗？</h4><p>当然可以，在现代操作系统和多核处理器的环境中，线程的调度和管理是操作系统内核的重要职责之一。<br />操作系统的调度器负责将线程分配给可用的 CPU 核心，从而实现并行处理。<br />多核处理器提供了并行执行多个线程的能力。每个核心可以独立执行一个或多个线程，操作系统的任务调度器会根据策略和算法，如优先级调度、轮转调度等，决定哪个线程何时在哪个核心上运行。<br><a name="jVrJm"></a></p><h3 id="8-守护线程了解吗？"><a href="#8-守护线程了解吗？" class="headerlink" title="8.守护线程了解吗？"></a>8.守护线程了解吗？</h3><p>Java 中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。<br />在 JVM 启动时会调用 main 方法，main 方法所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。<br />那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM 会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM 退出。换而言之，只要有一个用户线程还没结束，正常情况下 JVM 就不会退出。<br><a name="bGlth"></a></p><h3 id="9-线程间有哪些通信方式？"><a href="#9-线程间有哪些通信方式？" class="headerlink" title="9.线程间有哪些通信方式？"></a>9.线程间有哪些通信方式？</h3><p>线程之间传递信息有多种方式，每种方式适用于不同的场景。比如说使用共享对象、<code>wait()</code> 和 <code>notify()</code>、Exchanger 和 CompletableFuture。<br />①、<strong>使用共享对象</strong>，多个线程可以访问和修改同一个对象，从而实现信息的传递，比如说 volatile 和 synchronized 关键字。<br /><a href="https://javabetter.cn/thread/volatile.html">关键字 volatile</a> 用来修饰成员变量，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。<br /><a href="https://javabetter.cn/thread/synchronized-1.html">关键字 synchronized</a> 可以修饰方法，或者以同步代码块的形式来使用，确保多个线程在同一个时刻，只能有一个线程在执行某个方法或某个代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">hasMessage</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writeMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (hasMessage) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        hasMessage = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">readMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!hasMessage) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hasMessage = <span class="literal">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedObject</span> <span class="variable">sharedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sharedObject.writeMessage(<span class="string">&quot;Hello from Writer!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sharedObject.readMessage();</span><br><span class="line">            System.out.println(<span class="string">&quot;Reader received: &quot;</span> + message);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        writer.start();</span><br><span class="line">        reader.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、**使用 wait() 和 notify()**，例如，生产者-消费者模式中，生产者生产数据，消费者消费数据，通过 <code>wait()</code> 和 <code>notify()</code> 方法可以实现生产和消费的协调。<br />一个线程调用共享对象的 <code>wait()</code> 方法时，它会进入该对象的等待池，并释放已经持有的该对象的锁，进入等待状态，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。<br />一个线程调用共享对象的 <code>notify()</code> 方法时，它会唤醒在该对象等待池中等待的一个线程，使其进入锁池，等待获取锁。<br /><a href="https://javabetter.cn/thread/condition.html">Condition</a> 也提供了类似的方法，<code>await()</code> 负责等待、<code>signal()</code> 和 <code>signalAll()</code> 负责通知。<br />通常与锁（特别是 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a>）一起使用，为线程提供了一种等待某个条件成真的机制，并允许其他线程在该条件变化时通知等待线程。更灵活、更强大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageBox</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!empty) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        empty = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (empty) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        empty = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageBox</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBox</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            box.produce(<span class="string">&quot;Message from producer&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> box.consume();</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer received: &quot;</span> + message);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、<strong>使用 Exchanger</strong>，Exchanger 是一个同步点，可以在两个线程之间交换数据。一个线程调用 exchange() 方法，将数据传递给另一个线程，同时接收另一个线程的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Message from thread1&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> exchanger.exchange(message);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 received: &quot;</span> + response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Message from thread2&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> exchanger.exchange(message);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 received: &quot;</span> + response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④、<strong>使用 CompletableFuture</strong>，CompletableFuture 是 Java 8 引入的一个类，支持异步编程，允许线程在完成计算后将结果传递给其他线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟长时间计算</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Message from CompletableFuture&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.thenAccept(message -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Received: &quot;</span> + message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为 OD 的面试中出现过该原题。</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里面经同学 1 闲鱼后端一面的原题：线程之间传递信息?</li></ol></blockquote><p><a name="W5DUp"></a></p><h3 id="10-请说说-sleep-和-wait-的区别？（补充）"><a href="#10-请说说-sleep-和-wait-的区别？（补充）" class="headerlink" title="10.请说说 sleep 和 wait 的区别？（补充）"></a>10.请说说 sleep 和 wait 的区别？（补充）</h3><blockquote><p>2024 年 03 月 21 日增补</p></blockquote><p>答：<code>sleep()</code> 和 <code>wait()</code> 是 Java 中用于暂停当前线程的两个重要方法，sleep 是让当前线程休眠，不涉及对象类，也不需要获取对象的锁，属于 Thread 类的方法；wait 是让获得对象锁的线程实现等待，前提要获得对象的锁，属于 Object 类的方法。<br />它们之间的区别主要有以下几点：<br />①、所属类不同</p><ul><li><code>sleep()</code> 方法专属于 <code>Thread</code> 类。</li><li><code>wait()</code> 方法专属于 <code>Object</code> 类。</li></ul><p>②、锁行为不同<br />当线程执行 sleep 方法时，它不会释放任何锁。也就是说，如果一个线程在持有某个对象的锁时调用了 sleep，它在睡眠期间仍然会持有这个锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepDoesNotReleaseLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">sleepingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 会继续持有锁，并且进入睡眠状态&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 醒来了，并且释放了锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 进入同步代码块&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        sleepingThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        waitingThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 会继续持有锁，并且进入睡眠状态</span><br><span class="line">Thread 1 醒来了，并且释放了锁</span><br><span class="line">Thread 2 进入同步代码块</span><br></pre></td></tr></table></figure><p>从输出中我们可以看到，waitingThread 必须等待 sleepingThread 完成睡眠后才能进入同步代码块。<br />而当线程执行 wait 方法时，它会释放它持有的那个对象的锁，这使得其他线程可以有机会获取该对象的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitReleasesLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 持有锁，准备等待 5 秒&quot;</span>);</span><br><span class="line">                    lock.wait(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 醒来了，并且退出同步代码块&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">notifyingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 尝试唤醒等待中的线程&quot;</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 执行完了 notify&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        waitingThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        notifyingThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 持有锁，准备等待 5 秒</span><br><span class="line">Thread 2 尝试唤醒等待中的线程</span><br><span class="line">Thread 2 执行完了 notify</span><br><span class="line">Thread 1 醒来了，并且退出同步代码块</span><br></pre></td></tr></table></figure><p>这表明 waitingThread 在调用 wait 后确实释放了锁。<br />③、使用条件不同</p><ul><li><code>sleep()</code> 方法可以在任何地方被调用。</li><li><code>wait()</code> 方法必须在同步代码块或同步方法中被调用，这是因为调用 <code>wait()</code> 方法的前提是当前线程必须持有对象的锁。否则会抛出 <code>IllegalMonitorStateException</code> 异常。</li></ul><p>④、唤醒方式不同</p><ul><li>调用 sleep 方法后，线程会进入 TIMED_WAITING 状态（定时等待状态），即在指定的时间内暂停执行。当指定的时间结束后，线程会自动恢复到 RUNNABLE 状态（就绪状态），等待 CPU 调度再次执行。</li><li>调用 wait 方法后，线程会进入 WAITING 状态（无限期等待状态），直到有其他线程在同一对象上调用 notify 或 notifyAll，线程才会从 WAITING 状态转变为 RUNNABLE 状态，准备再次获得 CPU 的执行权。</li></ul><p>⑤、抛出异常不同</p><ul><li><code>sleep()</code> 方法在等待期间，如果线程被中断，会抛出 <code>InterruptedException</code>。</li><li>如果线程被中断或等待时间到期时，<code>wait()</code> 方法同样会在等待期间抛出 <code>InterruptedException</code>。</li></ul><p>我们来通过代码再感受一下 <code>sleep()</code> 和 <code>wait()</code> 在用法上的区别，先看 <code>sleep()</code> 的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程准备休眠 2 秒&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 线程将睡眠2秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程醒来了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>wait()</code> 的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程准备等待 2 秒&quot;</span>);</span><br><span class="line">                    lock.wait(<span class="number">2000</span>); <span class="comment">// 线程会等待2秒，或者直到其他线程调用 lock.notify()/notifyAll()</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程结束等待&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="RK0s7"></a></p><h3 id="11-线程安全，说一个使用场景？（补充）"><a href="#11-线程安全，说一个使用场景？（补充）" class="headerlink" title="11.线程安全，说一个使用场景？（补充）"></a>11.线程安全，说一个使用场景？（补充）</h3><blockquote><p>2024 年 05 月 01 日增补</p></blockquote><p>线程安全是 Java 并发编程中一个非常重要的概念，它指的是多线程环境下，多个线程对共享资源的访问不会导致数据的不一致性。<br />一个常见的使用场景是在实现单例模式时确保线程安全。<br />单例模式确保一个类只有一个实例，并提供一个全局访问点。在多线程环境下，如果多个线程同时尝试创建实例，单例类必须确保只创建一个实例。<br />饿汉式是一种比较直接的实现方式，它通过在类加载时就立即初始化单例对象来保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式单例则在第一次使用时初始化，这种方式需要使用双重检查锁定来确保线程安全，volatile 用来保证可见性，syncronized 用来保证同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IBOtH"></a></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a name="FrtYg"></a></p><h3 id="12-ThreadLocal-是什么？"><a href="#12-ThreadLocal-是什么？" class="headerlink" title="12.ThreadLocal 是什么？"></a>12.ThreadLocal 是什么？</h3><p><a href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-11.png"><br />在 Web 应用中，可以使用 ThreadLocal 存储用户会话信息，这样每个线程在处理用户请求时都能方便地访问当前用户的会话信息。<br />在数据库操作中，可以使用 ThreadLocal 存储数据库连接对象，每个线程有自己独立的数据库连接，从而避免了多线程竞争同一数据库连接的问题。<br />在格式化操作中，例如日期格式化，可以使用 ThreadLocal 存储 SimpleDateFormat 实例，避免多线程共享同一实例导致的线程安全问题。<br />使用 ThreadLocal 通常分为四步：<br />①、创建 ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ThreadLocal变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>②、设置 ThreadLocal 的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置ThreadLocal变量的值</span></span><br><span class="line">localVariable.set(<span class="string">&quot;沉默王二是沙雕&quot;</span>);</span><br></pre></td></tr></table></figure><p>③、获取 ThreadLocal 的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal变量的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> localVariable.get();</span><br></pre></td></tr></table></figure><p>④、删除 ThreadLocal 的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除ThreadLocal变量的值</span></span><br><span class="line">localVariable.remove();</span><br></pre></td></tr></table></figure><p><a name="KpXJD"></a></p><h4 id="除了-ThreadLocal，还有什么解决线程安全问题的方法？"><a href="#除了-ThreadLocal，还有什么解决线程安全问题的方法？" class="headerlink" title="除了 ThreadLocal，还有什么解决线程安全问题的方法？"></a>除了 ThreadLocal，还有什么解决线程安全问题的方法？</h4><p>①、Java 中的 synchronized 关键字可以用于方法和代码块，确保同一时间只有一个线程可以执行特定的代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 线程安全的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、Java 并发包（java.util.concurrent.locks）中提供了 Lock 接口和一些实现类，如 ReentrantLock。相比于 synchronized，ReentrantLock 提供了公平锁和非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 线程安全的操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③、Java 并发包还提供了一组原子变量类（如 AtomicInteger，AtomicLong 等），它们利用 CAS（比较并交换），实现了无锁的原子操作，适用于简单的计数器场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    atomicInteger.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④、Java 并发包提供了一些线程安全的集合类，如 ConcurrentHashMap，CopyOnWriteArrayList 等。这些集合类内部实现了必要的同步策略，提供了更高效的并发访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>⑤、volatile 变量保证了变量的可见性，修改操作是立即同步到主存的，读操作从主存中读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><a name="UNHik"></a></p><h3 id="13-你在工作中用到过-ThreadLocal-吗？"><a href="#13-你在工作中用到过-ThreadLocal-吗？" class="headerlink" title="13.你在工作中用到过 ThreadLocal 吗？"></a>13.你在工作中用到过 ThreadLocal 吗？</h3><p>有用到过，用来存储用户信息。<br /><a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>是典型的 MVC 架构，登录后的用户每次访问接口，都会在请求头中携带一个 token，在控制层可以根据这个 token，解析出用户的基本信息。<br />假如在服务层和持久层也要用到用户信息，就可以在控制层拦截请求把用户信息存入 ThreadLocal。<br />这样我们在任何一个地方，都可以取出 ThreadLocal 中存的用户信息。<br />很多其它场景的 cookie、session 等等数据隔离都可以通过 ThreadLocal 去实现。<br />数据库连接池也可以用 ThreadLocal，将数据库连接池的连接交给 ThreadLocal 进行管理，能够保证当前线程的操作都是同一个 Connnection。<br><a name="UBzMw"></a></p><h3 id="14-ThreadLocal-怎么实现的呢？"><a href="#14-ThreadLocal-怎么实现的呢？" class="headerlink" title="14.ThreadLocal 怎么实现的呢？"></a>14.ThreadLocal 怎么实现的呢？</h3><p>ThreadLocal 本身并不存储任何值，它只是作为一个映射，来映射线程的局部变量。当一个线程调用 ThreadLocal 的 set 或 get 方法时，实际上是访问线程自己的 ThreadLocal.ThreadLocalMap。<br />ThreadLocalMap 是 ThreadLocal 的静态内部类，它内部维护了一个 Entry 数组，key 是 ThreadLocal 对象，value 是线程的局部变量本身。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-13.png"><br />早期的 ThreadLocal 不是这样的，它的 ThreadLocalMap 中使用 Thread 作为 key，这也是最简单的实现方式。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240429112840.png"><br />优化后的方案有两个好处，一个是 Map 中存储的键值对变少了；另一个是 ThreadLocalMap 的生命周期和线程一样长，线程销毁的时候，ThreadLocalMap 也会被销毁。<br />Entry 继承了 WeakReference，它限定了 key 是一个弱引用，弱引用的好处是当内存不足时，JVM 会回收 ThreadLocal 对象，并且将其对应的 Entry 的 value 设置为 null，这样在很大程度上可以避免内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">//key赋值</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="comment">//value赋值</span></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 的实现原理就是，每个线程维护一个 Map，key 为 ThreadLocal 对象，value 为想要实现线程隔离的对象。<br />1、当需要存线程隔离的对象时，通过 ThreadLocal 的 set 方法将对象存入 Map 中。<br />2、当需要取线程隔离的对象时，通过 ThreadLocal 的 get 方法从 Map 中取出对象。<br />3、Map 的大小由 ThreadLocal 对象的多少决定。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407205747.png"><br><a name="zklfM"></a></p><h4 id="什么是弱引用，什么是强引用？"><a href="#什么是弱引用，什么是强引用？" class="headerlink" title="什么是弱引用，什么是强引用？"></a>什么是弱引用，什么是强引用？</h4><p>强引用，比如说 <code>User user = new User(&quot;沉默王二&quot;)</code> 中，user 就是一个强引用，<code>new User(&quot;沉默王二&quot;)</code> 就是一个强引用对象。<br />当 user 被置为 null 时（<code>user = null</code>），<code>new User(&quot;沉默王二&quot;)</code> 将会被垃圾回收；如果 user 不被置为 null，即便是内存空间不足，JVM 也不会回收 <code>new User(&quot;沉默王二&quot;)</code> 这个强引用对象，宁愿抛出 OutOfMemoryError。<br />弱引用，比如说下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;User&gt; userThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">userThreadLocal.set(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;沉默王二&quot;</span>));</span><br></pre></td></tr></table></figure><p>①、userThreadLocal 是一个强引用，<code>new ThreadLocal&lt;&gt;()</code> 是一个强引用对象；<br />②、<code>new User(&quot;沉默王二&quot;)</code> 是一个强引用对象。<br />③、在 ThreadLocalMap 中，<code>key = new ThreadLocal&lt;&gt;()</code> 是一个弱引用对象。当 JVM 进行垃圾回收时，如果发现了弱引用对象，就会将其回收。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-14.png"><br />其关系链就是：</p><ul><li>ThreadLocal 强引用 -&gt; ThreadLocal 对象。</li><li>Thread 强引用 -&gt; ThreadLocalMap。</li><li><code>ThreadLocalMap[i]</code> 强引用了 -&gt; Entry。</li><li>Entry.key 弱引用 -&gt; ThreadLocal 对象。</li><li>Entry.value 强引用 -&gt; 线程的局部变量对象。<br><a name="QBSyz"></a></li></ul><h3 id="15-ThreadLocal-内存泄露是怎么回事？"><a href="#15-ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="15.ThreadLocal 内存泄露是怎么回事？"></a>15.ThreadLocal 内存泄露是怎么回事？</h3><p>通常情况下，随着线程 Thread 的结束，其内部的 ThreadLocalMap 也会被回收，从而避免了内存泄漏。<br />但如果一个线程一直在运行，并且其 <code>ThreadLocalMap</code> 中的 Entry.value 一直指向某个强引用对象，那么这个对象就不会被回收，从而导致内存泄漏。当 Entry 非常多时，可能就会引发更严重的内存溢出问题。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407212932.png"><br><a name="q8zaj"></a></p><h4 id="那怎么解决内存泄漏问题呢？"><a href="#那怎么解决内存泄漏问题呢？" class="headerlink" title="那怎么解决内存泄漏问题呢？"></a>那怎么解决内存泄漏问题呢？</h4><p>很简单，使用完 ThreadLocal 后，及时调用 <code>remove()</code> 方法释放内存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(value);</span><br><span class="line">    <span class="comment">// 执行业务操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove(); <span class="comment">// 确保能够执行清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove()</code> 方法会将当前线程的 ThreadLocalMap 中的所有 key 为 null 的 Entry 全部清除，这样就能避免内存泄漏问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">            e != <span class="literal">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.referent = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="eJezc"></a></p><h4 id="那为什么-key-要设计成弱引用？"><a href="#那为什么-key-要设计成弱引用？" class="headerlink" title="那为什么 key 要设计成弱引用？"></a>那为什么 key 要设计成弱引用？</h4><p>弱引用的好处是，当内存不足的时候，JVM 会主动回收掉弱引用的对象。<br />比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WeakReference</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>());</span><br></pre></td></tr></table></figure><p>key 是弱引用，<code>new WeakReference(new ThreadLocal())</code> 是弱引用对象，当 JVM 进行垃圾回收时，如果发现了弱引用对象，就会将其回收。<br />一旦 key 被回收，ThreadLocalMap 在进行 set、get 的时候就会对 key 为 null 的 Entry 进行清理。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407214616.png"><br />总结一下，在 ThreadLocal 被垃圾收集后，下一次访问 ThreadLocalMap 时，Java 会自动清理那些键为 null 的条目（参照源码中的 replaceStaleEntry 方法），这个过程会在执行 ThreadLocalMap 相关操作（如 <code>get()</code>, <code>set()</code>, <code>remove()</code>）时触发。<br><a name="M5eXD"></a></p><h4 id="你了解哪些-ThreadLocal-的改进方案？"><a href="#你了解哪些-ThreadLocal-的改进方案？" class="headerlink" title="你了解哪些 ThreadLocal 的改进方案？"></a>你了解哪些 ThreadLocal 的改进方案？</h4><p>在 JDK 20 Early-Access Build 28 版本中，出现了 ThreadLocal 的改进方案，即 <code>ScopedValue</code>。<br />还有 Netty 中的 FastThreadLocal，它是 Netty 对 ThreadLocal 的优化，它内部维护了一个索引常量 index，每次创建 FastThreadLocal 中都会自动+1，用来取代 hash 冲突带来的损耗，用空间换时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FastThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextVariableIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nextIndex.getAndIncrement();</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        nextIndex.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="u5Yfg"></a></p><h3 id="16-ThreadLocalMap-的源码看过吗？"><a href="#16-ThreadLocalMap-的源码看过吗？" class="headerlink" title="16.ThreadLocalMap 的源码看过吗？"></a>16.ThreadLocalMap 的源码看过吗？</h3><p>ThreadLocalMap 虽然被叫做 Map，其实它是没有实现 Map 接口的，但是结构还是和 HashMap 比较类似的，主要关注的是两个要素：<code>元素数组</code>和<code>散列方法</code>。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-15.png"></p><ul><li><p>元素数组一个 table 数组，存储 Entry 类型的元素，Entry 是 ThreaLocal 弱引用作为 key，Object 作为 value 的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure></li><li><p>散列方法散列方法就是怎么把对应的 key 映射到 table 数组的相应下标，ThreadLocalMap 用的是哈希取余法，取出 key 的 threadLocalHashCode，然后和 table 数组长度减一&amp;运算（相当于取余）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的 threadLocalHashCode 计算有点东西，每创建一个 ThreadLocal 对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="l4mVp"></a></p></li></ul><h3 id="17-ThreadLocalMap-怎么解决-Hash-冲突的？"><a href="#17-ThreadLocalMap-怎么解决-Hash-冲突的？" class="headerlink" title="17.ThreadLocalMap 怎么解决 Hash 冲突的？"></a>17.ThreadLocalMap 怎么解决 Hash 冲突的？</h3><p>我们可能都知道 HashMap 使用了链表来解决冲突，也就是所谓的链地址法。<br />ThreadLocalMap 没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——<strong>开放定址法</strong>。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-16.png"><br />如上图所示，如果我们插入一个 value&#x3D;27 的数据，通过 hash 计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry 数据，而且 Entry 数据的 key 和当前不相等。此时就会线性向后查找，一直找到 Entry 为 null 的槽位才会停止查找，把元素放到空的槽中。<br />在 get 的时候，也会根据 ThreadLocal 对象的 hash 值，定位到 table 中的位置，然后判断该槽位 Entry 对象中的 key 是否和 get 的 key 一致，如果不一致，就判断下一个位置。<br><a name="xDx9g"></a></p><h3 id="18-ThreadLocalMap-扩容机制了解吗？"><a href="#18-ThreadLocalMap-扩容机制了解吗？" class="headerlink" title="18.ThreadLocalMap 扩容机制了解吗？"></a>18.ThreadLocalMap 扩容机制了解吗？</h3><p>在 ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure><p>再着看 rehash()具体实现：这里会先去清理过期的 Entry，然后还要根据条件判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code>来决定是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//清理过期Entry</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理过期Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着看看具体的<code>resize()</code>方法，扩容后的<code>newTab</code>的大小为老数组的两倍，然后遍历老的 table 数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code>，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后 table 引用指向<code>newTab</code><br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-17.png"><br><a name="Ccihf"></a></p><h3 id="19-父子线程怎么共享数据？"><a href="#19-父子线程怎么共享数据？" class="headerlink" title="19.父子线程怎么共享数据？"></a>19.父子线程怎么共享数据？</h3><p>父线程能用 ThreadLocal 来给子线程传值吗？毫无疑问，不能。那该怎么办？<br />这时候可以用到另外一个类——<code>InheritableThreadLocal </code>。<br />使用起来很简单，在主线程的 InheritableThreadLocal 实例设置值，在子线程中就可以拿到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        threadLocal.set(<span class="string">&quot;不擅技术&quot;</span>);</span><br><span class="line">        <span class="comment">//子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">                System.out.println(<span class="string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那原理是什么呢？</p></blockquote><p>原理很简单，在 Thread 类里还有另外一个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>在 Thread.init 的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals </code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure><p><a name="N6dCa"></a></p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><a name="Ykt8F"></a></p><h3 id="20-说一下你对-Java-内存模型的理解？"><a href="#20-说一下你对-Java-内存模型的理解？" class="headerlink" title="20.说一下你对 Java 内存模型的理解？"></a>20.说一下你对 Java 内存模型的理解？</h3><p>推荐阅读：<a href="https://javabetter.cn/thread/jmm.html">说说 Java 的内存模型</a><br />Java 内存模型（Java Memory Model）是一种抽象的模型，简称 JMM，主要用来定义多线程中变量的访问规则，用来解决变量的可见性、有序性和原子性问题，确保在并发环境中安全地访问共享变量。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2.jpeg"><br />JMM 定义了线程内存和主内存之间的抽象关系：线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了共享变量的副本，用来进行线程内部的读写操作。</p><ul><li>当一个线程更改了本地内存中共享变量的副本后，它需要将这些更改刷新到主内存中，以确保其他线程可以看到这些更改。</li><li>当一个线程需要读取共享变量时，它可能首先从本地内存中读取。如果本地内存中的副本是过时的，线程将从主内存中重新加载共享变量的最新值到本地内存中。</li></ul><p>本地内存是 JMM 中的一个抽象概念，并不真实存在。实际上，本地内存可能对应于 CPU 缓存、寄存器或者其他硬件和编译器优化。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20.png"><br />对于一个双核 CPU 的系统架构，每个核都有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。<br />每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。<br />Java 内存模型里面的本地内存，可能对应的是 L1 缓存或者 L2 缓存或者 CPU 寄存器。<br><a name="NFqcs"></a></p><h4 id="为什么线程要用自己的内存？"><a href="#为什么线程要用自己的内存？" class="headerlink" title="为什么线程要用自己的内存？"></a>为什么线程要用自己的内存？</h4><p>第一，在多线程环境中，如果所有线程都直接操作主内存中的共享变量，会引发更多的内存访问竞争，这不仅影响性能，还增加了线程安全问题的复杂度。通过让每个线程使用本地内存，可以减少对主内存的直接访问和竞争，从而提高程序的并发性能。<br />第二，现代 CPU 为了优化执行效率，可能会对指令进行乱序执行（指令重排序）。使用本地内存（CPU 缓存和寄存器）可以在不影响最终执行结果的前提下，使得 CPU 有更大的自由度来乱序执行指令，从而提高执行效率。<br><a name="IqiCC"></a></p><h3 id="21-说说你对原子性、可见性、有序性的理解？"><a href="#21-说说你对原子性、可见性、有序性的理解？" class="headerlink" title="21.说说你对原子性、可见性、有序性的理解？"></a>21.说说你对原子性、可见性、有序性的理解？</h3><ul><li><strong>原子性</strong>：指的是一个操作是不可分割的，要么全部执行成功，要么完全不执行。</li><li><strong>可见性</strong>：指的是一个线程对共享变量的修改，能够被其他线程及时看见。</li><li><strong>有序性</strong>：指的是程序代码的执行顺序与代码中的顺序一致。在没有同步机制的情况下，编译器可能会对指令进行重排序，以优化性能。这种重排序可能会导致多线程的执行结果与预期不符。<br><a name="yjNaR"></a></li></ul><h4 id="原子性、可见性、有序性都应该怎么保证呢？"><a href="#原子性、可见性、有序性都应该怎么保证呢？" class="headerlink" title="原子性、可见性、有序性都应该怎么保证呢？"></a>原子性、可见性、有序性都应该怎么保证呢？</h4><ul><li>原子性：JMM 只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<code>synchronized </code>。</li><li>可见性：Java 是利用<code>volatile</code>关键字来保证可见性的，除此之外，<code>final</code>和<code>synchronized</code>也能保证可见性。</li><li>有序性：<code>synchronized</code>或者<code>volatile</code>都可以保证多线程之间操作的有序性。<br><a name="f8mxL"></a></li></ul><h4 id="i-是原子操作吗？"><a href="#i-是原子操作吗？" class="headerlink" title="i++是原子操作吗？"></a>i++是原子操作吗？</h4><p>i++ 不是一个原子操作，它包括三个步骤：</p><ol><li>从内存中读取 i 的值。</li><li>对 i 进行加 1 操作。</li><li>将新的值写入内存。</li></ol><p>假如两个线程同时对 i 进行 i++ 操作时，可能会发生以下情况：</p><ol><li>线程 A 读取 i 的值（假设 i 的初始值为 1）。</li><li>线程 B 也读取 i 的值（值仍然是 1）。</li><li>线程 A 将 i 增加到 2，并将其写回内存。</li><li>线程 B 也将 i 增加到 2，并将其写回内存。</li></ol><p>尽管进行了两次递增操作，i 的值只增加了 1 而不是 2。可以使用 synchronized 或 AtomicInteger 确保操作的原子性。<br><a name="GdE4p"></a></p><h3 id="22-那说说什么是指令重排？"><a href="#22-那说说什么是指令重排？" class="headerlink" title="22.那说说什么是指令重排？"></a>22.那说说什么是指令重排？</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分 3 种类型。</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面 3 种重排序，如图：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-21.png"><br />我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，<code>Singleton instance=new Singleton()；</code>对应的 JVM 指令分为三步：分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-22.png"><br />JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。<br><a name="LxXOf"></a></p><h3 id="23-指令重排有限制吗？happens-before-了解吗？"><a href="#23-指令重排有限制吗？happens-before-了解吗？" class="headerlink" title="23.指令重排有限制吗？happens-before 了解吗？"></a>23.指令重排有限制吗？happens-before 了解吗？</h3><p>指令重排也是有一些限制的，有两个规则<code>happens-before</code>和<code>as-if-serial</code>来约束。<br />happens-before 的定义：</p><ul><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法</li></ul><p>happens-before 和我们息息相关的有六大规则：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-23.png"></p><ul><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li><li><strong>volatile 变量规则</strong>：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li><strong>传递性</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li><strong>start()规则</strong>：如果线程 A 执行操作 ThreadB.start()（启动线程 B），那么 A 线程的 ThreadB.start()操作 happens-before 于线程 B 中的任意操作。</li><li><strong>join()规则</strong>：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。<br><a name="pBa34"></a></li></ul><h3 id="24-as-if-serial-又是什么？单线程的程序一定是顺序的吗？"><a href="#24-as-if-serial-又是什么？单线程的程序一定是顺序的吗？" class="headerlink" title="24.as-if-serial 又是什么？单线程的程序一定是顺序的吗？"></a>24.as-if-serial 又是什么？单线程的程序一定是顺序的吗？</h3><p>as-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），<strong>单线程程序的执行结果不能被改变</strong>。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。<br />为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;   <span class="comment">// A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1.0</span>;   <span class="comment">// B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>上面 3 个操作的数据依赖关系：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-24.png"><br />A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。<br />所以最终，程序可能会有两种执行顺序：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-25.png"><br />as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器、runtime 和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial 语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。<br><a name="J62kQ"></a></p><h3 id="25-volatile-实现原理了解吗？"><a href="#25-volatile-实现原理了解吗？" class="headerlink" title="25.volatile 实现原理了解吗？"></a>25.volatile 实现原理了解吗？</h3><p>volatile 关键字主要有两个作用，一个是保证变量的内存可见性，一个是禁止指令重排序。<br><a name="ZKPT7"></a></p><h4 id="volatile-怎么保证可见性的呢？"><a href="#volatile-怎么保证可见性的呢？" class="headerlink" title="volatile 怎么保证可见性的呢？"></a>volatile 怎么保证可见性的呢？</h4><p>当一个变量被声明为 volatile 时，Java 内存模型会确保所有线程看到该变量时的值是一致的。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2.jpeg"><br />也就是说，当线程对 volatile 变量进行写操作时，JMM 会在写入这个变量之后插入一个 Store-Barrier（写屏障）指令，这个指令会强制将本地内存中的变量值刷新到主内存中。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-28.png"><br />当线程对 volatile 变量进行读操作时，JMM 会插入一个 Load-Barrier（读屏障）指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-29.png"><br />例如，我们声明一个 volatile 变量 x：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>线程 A 对 x 写入后会将其最新的值刷新到主内存中，线程 B 读取 x 时由于本地内存中的 x 失效了，就会从主内存中读取最新的值，内存可见性达成！<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-26.png"><br><a name="QqUeL"></a></p><h4 id="volatile-怎么保证有序性的呢？"><a href="#volatile-怎么保证有序性的呢？" class="headerlink" title="volatile 怎么保证有序性的呢？"></a>volatile 怎么保证有序性的呢？</h4><p>在程序执行期间，为了提高性能，编译器和处理器会对指令进行重排序。但涉及到 volatile 变量时，它们必须遵循一定的规则：</p><ul><li>写 volatile 变量的操作之前的操作不会被编译器重排序到写操作之后。</li><li>读 volatile 变量的操作之后的操作不会被编译器重排序到读操作之前。</li></ul><p>这意味着 volatile 变量的写操作总是发生在任何后续读操作之前。<br><a name="Y1iyq"></a></p><h4 id="volatile-和-synchronized-的区别"><a href="#volatile-和-synchronized-的区别" class="headerlink" title="volatile 和 synchronized 的区别"></a>volatile 和 synchronized 的区别</h4><p>volatile 关键字用于修饰变量，确保该变量的更新操作对所有线程是可见的，即一旦某个线程修改了 volatile 变量，其他线程会立即看到最新的值。<br />synchronized 关键字用于修饰方法或代码块，确保同一时刻只有一个线程能够执行该方法或代码块，从而实现互斥访问。<br><a name="xmrsW"></a></p><h4 id="volatile-加在基本类型和对象上的区别？"><a href="#volatile-加在基本类型和对象上的区别？" class="headerlink" title="volatile 加在基本类型和对象上的区别？"></a>volatile 加在基本类型和对象上的区别？</h4><p>当 <code>volatile</code> 用于基本数据类型时，能确保该变量的读写操作是直接从主内存中读取或写入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当 <code>volatile</code> 用于引用类型时，它确保引用本身的可见性，即确保引用指向的对象地址是最新的。<br />但是，<code>volatile</code> 并不能保证引用对象内部状态的线程安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">SomeObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeObject</span>();</span><br></pre></td></tr></table></figure><p>虽然 <code>volatile</code> 确保了 <code>obj</code> 引用的可见性，但对 <code>obj</code> 引用的具体对象的操作并不受 <code>volatile</code> 保护。如果需要保证引用对象内部状态的线程安全，需要使用其他同步机制（如 <code>synchronized</code> 或 <code>ReentrantLock</code>）。<br><a name="BiWhR"></a></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a name="p0TpD"></a></p><h3 id="26-synchronized-用过吗？怎么使用？"><a href="#26-synchronized-用过吗？怎么使用？" class="headerlink" title="26.synchronized 用过吗？怎么使用？"></a>26.synchronized 用过吗？怎么使用？</h3><p>在 Java 中，synchronized 是最常用的锁，它使用简单，并且可以保证线程安全，避免多线程并发访问时出现数据不一致的情况。<br />随着 JDK 版本的进化，synchronized 的性能也得到了进一步的提升，不再像以前样重量级了。<br />synchronized 可以用在方法和代码块中。<br />①、修饰方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在方法声明中使用了 synchronized 关键字，就表示该方法是同步的，也就是说，线程在执行这个方法的时候，其他线程不能同时执行，需要等待锁释放。<br />如果是静态方法的话，锁的是这个类的 Class 对象，因为静态方法是属于类级别的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②、修饰代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步代码块可以减少需要同步的代码量，颗粒度更低，更灵活。synchronized 后面的括号中指定了要锁定的对象，可以是 this，也可以是其他对象。<br><a name="raVrI"></a></p><h3 id="27-synchronized-的实现原理？"><a href="#27-synchronized-的实现原理？" class="headerlink" title="27.synchronized 的实现原理？"></a>27.synchronized 的实现原理？</h3><p><a name="yEPd2"></a></p><h4 id="synchronized-是怎么加锁的呢？"><a href="#synchronized-是怎么加锁的呢？" class="headerlink" title="synchronized 是怎么加锁的呢？"></a>synchronized 是怎么加锁的呢？</h4><p>synchronized 是 JVM 帮我们实现的，因此在使用的时候不用手动去 lock 和 unlock，JVM 会帮我们自动加锁和解锁。<br />①、synchronized 修饰代码块时，JVM 会通过 <code>monitorenter</code>、<code>monitorexit</code> 两个指令来实现同步：</p><ul><li><code>monitorenter</code> 指向同步代码块的开始位置</li><li><code>monitorexit</code> 指向同步代码块的结束位置。</li></ul><p>使用 <code>javap -c -s -v -l SynchronizedDemo.class</code> 反编译一段 synchronized 代码块时，可以看到 monitorenter 和 monitorexit 指令。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-30.png"><br />②、synchronized 修饰方法时，JVM 会通过 <code>ACC_SYNCHRONIZED</code> 标记符来实现同步。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-31.png"><br><a name="zd0u4"></a></p><h4 id="synchronized-锁住的是什么呢？"><a href="#synchronized-锁住的是什么呢？" class="headerlink" title="synchronized 锁住的是什么呢？"></a>synchronized 锁住的是什么呢？</h4><p>monitorenter、monitorexit 或者 ACC_SYNCHRONIZED 都是<strong>基于 Monitor 实现</strong>的。<br />实例对象结构里有对象头，对象头里面有一块结构叫 Mark Word，Mark Word 指针指向了<strong>monitor</strong>。<br />所谓的 Monitor 其实是一种<strong>同步工具</strong>，也可以说是一种<strong>同步机制</strong>。在 Java 虚拟机（HotSpot）中，Monitor 是由<strong>ObjectMonitor 实现</strong>的，可以叫做内部锁，或者 Monitor 锁。<br />ObjectMonitor 的工作原理：</p><ul><li><p>ObjectMonitor 有两个队列：_WaitSet、_EntryList，用来保存 ObjectWaiter 对象列表。</p></li><li><p>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录线程获取锁的次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//锁的重入次数</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  <span class="comment">// 指向持有ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = NULL;  <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;  <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以我们就知道了，同步是锁住的什么东西：</p></li><li><p>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</p></li><li><p>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。<br><a name="ca0Dz"></a></p></li></ul><h4 id="会不会牵扯到-os-层面呢？"><a href="#会不会牵扯到-os-层面呢？" class="headerlink" title="会不会牵扯到 os 层面呢？"></a>会不会牵扯到 os 层面呢？</h4><p>会，synchronized 升级为重量级锁时，依赖于操作系统的互斥量（mutex）来实现，mutex 用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段。<br><a name="Btdtg"></a></p><h3 id="28-除了原子性，synchronized-可见性，有序性，可重入性怎么实现？"><a href="#28-除了原子性，synchronized-可见性，有序性，可重入性怎么实现？" class="headerlink" title="28.除了原子性，synchronized 可见性，有序性，可重入性怎么实现？"></a>28.除了原子性，synchronized 可见性，有序性，可重入性怎么实现？</h3><p><a name="FDYvU"></a></p><h4 id="synchronized-怎么保证可见性？"><a href="#synchronized-怎么保证可见性？" class="headerlink" title="synchronized 怎么保证可见性？"></a>synchronized 怎么保证可见性？</h4><ul><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>线程加锁后，其它线程无法获取主内存中的共享变量。</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。<br><a name="YMmYX"></a></li></ul><h4 id="synchronized-怎么保证有序性？"><a href="#synchronized-怎么保证有序性？" class="headerlink" title="synchronized 怎么保证有序性？"></a>synchronized 怎么保证有序性？</h4><p>synchronized 同步的代码块，具有排他性，一次只能被一个线程拥有，所以 synchronized 保证同一时刻，代码是单线程执行的。<br />因为 as-if-serial 语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。<br />所以 synchronized 保证的有序是执行结果的有序性，而不是防止指令重排的有序性。<br><a name="UepPI"></a></p><h4 id="synchronized-怎么实现可重入的呢？"><a href="#synchronized-怎么实现可重入的呢？" class="headerlink" title="synchronized 怎么实现可重入的呢？"></a>synchronized 怎么实现可重入的呢？</h4><p>可重入意味着同一个线程可以多次获得同一个锁，而不会被阻塞。具体来说，如果一个线程已经持有某个锁，那么它可以再次进入该锁保护的代码块或方法，而不会被阻塞。<br />synchronized 之所以支持可重入，是因为 Java 的对象头包含了一个 Mark Word，用于存储对象的状态，包括锁信息。<br />当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。<br />如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。如果 ID 匹配，表示的是同一个线程，锁计数器递增。<br />当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。<br><a name="lopyl"></a></p><h3 id="29-锁升级？synchronized-优化了解吗？"><a href="#29-锁升级？synchronized-优化了解吗？" class="headerlink" title="29.锁升级？synchronized 优化了解吗？"></a>29.锁升级？synchronized 优化了解吗？</h3><p>推荐阅读：<a href="https://javabetter.cn/thread/synchronized.html">偏向锁、轻量级锁、重量级锁到底是什么？</a><br><a name="m5LOP"></a></p><h4 id="什么是锁升级？"><a href="#什么是锁升级？" class="headerlink" title="什么是锁升级？"></a>什么是锁升级？</h4><p>锁升级是 Java 虚拟机中的一个优化机制，用于提高多线程环境下 synchronized 的并发性能。锁升级涉及从较轻的锁状态（如无锁或偏向锁）逐步升级到较重的锁状态（如轻量级锁和重量级锁），以适应不同程度的竞争情况。<br />Java 对象头里的 <code>Mark Word</code> 会记录锁的状态，一共有四种状态：<br />①、无锁状态，在这个状态下，没有线程试图获取锁。<br />②、偏向锁，当第一个线程访问同步块时，锁会进入偏向模式。Mark Word 会被设置为偏向模式，并且存储了获取它的线程 ID。<br />偏向锁的目的是消除同一线程的后续锁获取和释放的开销。如果同一线程再次请求锁，就无需再次同步。<br />③、当有多个线程竞争锁，但没有锁竞争的强烈迹象（即线程交替执行同步块）时，偏向锁会升级为轻量级锁。<br />线程尝试通过<a href="https://javabetter.cn/thread/cas.html">CAS 操作</a>（Compare-And-Swap）将对象头的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获取轻量级锁；如果失败，说明有竞争。<br />④、重量级锁，当锁竞争激烈时，轻量级锁会膨胀为重量级锁。<br />重量级锁通过将对象头的 Mark Word 指向监视器（Monitor）对象来实现，该对象包含了锁的持有者、锁的等待队列等信息。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-34.png"><br><a name="J0dgX"></a></p><h4 id="synchronized-做了哪些优化？"><a href="#synchronized-做了哪些优化？" class="headerlink" title="synchronized 做了哪些优化？"></a>synchronized 做了哪些优化？</h4><p>在 JDK1.6 之前，synchronized 是直接调用 ObjectMonitor 的 enter 和 exit 实现的，这种锁也被称为<strong>重量级锁</strong>。这也是为什么很多声音说不要用 synchronized 的原因，有点“谈虎色变”的感觉。<br />从 JDK 1.6 开始，HotSpot 对 Java 中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，极大提升了 synchronized 的性能。<br /><strong>①、偏向锁</strong>：当一个线程首次获得锁时，JVM 会将锁标记为偏向这个线程，将锁的标志位设置为偏向模式，并且在对象头中记录下该线程的 ID。<br />之后，当相同的线程再次请求这个锁时，就无需进行额外的同步。如果另一个线程尝试获取这个锁，偏向模式会被撤销，并且锁会升级为轻量级锁。<br /><strong>②、轻量级锁</strong>：多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。<br />当一个线程尝试获取轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record），然后尝试使用 CAS 操作将对象头的 Mark Word 替换为指向锁记录的指针。<br />如果成功，该线程持有锁；如果失败，表示有其他线程竞争，锁会升级为重量级锁。<br /><strong>③、自旋锁</strong>：当线程尝试获取轻量级锁失败时，它会进行自旋，即循环检查锁是否可用，以避免立即进入阻塞状态。<br />自旋的次数不是固定的，而是根据之前在同一个锁上的自旋时间和锁的状态动态调整的。<br /><strong>④、锁粗化</strong>：如果 JVM 检测到一系列连续的锁操作实际上是在单一线程中完成的，则会将多个锁操作合并为一个更大范围的锁操作，这可以减少锁请求的次数。<br />锁粗化主要针对循环内连续加锁解锁的情况进行优化。<br /><strong>⑤、锁消除</strong>：JVM 的即时编译器（<a href="https://javabetter.cn/jvm/jit.html">JIT</a>）可以在运行时进行代码分析，如果发现某些锁操作不可能被多个线程同时访问，那么这些锁操作就会被完全消除。锁消除可以减少不必要的同步开销。<br><a name="QDTKM"></a></p><h4 id="锁升级的过程是什么样的？"><a href="#锁升级的过程是什么样的？" class="headerlink" title="锁升级的过程是什么样的？"></a>锁升级的过程是什么样的？</h4><p>无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-35.png"><br />大体上省简的升级过程是这样的：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-36.png"><br />完整的升级过程是这样的：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-37.png"><br /><strong>①、从无锁到偏向锁：</strong><br />当一个线程首次访问同步块时，如果此对象无锁状态且偏向锁未被禁用，JVM 会将该对象头的锁标记改为偏向锁状态，并记录下当前线程的 ID。此时，对象头中的 Mark Word 中存储了持有偏向锁的线程 ID。<br />如果另一个线程尝试获取这个已被偏向的锁，JVM 会检查当前持有偏向锁的线程是否活跃。如果持有偏向锁的线程不活跃，则可以将锁重偏向至新的线程；如果持有偏向锁的线程还活跃，则需要撤销偏向锁，升级为轻量级锁。<br /><strong>②、偏向锁的轻量级锁：</strong><br />进行偏向锁撤销时，会遍历堆栈的所有锁记录，暂停拥有偏向锁的线程，并检查锁对象。如果这个过程中发现有其他线程试图获取这个锁，JVM 会撤销偏向锁，并将锁升级为轻量级锁。<br />当有两个或以上线程竞争同一个偏向锁时，偏向锁模式不再有效，此时偏向锁会被撤销，对象的锁状态会升级为轻量级锁。<br /><strong>③、轻量级锁到重量级锁：</strong><br />轻量级锁通过线程自旋来等待锁释放。如果自旋超过预定次数（自旋次数是可调的，并且自适应的），表明锁竞争激烈，轻量级锁的自旋已经不再高效。<br />当自旋等待失败，或者有线程在等待队列中等待相同的轻量级锁时，轻量级锁会升级为重量级锁。在这种情况下，JVM 会在操作系统层面创建一个互斥锁（Mutex），所有进一步尝试获取该锁的线程将会被阻塞，直到锁被释放。<br><a name="Jf4rR"></a></p><h3 id="30-说说-synchronized-和-ReentrantLock-的区别？"><a href="#30-说说-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="30.说说 synchronized 和 ReentrantLock 的区别？"></a>30.说说 synchronized 和 ReentrantLock 的区别？</h3><p><a href="https://javabetter.cn/thread/synchronized-1.html">synchronized</a> 是一个关键字，而 Lock 属于一个接口，其实现类主要有 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a>、<a href="https://javabetter.cn/thread/ReentrantReadWriteLock.html">ReentrantReadWriteLock</a>。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-38.png"><br><a name="ade9b"></a></p><h4 id="使用方式有什么不同？"><a href="#使用方式有什么不同？" class="headerlink" title="使用方式有什么不同？"></a>使用方式有什么不同？</h4><p>synchronized 可以直接在方法上加锁，也可以在代码块上加锁（无需手动释放锁，锁会自动释放），而 ReentrantLock 必须手动声明来加锁和释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 修饰方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized 修饰代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock 加锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着 JDK 版本的升级，synchronized 的性能已经可以媲美 ReentrantLock 了，加入了偏向锁、轻量级锁和重量级锁的自适应优化等，所以可以大胆地用。<br><a name="YlZgd"></a></p><h4 id="功能特点有什么不同？"><a href="#功能特点有什么不同？" class="headerlink" title="功能特点有什么不同？"></a>功能特点有什么不同？</h4><p>如果需要更细粒度的控制（如可中断的锁操作、尝试非阻塞获取锁、超时获取锁或者使用公平锁等），可以使用 Lock。</p><ul><li>ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>来实现这个机制。</li><li>ReentrantLock 可以指定是公平锁还是非公平锁。</li><li>ReentrantReadWriteLock 读写锁，读锁是共享锁，写锁是独占锁，读锁可以同时被多个线程持有，写锁只能被一个线程持有。这种锁的设计可以提高性能，特别是在读操作的数量远远超过写操作的情况下。</li></ul><p>Lock 还提供了<code>newCondition()</code>方法来创建等待通知条件<a href="https://javabetter.cn/thread/condition.html">Condition</a>，比 synchronized 与 <code>wait()</code>、 <code>notify()/notifyAll()</code>方法的组合更强大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><p><a name="yDrU3"></a></p><h4 id="并发量大的情况下，使用-synchronized-还是-ReentrantLock？"><a href="#并发量大的情况下，使用-synchronized-还是-ReentrantLock？" class="headerlink" title="并发量大的情况下，使用 synchronized 还是 ReentrantLock？"></a>并发量大的情况下，使用 synchronized 还是 ReentrantLock？</h4><p>在并发量特别高的情况下，ReentrantLock 的性能可能会优于 synchronized，原因包括：</p><ul><li>ReentrantLock 提供了超时和公平锁等特性，可以更好地应对复杂的并发场景 。</li><li>ReentrantLock 允许更细粒度的锁控制，可以有效减少锁竞争。</li><li>ReentrantLock 支持条件变量 Condition，可以实现比 synchronized 更复杂的线程间通信机制。<br><a name="KV0pZ"></a></li></ul><h3 id="31-AQS-了解多少？"><a href="#31-AQS-了解多少？" class="headerlink" title="31.AQS 了解多少？"></a>31.AQS 了解多少？</h3><p>AQS，全称是 AbstractQueuedSynchronizer，中文意思是抽象队列同步器，由 Doug Lea 设计，是 Java 并发包<code>java.util.concurrent</code>的核心框架类，许多同步类的实现都依赖于它，如 ReentrantLock、Semaphore、CountDownLatch 等。<br />AQS 的思想是，如果被请求的共享资源空闲，则当前线程能够成功获取资源；否则，它将进入一个等待队列，当有其他线程释放资源时，系统会挑选等待队列中的一个线程，赋予其资源。<br />整个过程通过维护一个 int 类型的状态和一个先进先出（FIFO）的队列，来实现对共享资源的管理。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-39.png"><br />①、同步状态 state 由 volatile 修饰，保证了多线程之间的可见性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><p>②、同步队列是通过内部定义的 Node 类来实现的，每个 Node 包含了等待状态、前后节点、线程的引用等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 支持两种同步方式：</p><ul><li>独占模式：这种方式下，每次只能有一个线程持有锁，例如 ReentrantLock。</li><li>共享模式：这种方式下，多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。</li></ul><p>子类可以通过继承 AQS 并实现它的方法来管理同步状态，这些方法包括：</p><ul><li><code>tryAcquire</code>：独占方式尝试获取资源，成功则返回 true，失败则返回 false；</li><li><code>tryRelease</code>：独占方式尝试释放资源；</li><li><code>tryAcquireShared(int arg)</code>：共享方式尝试获取资源；</li><li><code>tryReleaseShared(int arg)</code>：共享方式尝试释放资源；</li><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。</li></ul><p>如果共享资源被占用，需要一种特定的阻塞等待唤醒机制来保证锁的分配，AQS 会将竞争共享资源失败的线程添加到一个 CLH 队列中。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-40.png"><br />在 CLH 锁中，当一个线程尝试获取锁并失败时，它会将自己添加到队列的尾部并自旋，等待前一个节点的线程释放锁。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-41.png"><br><a name="PHRJv"></a></p><h3 id="32-ReentrantLock-实现原理？"><a href="#32-ReentrantLock-实现原理？" class="headerlink" title="32.ReentrantLock 实现原理？"></a>32.ReentrantLock 实现原理？</h3><p><a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a> 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞。<br />可重入表示当前线程获取该锁后再次获取不会被阻塞，也就意味着同一个线程可以多次获得同一个锁而不会发生死锁。<br />ReentrantLock 的加锁和解锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建非公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 获取锁操作</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行代码逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁操作</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new ReentrantLock() </code>默认创建的是非公平锁 NonfairSync。在非公平锁模式下，锁可能会授予刚刚请求它的线程，而不考虑等待时间。<br />ReentrantLock 也支持公平锁，该模式下，锁会授予等待时间最长的线程。<br />ReentrantLock 内部通过一个计数器来跟踪锁的持有次数。<br />当线程调用<code>lock()</code>方法获取锁时，ReentrantLock 会检查当前状态，判断锁是否已经被其他线程持有。如果没有被持有，则当前线程将获得锁；如果锁已被其他线程持有，则当前线程将根据锁的公平性策略，可能会被加入到等待队列中。<br />线程首次获取锁时，计数器值变为 1；如果同一线程再次获取锁，计数器增加；每释放一次锁，计数器减 1。<br />当线程调用<code>unlock()</code>方法时，ReentrantLock 会将持有锁的计数减 1，如果计数到达 0，则释放锁，并唤醒等待队列中的线程来竞争锁。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-42.png"><br><a name="ZLHSR"></a></p><h3 id="33-ReentrantLock-怎么实现公平锁的？"><a href="#33-ReentrantLock-怎么实现公平锁的？" class="headerlink" title="33.ReentrantLock 怎么实现公平锁的？"></a>33.ReentrantLock 怎么实现公平锁的？</h3><p>ReentrantLock 的默认构造方法创建的是非公平锁 NonfairSync。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过有参构造方法传递 true 参数来创建公平锁 FairSync。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">--- ReentrantLock</span><br><span class="line"><span class="comment">// true 代表公平锁，false 代表非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync、NonfairSync 都是 ReentrantLock 的内部类，分别实现了公平锁和非公平锁的逻辑。<br><a name="EG6E8"></a></p><h4 id="非公平锁和公平锁有什么不同？"><a href="#非公平锁和公平锁有什么不同？" class="headerlink" title="非公平锁和公平锁有什么不同？"></a>非公平锁和公平锁有什么不同？</h4><p>①、公平锁意味着在多个线程竞争锁时，获取锁的顺序与线程请求锁的顺序相同，即先来先服务（FIFO）。<br />虽然能保证锁的顺序，但实现起来比较复杂，因为需要额外维护一个有序队列。<br />②、非公平锁不保证线程获取锁的顺序，当锁被释放时，任何请求锁的线程都有机会获取锁，而不是按照请求的顺序。<br><a name="fToDV"></a></p><h4 id="怎么实现一个非公平锁呢？"><a href="#怎么实现一个非公平锁呢？" class="headerlink" title="怎么实现一个非公平锁呢？"></a>怎么实现一个非公平锁呢？</h4><p>要实现一个非公平锁，只需要在创建 ReentrantLock 实例时，不传递任何参数或者传递 false 给它的构造方法就好了。<br><a name="dpEsX"></a></p><h3 id="34-CAS-了解多少？"><a href="#34-CAS-了解多少？" class="headerlink" title="34.CAS 了解多少？"></a>34.CAS 了解多少？</h3><p>CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为“比较并交换”，是一种无锁的原子操作。<br />在 Java 中，我们可以使用 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized</a>关键字和 <code>CAS</code> 来实现加锁效果。<br />synchronized 是悲观锁，尽管随着 JDK 版本的升级，synchronized 关键字已经“轻量级”了很多，但依然是悲观锁，线程开始执行第一步就要获取锁，一旦获得锁，其他的线程进入后就会阻塞并等待锁。<br />CAS 是乐观锁，线程执行的时候不会加锁，它会假设此时没有冲突，然后完成某项操作；如果因为冲突失败了就重试，直到成功为止。<br />在 CAS 中，有这样三个值：</p><ul><li>V：要更新的变量(var)</li><li>E：预期值(expected)</li><li>N：新值(new)</li></ul><p>比较并交换的过程如下：<br />判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。<br />这里的预期值 E 本质上指的是“旧值”。<br />这个比较和替换的操作是原子的，即不可中断，确保了数据的一致性。<br />举个例子，变量当前的值为 0，需要将其更新为 1，可以借助 AtomicInteger 类的 compareAndSet 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">expect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">atomicInteger.compareAndSet(expect, update);</span><br></pre></td></tr></table></figure><p>compareAndSet 就是一个 CAS 方法，它调用的是 Unsafe 的 compareAndSwapInt。<br />Unsafe 对 CAS 的实现是通过 C++ 实现的，它的具体实现和操作系统、CPU 都有关系。<br />Linux 的 X86 下主要是通过 cmpxchgl 这个指令在 CPU 上完成 CAS 操作的，但在多处理器情况下，必须使用 lock 指令加锁来完成。当然，不同的操作系统和处理器在实现方式上肯定会有所不同。<br><a name="nxbBe"></a></p><h3 id="35-CAS-有什么问题？如何解决？"><a href="#35-CAS-有什么问题？如何解决？" class="headerlink" title="35.CAS 有什么问题？如何解决？"></a>35.CAS 有什么问题？如何解决？</h3><p>CAS 存在三个经典问题。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-44.png"><br><a name="ESPBt"></a></p><h4 id="什么是-ABA-问题？如何解决？"><a href="#什么是-ABA-问题？如何解决？" class="headerlink" title="什么是 ABA 问题？如何解决？"></a>什么是 ABA 问题？如何解决？</h4><p>如果一个位置的值原来是 A，后来被改为 B，再后来又被改回 A，那么进行 CAS 操作的线程将无法知晓该位置的值在此期间已经被修改过。<br />可以使用版本号&#x2F;时间戳的方式来解决 ABA 问题。<br />比如说，每次变量更新时，不仅更新变量的值，还更新一个版本号。CAS 操作时不仅要求值匹配，还要求版本号匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">updateValue</span><span class="params">(<span class="type">int</span> newValue, <span class="type">int</span> currentVersion)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.version == currentVersion) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = newValue;</span><br><span class="line">            <span class="built_in">this</span>.version++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 的 AtomicStampedReference 类就实现了这种机制，它会同时检查引用值和 stamp 是否都相等。<br><a name="ivaiE"></a></p><h4 id="循环性能开销"><a href="#循环性能开销" class="headerlink" title="循环性能开销"></a>循环性能开销</h4><p>自旋 CAS，如果一直循环执行，一直不成功，会给 CPU 带来非常大的执行开销。<br />在 Java 中，很多使用自旋 CAS 的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。<br><a name="AaqZm"></a></p><h4 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a>只能保证一个变量的原子操作</h4><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p><ul><li>可以考虑改用锁来保证操作的原子性</li><li>可以考虑合并多个变量，将多个变量封装成一个对象，通过 AtomicReference 来保证原子性。<br><a name="v09Cs"></a></li></ul><h3 id="36-Java-有哪些保证原子性的方法？如何保证多线程下-i-结果正确？"><a href="#36-Java-有哪些保证原子性的方法？如何保证多线程下-i-结果正确？" class="headerlink" title="36.Java 有哪些保证原子性的方法？如何保证多线程下 i++ 结果正确？"></a>36.Java 有哪些保证原子性的方法？如何保证多线程下 i++ 结果正确？</h3><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-45.png"></p><ul><li>使用循环原子类，例如 AtomicInteger，实现 i++原子操作</li><li>使用 juc 包下的锁，如 ReentrantLock ，对 i++操作加锁 lock.lock()来实现原子性</li><li>使用 synchronized，对 i++操作加锁<br><a name="kN7OP"></a></li></ul><h3 id="37-原子操作类了解多少？"><a href="#37-原子操作类了解多少？" class="headerlink" title="37.原子操作类了解多少？"></a>37.原子操作类了解多少？</h3><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量 i&#x3D;1，A 线程更新 i+1，B 线程也更新 i+1，经过两个线程操作之后可能 i 不等于 3，而是等于 2。因为 A 和 B 线程在更新变量 i 的时候拿到的 i 都是 1，这就是线程不安全的更新操作，一般我们会使用 synchronized 来解决这个问题，synchronized 会保证多线程不会同时更新变量 i。<br />其实除此之外，还有更轻量级的选择，Java 从 JDK 1.5 开始提供了 java.util.concurrent.atomic 包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<br />因为变量的类型有很多种，所以在 Atomic 包里一共提供了 13 个类，属于 4 种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-46.png"><br />Atomic 包里的类基本都是使用 Unsafe 实现的包装类。<br />使用原子的方式更新基本类型，Atomic 包提供了以下 3 个类：</p><ul><li>AtomicBoolean：原子更新布尔类型。</li><li>AtomicInteger：原子更新整型。</li><li>AtomicLong：原子更新长整型。</li></ul><p>通过原子的方式更新数组里的某个元素，Atomic 包提供了以下 4 个类：</p><ul><li>AtomicIntegerArray：原子更新整型数组里的元素。</li><li>AtomicLongArray：原子更新长整型数组里的元素。</li><li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li><li>AtomicIntegerArray 类主要是提供原子的方式更新数组里的整型</li></ul><p>原子更新基本类型的 AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic 包提供了以下 3 个类：</p><ul><li>AtomicReference：原子更新引用类型。</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是 AtomicMarkableReference（V initialRef，boolean initialMark）。</li></ul><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic 包提供了以下 3 个类进行原子字段更新：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br><a name="hkgi0"></a></li></ul><h3 id="38-AtomicInteger-的原理？"><a href="#38-AtomicInteger-的原理？" class="headerlink" title="38.AtomicInteger 的原理？"></a>38.AtomicInteger 的原理？</h3><p>一句话概括：<strong>使用 CAS 实现</strong>。<br />以 AtomicInteger 的添加方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Unsafe</code>类的实例来进行添加操作，来看看具体的 CAS 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareAndSwapInt 是一个 native 方法，基于 CAS 来操作 int 类型变量。其它的原子操作类基本都是大同小异。<br><a name="cT2E6"></a></p><h3 id="39-线程死锁了解吗？该如何避免？"><a href="#39-线程死锁了解吗？该如何避免？" class="headerlink" title="39.线程死锁了解吗？该如何避免？"></a>39.线程死锁了解吗？该如何避免？</h3><p>死锁发生在多个线程相互等待对方释放锁资源，导致所有线程都无法继续执行。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-47.png"><br><a name="aA6oQ"></a></p><h4 id="那么为什么会产生死锁呢？"><a href="#那么为什么会产生死锁呢？" class="headerlink" title="那么为什么会产生死锁呢？"></a>那么为什么会产生死锁呢？</h4><p>讲个笑话，死锁的产生也不是你想产生就产生的，它是有条件的：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-48.png"></p><ul><li><strong>互斥条件</strong>：资源不能被多个线程共享，一次只能由一个线程使用。如果一个线程已经占用了一个资源，其他请求该资源的线程必须等待，直到资源被释放。</li><li><strong>持有并等待条件</strong>：一个线程至少已经持有至少一个资源，且正在等待获取额外的资源，这些额外的资源被其他线程占有。</li><li><strong>不可剥夺条件</strong>：资源不能被强制从一个线程中抢占过来，只能由持有资源的线程主动释放。</li><li><strong>循环等待条件</strong>：存在一种线程资源的循环链，每个线程至少持有一个其他线程所需要的资源，然后又等待下一个线程所占有的资源。这形成了一个循环等待的环路。<br><a name="zvGHG"></a></li></ul><h4 id="该如何避免死锁呢？"><a href="#该如何避免死锁呢？" class="headerlink" title="该如何避免死锁呢？"></a>该如何避免死锁呢？</h4><p>理解产生死锁的这四个必要条件后，就可以采取相应的措施来避免死锁，换句话说，就是<strong>至少破坏死锁发生的一个条件</strong>。</p><ul><li><strong>破坏互斥条件</strong>：这通常不可行，因为加锁就是为了互斥。</li><li><strong>破坏持有并等待条件</strong>：一种方法是要求线程在开始执行前一次性地申请所有需要的资源。</li><li><strong>破坏非抢占条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：对所有资源类型进行排序，强制每个线程按顺序申请资源，这样可以避免循环等待的发生。<br><a name="chJ0U"></a></li></ul><h3 id="40-那死锁问题怎么排查呢？"><a href="#40-那死锁问题怎么排查呢？" class="headerlink" title="40.那死锁问题怎么排查呢？"></a>40.那死锁问题怎么排查呢？</h3><p>首先从系统级别上排查，比如说在 Linux 生产环境中，可以先使用 top ps 等命令查看进程状态，看看是否有进程占用了过多的资源。<br />接着，使用 JDK 自带的一些性能监控工具进行排查，比如说 jps、jstat、jinfo、jmap、jstack、jcmd 等等。<br />比如说，使用 <code>jps -l</code> 查看当前 Java 进程，然后使用 <code>jstack 进程号</code> 查看当前 Java 进程的线程堆栈信息，看看是否有线程在等待锁资源。<br />来编写一个死锁程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1获取到了锁1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1获取到了锁2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2获取到了锁2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2获取到了锁1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了两个线程，每个线程都试图按照不同的顺序获取两个<a href="https://javabetter.cn/thread/thread-bring-some-problem.html#%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98">锁（lock1 和 lock2）</a>。这种锁的获取顺序不一致很容易导致死锁。<br />运行这段代码，果然卡住了。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/console-tools-20240106192010.png"><br />运行 <code>jstack pid</code> 命令，可以看到死锁的线程信息。诚不欺我！<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/console-tools-20240106192123.png"><br />也可以使用一些可视化的性能监控工具，比如说 JConsole、VisualVM 等。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-49.png"><br><a name="tyGAM"></a></p><h3 id="41-聊聊如何进行线程同步？（补充）"><a href="#41-聊聊如何进行线程同步？（补充）" class="headerlink" title="41.聊聊如何进行线程同步？（补充）"></a>41.聊聊如何进行线程同步？（补充）</h3><p>所谓同步，即协同步调，按预定的先后次序访问共享资源，以免造成混乱。<br />线程同步是多线程编程中的一个核心概念，它涉及到在多线程环境下如何安全地访问和修改共享资源的问题。<br />当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作。<br />如果多个线程同时读写某个共享资源（如变量、文件等），而没有适当的同步机制，就可能导致数据不一致、数据损坏等问题的出现。<br />线程同步的实现方式有 6 种：互斥量、读写锁、条件变量、自旋锁、屏障、信号量。</p><ul><li><strong>互斥量</strong>：互斥量（mutex）是一种最基本的同步手段，本质上是一把锁，在访问共享资源前先对互斥量进行加锁，访问完后再解锁。对互斥量加锁后，任何其他试图再次对互斥量加锁的线程都会被阻塞，直到当前线程解锁。</li><li><strong>读写锁</strong>：<a href="https://javabetter.cn/thread/ReentrantReadWriteLock.html">读写锁</a>有三种状态，读模式加锁、写模式加锁和不加锁；一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。非常适合读多写少的场景。</li><li><strong>条件变量</strong>：<a href="https://javabetter.cn/thread/condition.html">条件变量</a>是一种同步手段，它允许线程在满足特定条件时才继续执行，否则进入等待状态。条件变量通常与互斥量一起使用，以防止竞争条件的发生。</li><li><strong>自旋锁</strong>：自旋锁是一种锁的实现方式，它不会让线程进入睡眠状态，而是一直循环检测锁是否被释放。自旋锁适用于锁的持有时间非常短的情况。</li><li>信号量：信号量（<a href="https://javabetter.cn/thread/CountDownLatch.html">Semaphore</a>）本质上是一个计数器，用于为多个进程提供共享数据对象的访问。</li></ul><p>在 Java 中，<a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>和 Lock 接口是用来实现线程同步的常用方式，我就以它俩来举例说明。<br><a name="J88oE"></a></p><h4 id="简单说说-synchronized-关键字"><a href="#简单说说-synchronized-关键字" class="headerlink" title="简单说说 synchronized 关键字"></a>简单说说 synchronized 关键字</h4><p>当一个线程访问某对象的 synchronized 方法或代码块时，其他线程对该对象的所有 synchronized 方法或代码块的访问将被阻塞，直到第一个线程完成操作。<br />synchronized 关键字就属于典型的互斥量，它保证了同一时间只有一个线程可以访问共享资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用synchronized方法保证线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，increment 方法和 getCount 方法都被标记为 synchronized。这意味着同一时间内只有一个线程可以执行这两个方法中的任意一个。<br />在 JVM 的早期版本中，synchronized 是重量级的，因为线程阻塞和唤醒需要操作系统的介入。但在 JVM 的后续版本中，对 synchronized 进行了大量优化，如偏向锁、轻量级锁和适应性自旋等，所以现在的 synchronized 并不一定是重量级的，其性能在许多情况下都很好，可以大胆地用。<br><a name="rdslP"></a></p><h4 id="简单说说-Lock-接口？"><a href="#简单说说-Lock-接口？" class="headerlink" title="简单说说 Lock 接口？"></a>简单说说 Lock 接口？</h4><p>Lock 接口提供了比 synchronized 关键字更灵活的锁操作。比如说我们可以用重入锁 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a> 来实现同样的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterWithLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>increment 方法先上锁，然后尝试增加 count 的值，在完成操作后释放锁。这样就可以保证 count 的操作是线程安全的。<br />ReentrantLock 和 synchronized 都可以用来实现同步，但它们之间也存在一些区别：</p><ul><li><strong>ReentrantLock 是一个类，而 synchronized 是 Java 中的关键字</strong>；</li><li>**ReentrantLock 可以实现多路选择通知（可以绑定多个 **<a href="https://javabetter.cn/thread/condition.html">Condition</a><strong>），而 synchronized 只能通过 wait 和 notify&#x2F;notifyAll 方法唤醒一个线程或者唤醒全部线程（单路通知）</strong>；</li><li>ReentrantLock 必须手动释放锁。通常需要在 finally 块中调用 unlock 方法以确保锁被正确释放。</li><li>synchronized 会自动释放锁，当同步块执行完毕时，由 JVM 自动释放，不需要手动操作。</li><li>ReentrantLock: 通常提供更好的性能，特别是在高竞争环境下。</li><li>synchronized: 在某些情况下，性能可能稍差一些，但随着 JDK 版本的升级，性能差距已经不大了。<br><a name="nUCM6"></a></li></ul><h3 id="42-聊聊悲观锁和乐观锁？（补充）"><a href="#42-聊聊悲观锁和乐观锁？（补充）" class="headerlink" title="42.聊聊悲观锁和乐观锁？（补充）"></a>42.聊聊悲观锁和乐观锁？（补充）</h3><p>对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。<br />悲观锁的代表有 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>和 <a href="https://javabetter.cn/thread/reentrantLock.html">Lock 接口</a>。<br />乐观锁，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 <a href="https://javabetter.cn/thread/cas.html">CAS</a> 的技术来保证线程执行的安全性。<br />由于乐观锁假想操作中没有锁的存在，因此不太可能出现死锁的情况，换句话说，乐观锁天生免疫死锁。</p><ul><li>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；</li><li>悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。<br><a name="IY53t"></a></li></ul><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p><a name="zYluk"></a></p><h3 id="43-CountDownLatch（倒计数器）了解吗？"><a href="#43-CountDownLatch（倒计数器）了解吗？" class="headerlink" title="43.CountDownLatch（倒计数器）了解吗？"></a>43.CountDownLatch（倒计数器）了解吗？</h3><p>推荐阅读：<a href="https://javabetter.cn/thread/CountDownLatch.html">Java 并发编程通信工具类 Semaphore、Exchanger、CountDownLatch、CyclicBarrier、Phaser 等一网打尽</a><br />CountDownLatch 是 JUC 包中的一个同步工具类，用于协调多个线程之间的同步。它允许一个或多个线程等待，直到其他线程中执行的一组操作完成。它通过一个计数器来实现，该计数器由线程递减，直到到达零。</p><ul><li>初始化：创建 CountDownLatch 对象时，指定计数器的初始值。</li><li>等待（await）：一个或多个线程调用 await 方法，进入等待状态，直到计数器的值变为零。</li><li>倒计数（countDown）：其他线程在完成各自任务后调用 countDown 方法，将计数器的值减一。当计数器的值减到零时，所有在 await 上等待的线程会被唤醒，继续执行。</li></ul><p>当等待多个线程完成各自的启动任务后再启动主线程的任务，就可以使用 CountDownLatch。<br />CountDownLatch 的<strong>核心方法</strong>也不多：</p><ul><li><code>CountDownLatch(int count)</code>：创建一个带有给定计数器的 CountDownLatch。</li><li><code>void await()</code>：阻塞当前线程，直到计数器为零。</li><li><code>void countDown()</code>：递减计数器的值，如果计数器值变为零，则释放所有等待的线程。<br><a name="Eaenv"></a></li></ul><h3 id="44-CyclicBarrier（同步屏障）了解吗？"><a href="#44-CyclicBarrier（同步屏障）了解吗？" class="headerlink" title="44.CyclicBarrier（同步屏障）了解吗？"></a>44.CyclicBarrier（同步屏障）了解吗？</h3><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br />它和 CountDownLatch 类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有 CyclicBarrier，自然是它有和 CountDownLatch 不同的地方。<br />我们拿代码模拟这一场景，发现 CountDownLatch 无能为力了，因为 CountDownLatch 的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用 CyclicBarrier 就可以实现，因为它可以重复利用。<br />CyclicBarrier 最最核心的方法，仍然是 await()：</p><ul><li>如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生<strong>被中断</strong>、<strong>屏障被拆除</strong>、<strong>屏障被重设</strong>等情况；</li></ul><p>上面的例子抽象一下，本质上它的流程就是这样就是这样：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-55.png"><br><a name="GpDQR"></a></p><h3 id="45-CyclicBarrier-和-CountDownLatch-有什么区别？"><a href="#45-CyclicBarrier-和-CountDownLatch-有什么区别？" class="headerlink" title="45.CyclicBarrier 和 CountDownLatch 有什么区别？"></a>45.CyclicBarrier 和 CountDownLatch 有什么区别？</h3><p>两者最核心的区别[18]：</p><ul><li>CountDownLatch 是一次性的，而 CyclicBarrier 则可以多次设置屏障，实现重复利用；</li><li>CountDownLatch 中的各个子线程不可以等待其他线程，只能完成自己的任务；而 CyclicBarrier 中的各个线程可以等待其他线程</li></ul><p>它们区别用一个表格整理：</p><table><thead><tr><th>CyclicBarrier</th><th>CountDownLatch</th></tr></thead><tbody><tr><td>CyclicBarrier 是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</td><td>CountDownLatch 是一次性的，不同的线程在同一个计数器上工作，直到计数器为 0.</td></tr><tr><td>CyclicBarrier 面向的是线程数</td><td>CountDownLatch 面向的是任务数</td></tr><tr><td>在使用 CyclicBarrier 时，你必须在构造中指定参与协作的线程数，这些线程必须调用 await()方法</td><td>使用 CountDownLatch 时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要</td></tr><tr><td>CyclicBarrier 可以在所有的线程释放后重新使用</td><td>CountDownLatch 在计数器为 0 时不能再使用</td></tr><tr><td>在 CyclicBarrier 中，如果某个线程遇到了中断、超时等问题时，则处于 await 的线程都会出现问题</td><td>在 CountDownLatch 中，如果某个线程出现问题，其他线程不受影响</td></tr></tbody></table><p><a name="gyS1n"></a></p><h3 id="46-Semaphore（信号量）了解吗？"><a href="#46-Semaphore（信号量）了解吗？" class="headerlink" title="46.Semaphore（信号量）了解吗？"></a>46.Semaphore（信号量）了解吗？</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<br />我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore 的本质就是<strong>协调多个线程对共享资源的获取</strong>。<br />我们再来看一个 Semaphore 的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。<br />在代码中，虽然有 30 个线程在执行，但是只允许 10 个并发执行。Semaphore 的构造方法<code> Semaphore（int permits</code>）接受一个整型的数字，表示可用的许可证数量。<code>Semaphore（10）</code>表示允许 10 个线程获取许可证，也就是最大并发数是 10。Semaphore 的用法也很简单，首先线程使用 Semaphore 的 acquire()方法获取一个许可证，使用完之后调用 release()方法归还许可证。还可以用 tryAcquire()方法尝试获取许可证。<br><a name="D5Sj9"></a></p><h3 id="47-Exchanger-了解吗？"><a href="#47-Exchanger-了解吗？" class="headerlink" title="47.Exchanger 了解吗？"></a>47.Exchanger 了解吗？</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger 用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-58.jpeg"><br />这两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange()方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<br />Exchanger 可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出 2 个交配结果。Exchanger 也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用 AB 岗两人进行录入，录入到 Excel 之后，系统需要加载这两个 Excel，并对两个 Excel 数据进行校对，看看是否录入一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">&quot;银行流水A&quot;</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">&quot;银行流水B&quot;</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> exgr.exchange(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;A和B数据是否一致：&quot;</span> + A.equals(B) + <span class="string">&quot;，A录入的是：&quot;</span></span><br><span class="line">                            + A + <span class="string">&quot;，B录入是：&quot;</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如两个线程有一个没有执行 exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeOut, TimeUnit unit) </code>设置最大等待时长。<br><a name="WdZ1E"></a></p><h3 id="48-能说一下-ConcurrentHashMap-的实现吗？（补充）"><a href="#48-能说一下-ConcurrentHashMap-的实现吗？（补充）" class="headerlink" title="48.能说一下 ConcurrentHashMap 的实现吗？（补充）"></a>48.能说一下 ConcurrentHashMap 的实现吗？（补充）</h3><p><a href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a> 在 JDK 7 时采用的是分段锁机制（Segment Locking），整个 Map 被分为若干段，每个段都可以独立地加锁。因此，不同的线程可以同时操作不同的段，从而实现并发访问。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/map-20230816155810.png"><br />在 JDK 8 及以上版本中，ConcurrentHashMap 的实现进行了优化，不再使用分段锁，而是使用了一种更加精细化的锁——桶锁，以及 CAS 无锁算法。每个桶（Node 数组的每个元素）都可以独立地加锁，从而实现更高级别的并发访问。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/map-20230816155924.png"><br />同时，对于读操作，通常不需要加锁，可以直接读取，因为 ConcurrentHashMap 内部使用了 volatile 变量来保证内存可见性。<br />对于写操作，ConcurrentHashMap 使用 CAS 操作来实现无锁的更新，这是一种乐观锁的实现，因为它假设没有冲突发生，在实际更新数据时才检查是否有其他线程在尝试修改数据，如果有，采用悲观的锁策略，如 synchronized 代码块来保证数据的一致性。<br><a name="LFA40"></a></p><h4 id="说一下-JDK-7-中的-ConcurrentHashMap-的实现原理？"><a href="#说一下-JDK-7-中的-ConcurrentHashMap-的实现原理？" class="headerlink" title="说一下 JDK 7 中的 ConcurrentHashMap 的实现原理？"></a>说一下 JDK 7 中的 ConcurrentHashMap 的实现原理？</h4><p>JDK 7 的 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组构成的。Segment 是一种可重入的锁 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a>，HashEntry 则用于存储键值对数据。<br />一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/collection-31.png"><br /><strong>①、put 流程</strong><br />ConcurrentHashMap 的 put 流程和 HashMap 非常类似，只不过是先定位到具体的 Segment，然后通过 ReentrantLock 去操作而已。</p><ol><li>计算 hash，定位到 segment，segment 如果是空就先初始化；</li><li>使用 ReentrantLock 加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定能获取到锁；</li><li>遍历 HashEntry，key 相同就直接替换，不存在就插入。</li><li>释放锁。</li></ol><p><strong>②、get 流程</strong><br />get 也很简单，通过 <code>hash(key)</code> 定位到 segment，再遍历链表定位到具体的元素上，需要注意的是 value 是 <a href="https://javabetter.cn/thread/volatile.html">volatile 的</a>，所以 get 是不需要加锁的。<br><a name="wHDJr"></a></p><h4 id="说一下-JDK-8-中的-ConcurrentHashMap-的实现原理？"><a href="#说一下-JDK-8-中的-ConcurrentHashMap-的实现原理？" class="headerlink" title="说一下 JDK 8 中的 ConcurrentHashMap 的实现原理？"></a>说一下 JDK 8 中的 ConcurrentHashMap 的实现原理？</h4><p>JDK 8 中的 ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS + synchronized 来保证并发安全性，整个容器只分为一个 Segment，即 table 数组。<br />Node 和 JDK 7 一样，使用 volatile 关键字，保证多线程操作时，变量的可见性。<br />ConcurrentHashMap 实现线程安全的关键点在于 put 流程。<br /><strong>①、put 流程</strong><br />第一步，计算 hash，遍历 node 数组，如果 node 是空的话，就通过 CAS+自旋的方式初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备初始化</span></span><br><span class="line">tab = initTable();</span><br><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果正在初始化或者扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;   <span class="comment">//CAS操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，如果当前数组位置是空，直接通过 CAS 自旋写入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，如果 <code>hash==MOVED</code>，说明需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure><p>扩容的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="comment">// 下一个表的引用，即新的扩容后的数组</span></span><br><span class="line">    <span class="type">int</span> sc; <span class="comment">// 用于缓存sizeCtl的值</span></span><br><span class="line">    <span class="comment">// 检查条件：传入的表不为空，节点f是ForwardingNode类型，且f中的nextTable不为空</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length); <span class="comment">// 根据当前表长度计算resize stamp</span></span><br><span class="line">        <span class="comment">// 检查循环条件：nextTab等于nextTable，table等于传入的tab，且sizeCtl为负数（表示正在进行或准备进行扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查是否应该停止扩容（比如：resize stamp不匹配，或者已达到最大并发扩容线程数，或者transferIndex已经不大于0）</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 尝试通过CAS增加sizeCtl的值，以表示有更多线程参与扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab); <span class="comment">// 调用transfer方法，实际进行数据迁移</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab; <span class="comment">// 返回新的表引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table; <span class="comment">// 如果不符合扩容协助条件，返回当前表引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，如果都不满足，就使用 synchronized 写入数据，和 HashMap 一样，key 的 hash 一样就覆盖，反之使用拉链法解决哈希冲突，当链表长度超过 8 就转换成红黑树。<br /><strong>②、get 查询</strong><br />get 查询的时候，也是通过 key 的 hash 进行定位，需要注意的是 ConcurrentHashMap 会判断 hash 值是否小于 0。<br />如果小于 0，说明是个特殊节点，会调用节点的 find 方法进行查找，比如说 ForwardingNode 的 find 方法或者 TreeNode 的 find 方法。<br><a name="GLWbK"></a></p><h4 id="总结一下-HashMap-和-ConcurrentHashMap-的区别？"><a href="#总结一下-HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="总结一下 HashMap 和 ConcurrentHashMap 的区别？"></a>总结一下 HashMap 和 ConcurrentHashMap 的区别？</h4><p>①、HashMap 是非线程安全的，多线程环境下应该使用 ConcurrentHashMap。<br />②、由于 HashMap 仅在单线程环境下使用，所以不需要考虑同步问题，因此效率高于 ConcurrentHashMap。<br><a name="lajbm"></a></p><h4 id="你项目中怎么使用-ConcurrentHashMap-的？"><a href="#你项目中怎么使用-ConcurrentHashMap-的？" class="headerlink" title="你项目中怎么使用 ConcurrentHashMap 的？"></a>你项目中怎么使用 ConcurrentHashMap 的？</h4><p>在<a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，很多地方都用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，使用 ConcurrentHashMap 来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。<br><a name="sYdoB"></a></p><h4 id="ConcurrentHashMap-对-HashMap-的优化？"><a href="#ConcurrentHashMap-对-HashMap-的优化？" class="headerlink" title="ConcurrentHashMap 对 HashMap 的优化？"></a>ConcurrentHashMap 对 HashMap 的优化？</h4><p>ConcurrentHashMap 是 HashMap 的线程安全版本，使用了 CAS、synchronized、volatile 来确保线程安全。<br />首先是 hash 的计算方法上，ConcurrentHashMap 的 spread 方法接收一个已经计算好的 hashCode，然后将这个哈希码的高 16 位与自身进行异或运算，这里的 HASH_BITS 是一个常数，值为 0x7fffffff，它确保结果是一个非负整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比 HashMap 的 hash 计算多了一个 <code>&amp; HASH_BITS</code> 的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，ConcurrentHashMap 对节点 Node 做了进一步的封装，比如说用 Forwarding Node 来表示正在进行扩容的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是 put 方法，通过 CAS + synchronized 来保证线程安全。<br><a name="ayK6x"></a></p><h4 id="为什么-ConcurrentHashMap-在-JDK-1-7-中要用-ReentrantLock，而在-JDK-1-8-要用-synchronized"><a href="#为什么-ConcurrentHashMap-在-JDK-1-7-中要用-ReentrantLock，而在-JDK-1-8-要用-synchronized" class="headerlink" title="为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized"></a>为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized</h4><p>ConcurrentHashMap 在 JDK 1.7 和 JDK 1.8 中的实现机制不同，主要体现在锁的机制上。<br />JDK 1.7 中的 ConcurrentHashMap 使用了分段锁机制，即 Segment 锁，每个 Segment 都是一个 ReentrantLock，这样可以保证每个 Segment 都可以独立地加锁，从而实现更高级别的并发访问。<br />而在 JDK 1.8 中，ConcurrentHashMap 取消了 Segment 分段锁，采用了更加精细化的锁——桶锁，以及 CAS 无锁算法，每个桶（Node 数组的每个元素）都可以独立地加锁，从而实现更高级别的并发访问。<br />再加上 JVM 对 synchronized 做了大量优化，如锁消除、锁粗化、自旋锁和偏向锁等，在低中等的竞争情况下，synchronized 的性能并不比 ReentrantLock 差，并且使用 synchronized 可以简化代码实现。<br><a name="MQXvB"></a></p><h3 id="49-ConcurrentHashMap-怎么保证可见性？"><a href="#49-ConcurrentHashMap-怎么保证可见性？" class="headerlink" title="49.ConcurrentHashMap 怎么保证可见性？"></a>49.ConcurrentHashMap 怎么保证可见性？</h3><p>ConcurrentHashMap 保证可见性主要通过使用 volatile 关键字和 synchronized 同步块。<br />在 Java 中，volatile 关键字保证了变量的可见性，即一个线程修改了一个 volatile 变量后，其他线程可以立即看到这个修改。在 ConcurrentHashMap 的内部实现中，有些关键的变量被声明为 volatile，比如 Segment 数组和 Node 数组等。<br />此外，ConcurrentHashMap 还使用了 synchronized 同步块来保证复合操作的原子性。当一个线程进入 synchronized 同步块时，它会获得锁，然后执行同步块内的代码。当它退出 synchronized 同步块时，它会释放锁，并将在同步块内对共享变量的所有修改立即刷新到主内存，这样其他线程就可以看到这些修改了。<br />通过这两种机制，ConcurrentHashMap 保证了在并发环境下的可见性，从而确保了线程安全。<br><a name="WmRXr"></a></p><h3 id="50-为什么-ConcurrentHashMap-比-Hashtable-效率高"><a href="#50-为什么-ConcurrentHashMap-比-Hashtable-效率高" class="headerlink" title="50.为什么 ConcurrentHashMap 比 Hashtable 效率高"></a>50.为什么 ConcurrentHashMap 比 Hashtable 效率高</h3><blockquote><p>2024 年 03 月 26 日增补，从集合框架移动到并发编程这里</p></blockquote><p>Hashtable 在任何时刻只允许一个线程访问整个 Map，通过对整个 Map 加锁来实现线程安全。<br />而 ConcurrentHashMap（尤其是在 JDK 8 及之后版本）通过锁分离和 CAS 操作实现更细粒度的锁定策略，允许更高的并发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS 操作是一种乐观锁，它不会阻塞线程，而是在更新时检查是否有其他线程已经修改了数据，如果没有就更新，如果有就重试。<br />ConcurrentHashMap 允许多个读操作并发进行而不加锁，因为它通过 <a href="https://javabetter.cn/thread/volatile.html">volatile 变量</a>来保证读取操作的内存可见性。相比之下，Hashtable 对读操作也加锁，增加了开销。<br><a name="jzwGI"></a></p><h3 id="51-能说一下-CopyOnWriteArrayList-的实现原理吗？"><a href="#51-能说一下-CopyOnWriteArrayList-的实现原理吗？" class="headerlink" title="51.能说一下 CopyOnWriteArrayList 的实现原理吗？"></a>51.能说一下 CopyOnWriteArrayList 的实现原理吗？</h3><p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，它遵循写时复制（Copy-On-Write）的原则，即在写操作时，会先复制一个新的数组，然后在新的数组上进行写操作，写完之后再将原数组引用指向新数组。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CopyOnWriteArrayList-01.png"><br />这样，读操作总是在一个不变的数组版本上进行的，就不需要同步了。<br><a name="VrLsY"></a></p><h3 id="52-能说一下-BlockingQueue-吗？"><a href="#52-能说一下-BlockingQueue-吗？" class="headerlink" title="52. 能说一下 BlockingQueue 吗？"></a>52. 能说一下 BlockingQueue 吗？</h3><p><a href="https://javabetter.cn/thread/BlockingQueue.html">BlockingQueue</a> 代表的是线程安全的队列，不仅可以由多个线程并发访问，还添加了等待&#x2F;通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。<br />阻塞队列（BlockingQueue）被广泛用于“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。<br />BlockingQueue 接口的实现类有 ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、LinkedBlockingQueue、LinkedTransferQueue、PriorityBlockingQueue、SynchronousQueue 等。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/BlockingQueue-20230818153420.png"><br />阻塞指的是一种程序执行状态，其中某个线程在等待某个条件满足时暂停其执行（即阻塞），直到条件满足时恢复其执行。<br><a name="h9Tkq"></a></p><h4 id="阻塞队列是如何实现的？"><a href="#阻塞队列是如何实现的？" class="headerlink" title="阻塞队列是如何实现的？"></a>阻塞队列是如何实现的？</h4><p>就拿 ArrayBlockingQueue 来说，它是一个基于数组的有界阻塞队列，采用 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a> 锁来实现线程的互斥，而 ReentrantLock 底层采用的是 AQS 实现的队列同步，线程的阻塞调用 <a href="https://javabetter.cn/thread/LockSupport.html">LockSupport.park</a> 实现，唤醒调用 LockSupport.unpark 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 使用ReentrantLock锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 插入元素后，通知消费者线程可以继续取元素</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，阻塞，等待生产者线程放入元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 移除元素并返回</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素并返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 数组是循环队列，如果到达数组末尾，从头开始</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 移除元素后，通知生产者线程可以继续放入元素</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="n0oU7"></a></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a name="KFS0h"></a></p><h3 id="53-什么是线程池？"><a href="#53-什么是线程池？" class="headerlink" title="53.什么是线程池？"></a>53.什么是线程池？</h3><p>线程池，简单来说，就是一个管理线程的池子。<br />①、频繁地创建和销毁线程会消耗系统资源，线程池能够复用已创建的线程。<br />②、提高响应速度，当任务到达时，任务可以不需要等待线程创建就立即执行。<br />③、线程池支持定时执行、周期性执行、单线程执行和并发数控制等功能。<br><a name="fmkCH"></a></p><h3 id="54-能说说工作中线程池的应用吗？"><a href="#54-能说说工作中线程池的应用吗？" class="headerlink" title="54.能说说工作中线程池的应用吗？"></a>54.能说说工作中线程池的应用吗？</h3><p>推荐阅读：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">线程池在美团业务中的应用</a><br />为了最大程度利用 CPU 的多核性能，并行运算的能力是不可获取的，通过线程池来管理线程是一个非常基础的操作。<br /><strong>①、快速响应用户请求</strong><br />当用户发起一个实时请求，服务器需要快速响应，此时如果每次请求都直接创建一个线程，那么线程的创建和销毁会消耗大量的系统资源。<br />使用线程池，可以预先创建一定数量的线程，当用户请求到来时，直接从线程池中获取一个空闲线程，执行用户请求，执行完毕后，线程不销毁，而是继续保留在线程池中，等待下一个请求。<br />注意：这种场景下需要调高 corePoolSize 和 maxPoolSize，尽可能多创建线程，避免使用队列去缓存任务。<br />比如说，在项目中，当用户请求首页时，就使用了线程池去加载首页的热门文章、置顶文章、侧边栏、用户登录信息等。<br />我们封装了一个异步类 AsyncUtil，内部的静态类 CompletableFutureBridge 是通过 <a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture</a> 实现的，其中的 <code>runAsyncWithTimeRecord()</code> 方法就是使用线程池去执行任务的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFutureBridge <span class="title function_">runAsyncWithTimeRecord</span><span class="params">(Runnable run, String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> runAsyncWithTimeRecord(run, name, executorService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中线程池的初始化中，corePoolSize 为 CPU 核心数的两倍，因为技术派中的大多数任务都是 IO 密集型的，maxPoolSize 设置为 50，是一个比较理想的值，尤其是在本地环境中；阻塞队列为 SynchronousQueue，这意味着任务被创建后直接提交给等待的线程处理，而不是放入队列中。<br /><strong>②、快速处理批量任务</strong><br />这种场景也需要处理大量的任务，但可能不需要立即响应，这时候就应该设置队列去缓冲任务，corePoolSize 不需要设置得太高，避免线程上下文切换引起的频繁切换问题。<br><a name="Qas0s"></a></p><h3 id="55-能简单说一下线程池的工作流程吗？"><a href="#55-能简单说一下线程池的工作流程吗？" class="headerlink" title="55.能简单说一下线程池的工作流程吗？"></a>55.能简单说一下线程池的工作流程吗？</h3><p>当应用程序提交一个任务时，线程池会根据当前线程的状态和参数决定如何处理这个任务。</p><ul><li>如果线程池中的核心线程都在忙，并且线程池未达到最大线程数，新提交的任务会被放入队列中进行等待。</li><li>如果任务队列已满，且当前线程数量小于最大线程数，线程池会创建新的线程来处理任务。</li></ul><p>空闲的线程会从任务队列中取出任务来执行，当任务执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。<br />当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。<br />举例：</p><ol><li>corePoolSize 对应营业窗口数 3</li><li>maximumPoolSize 对应最大窗口数 6</li><li>workQueue 对应排队区</li><li>handler 对应接待员小美<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">6</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">0</span>, <span class="comment">// 线程空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 等待队列</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 模拟 10 个顾客来银行办理业务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;办理业务&quot;</span> + tempInt);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>好，我再来梳理一下线程池的整个工作流程。<br />第一步，创建线程池。<br />第二步，调用线程池的 <code>execute()</code>方法，提交任务。</li></ol><ul><li>如果正在运行的线程数量小于 corePoolSize，那么线程池会创建一个新的线程来执行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么线程池会将这个任务放入等待队列；</li><li>如果等待队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么线程池会创建新的线程来执行这个任务；</li><li>如果等待队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会执行拒绝策略。</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-66.png"><br />第三步，线程执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。<br />第四步，当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。<br><a name="hFeW2"></a></p><h3 id="56-线程池主要参数有哪些？"><a href="#56-线程池主要参数有哪些？" class="headerlink" title="56.线程池主要参数有哪些？"></a>56.线程池主要参数有哪些？</h3><p>线程池有 7 个参数，需要重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>、<code>handler</code> 这四个。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-67.png"><br />我一一说一下：<br /><strong>①、corePoolSize</strong><br />定义了线程池中的核心线程数量。即使这些线程处于空闲状态，它们也不会被回收。这是线程池保持在等待状态下的线程数。<br /><strong>②、maximumPoolSize</strong><br />线程池允许的最大线程数量。当工作队列满了之后，线程池会创建新线程来处理任务，直到线程数达到这个最大值。<br /><strong>③、workQueue</strong><br />用于存放待处理任务的阻塞队列。当所有核心线程都忙时，新任务会被放在这个队列里等待执行。<br /><strong>④、handler</strong><br />拒绝策略 RejectedExecutionHandler，定义了当线程池和工作队列都满了之后对新提交的任务的处理策略。常见的拒绝策略包括抛出异常、直接丢弃、丢弃队列中最老的任务、由提交任务的线程来直接执行任务等。<br /><strong>⑤、threadFactory</strong><br />一个创建新线程的工厂。它用于创建线程池中的线程。可以通过自定义 ThreadFactory 来给线程池中的线程设置有意义的名字，或设置优先级等。<br /><strong>⑥、keepAliveTime</strong><br />非核心线程的空闲存活时间。如果线程池中的线程数量超过了 corePoolSize，那么这些多余的线程在空闲时间超过 keepAliveTime 时会被终止。<br /><strong>⑦、unit</strong><br />keepAliveTime 参数的时间单位：</p><ul><li>TimeUnit.DAYS; 天</li><li>TimeUnit.HOURS; 小时</li><li>TimeUnit.MINUTES; 分钟</li><li>TimeUnit.SECONDS; 秒</li><li>TimeUnit.MILLISECONDS; 毫秒</li><li>TimeUnit.MICROSECONDS; 微秒</li><li>TimeUnit.NANOSECONDS; 纳秒<br><a name="diMLJ"></a></li></ul><h4 id="能简单说一下参数之间的关系吗？"><a href="#能简单说一下参数之间的关系吗？" class="headerlink" title="能简单说一下参数之间的关系吗？"></a>能简单说一下参数之间的关系吗？</h4><p>①、corePoolSize 和 maximumPoolSize 共同定义了线程池的规模。</p><ul><li>当提交的任务数不足以填满核心线程时，线程池只会创建足够的线程来处理任务。</li><li>当任务数增多，超过核心线程的处理能力时，任务会被加入 workQueue。</li><li>如果 workQueue 已满，而当前线程数又小于 maximumPoolSize，线程池会尝试创建新的线程来处理任务。</li></ul><p>②、keepAliveTime 和 unit 决定了非核心线程可以空闲存活多久。这会影响了线程池的资源回收策略。<br />③、workQueue 的选择对线程池的行为有重大影响。不同类型的队列（如无界队列、有界队列）会导致线程池在任务增多时的反应不同。<br />④、handler 定义了线程池的饱和策略，即当线程池无法接受新任务时的行为。决定了系统在极限情况下的表现。<br><a name="LSwoj"></a></p><h4 id="核心线程数不够会怎么进行处理？"><a href="#核心线程数不够会怎么进行处理？" class="headerlink" title="核心线程数不够会怎么进行处理？"></a>核心线程数不够会怎么进行处理？</h4><p>当提交的任务数超过了 corePoolSize，但是小于 maximumPoolSize 时，线程池会创建新的线程来处理任务。<br />当提交的任务数超过了 maximumPoolSize 时，线程池会根据拒绝策略来处理任务。<br><a name="JPh1y"></a></p><h4 id="举个例子说一下这些参数的变化"><a href="#举个例子说一下这些参数的变化" class="headerlink" title="举个例子说一下这些参数的变化"></a>举个例子说一下这些参数的变化</h4><p>假设一个场景，线程池的配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize = <span class="number">5</span></span><br><span class="line">maximumPoolSize = <span class="number">10</span></span><br><span class="line">keepAliveTime = <span class="number">60</span>秒</span><br><span class="line">workQueue = LinkedBlockingQueue（容量为<span class="number">100</span>）</span><br><span class="line">默认的<span class="type">threadFactory</span></span><br><span class="line"><span class="variable">handler</span> <span class="operator">=</span> ThreadPoolExecutor.AbortPolicy()</span><br></pre></td></tr></table></figure><p><strong>场景一</strong>：当系统启动后，逐渐有 10 个任务提交到线程池。</p><ul><li>前 5 个任务会立即执行，因为它们会占用所有的核心线程。</li><li>随后的 5 个任务会被放入工作队列中等待执行。</li></ul><p><strong>场景二</strong>：如果此时再有 100 个任务提交到线程池。</p><ul><li>工作队列已满，线程池会创建额外的线程来执行这些任务，直到线程总数达到 maximumPoolSize（10 个线程）。</li><li>如果任务继续增加，超过了工作队列和最大线程数的限制，新来的任务将会根据拒绝策略（AbortPolicy）被拒绝，抛出 RejectedExecutionException 异常。</li></ul><p><strong>场景三</strong>：如果任务突然减少，只有少量的任务需要执行：<br />核心线程会一直运行，而超出核心线程数的线程，如果空闲时间超过 keepAliveTime，将会被终止，直到线程池的线程数减少到 corePoolSize。<br><a name="pS3Qq"></a></p><h3 id="57-线程池的拒绝策略有哪些？"><a href="#57-线程池的拒绝策略有哪些？" class="headerlink" title="57.线程池的拒绝策略有哪些？"></a>57.线程池的拒绝策略有哪些？</h3><p>主要有四种：</p><ul><li>AbortPolicy：这是默认的拒绝策略。该策略会抛出一个 RejectedExecutionException 异常。也就对应着“我们系统瘫痪了”。</li><li>CallerRunsPolicy：该策略不会抛出异常，而是会让提交任务的线程（即调用 execute 方法的线程）自己来执行这个任务。也就对应着“谁叫你来办的你找谁去”。</li><li>DiscardOldestPolicy：策略会丢弃队列中最老的一个任务（即队列中等待最久的任务），然后尝试重新提交被拒绝的任务。也就对应着“看你比较急，去队里加个塞”。</li><li>DiscardPolicy：策略会默默地丢弃被拒绝的任务，不做任何处理也不抛出异常。也就对应着“今天没办法，不行你看改一天”。</li></ul><p>如果想实现自己的拒绝策略，实现 RejectedExecutionHandler 接口即可。<br><a name="KDkx5"></a></p><h3 id="58-线程池有哪几种阻塞队列？"><a href="#58-线程池有哪几种阻塞队列？" class="headerlink" title="58.线程池有哪几种阻塞队列？"></a>58.线程池有哪几种阻塞队列？</h3><p>在 Java 中，线程池（ThreadPoolExecutor）使用阻塞队列（BlockingQueue）来存储待处理的任务。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-69.png"><br />①、ArrayBlockingQueue：一个有界的先进先出的阻塞队列，底层是一个数组，适合固定大小的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">10</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>②、LinkedBlockingQueue：底层数据结构是链表，如果不指定大小，默认大小是 Integer.MAX_VALUE，相当于一个无界队列。项目中，就使用了 LinkedBlockingQueue 来配置 RabbitMQ 的消息队列。<br />③、PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。任务按照其自然顺序或通过构造器给定的 Comparator 来排序。<br />适用于需要按照给定优先级处理任务的场景，比如优先处理紧急任务。<br />④、DelayQueue：类似于 PriorityBlockingQueue，由二叉堆实现的无界优先级阻塞队列。<br />Executors 中的 <code>newScheduledThreadPool()</code> 就使用了 DelayQueue 来实现延迟执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤、SynchronousQueue：实际上它不是一个真正的队列，因为没有容量。每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都必须等待另一个线程的插入操作。<br /><code>Executors.newCachedThreadPool()</code> 就使用了 SynchronousQueue，这个线程池会根据需要创建新线程，如果有空闲线程则会重复使用，线程空闲 60 秒后会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="LBG9F"></a></p><h3 id="59-线程池提交-execute-和-submit-有什么区别？"><a href="#59-线程池提交-execute-和-submit-有什么区别？" class="headerlink" title="59.线程池提交 execute 和 submit 有什么区别？"></a>59.线程池提交 execute 和 submit 有什么区别？</h3><ol><li><p>execute 用于提交不需要返回值的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub &#125;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>submit()方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get()方法来获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(haveReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> future.get(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池 executor.shutdown();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="NWi54"></a></p></li></ol><h3 id="60-线程池怎么关闭知道吗？"><a href="#60-线程池怎么关闭知道吗？" class="headerlink" title="60.线程池怎么关闭知道吗？"></a>60.线程池怎么关闭知道吗？</h3><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。<br /><strong>shutdown() 将线程池状态置为 shutdown,并不会立即停止</strong>：</p><ol><li>停止接收外部 submit 的任务</li><li>内部正在跑的任务和队列里等待的任务，会执行完</li><li>等到第二步完成后，才真正停止</li></ol><p><strong>shutdownNow() 将线程池状态置为 stop。一般会立即停止，事实上不一定</strong>：</p><ol><li>和 shutdown()一样，先停止接收外部提交的任务</li><li>忽略队列里等待的任务</li><li>尝试将正在跑的任务 interrupt 中断</li><li>返回未执行的任务列表</li></ol><p>shutdown 和 shutdownnow 简单来说区别如下：</p><ul><li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li><li>shutdown()只是关闭了提交通道，用 submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。<br><a name="ve21h"></a></li></ul><h3 id="61-线程池的线程数应该怎么配置？"><a href="#61-线程池的线程数应该怎么配置？" class="headerlink" title="61.线程池的线程数应该怎么配置？"></a>61.线程池的线程数应该怎么配置？</h3><p>首先，我会分析线程池中执行的任务类型是 CPU 密集型还是 IO 密集型？<br />①、对于 CPU 密集型任务，我的目标是尽量减少线程上下文切换，以优化 CPU 使用率。一般来说，核心线程数设置为处理器的核心数或核心数加一（以备不时之需，如某些线程因等待系统资源而阻塞时）是较理想的选择。<br />②、对于 IO 密集型任务，由于线程经常处于等待状态（等待 IO 操作完成），可以设置更多的线程来提高并发性（比如说 2 倍），从而增加 CPU 利用率。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-70.png"><br />核心数可以通过 Java 的<code>Runtime.getRuntime().availableProcessors()</code>方法获取。<br />此外，每个线程都会占用一定的内存，因此我需要确保线程池的规模不会耗尽 JVM 内存，避免频繁的垃圾回收或内存溢出。<br />最后，我会根据业务需求和系统资源来调整线程池的参数，比如核心线程数、最大线程数、非核心线程的空闲存活时间、任务队列容量等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    cores, <span class="comment">// 核心线程数设置为CPU核心数</span></span><br><span class="line">    cores * <span class="number">2</span>, <span class="comment">// 最大线程数为核心数的两倍</span></span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">// 非核心线程的空闲存活时间</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>) <span class="comment">// 任务队列容量</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="feMke"></a></p><h3 id="62-有哪几种常见的线程池？"><a href="#62-有哪几种常见的线程池？" class="headerlink" title="62.有哪几种常见的线程池？"></a>62.有哪几种常见的线程池？</h3><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-71.png"><br />可以通过 Executors 工厂类来创建四种常见的线程池：</p><ul><li>newFixedThreadPool (固定线程数目的线程池)</li><li>newCachedThreadPool (可缓存线程的线程池)</li><li>newSingleThreadExecutor (单线程的线程池)</li><li>newScheduledThreadPool (定时及周期执行的线程池)<br><a name="ULwjL"></a></li></ul><h3 id="63-能说一下四种常见线程池的原理吗？"><a href="#63-能说一下四种常见线程池的原理吗？" class="headerlink" title="63.能说一下四种常见线程池的原理吗？"></a>63.能说一下四种常见线程池的原理吗？</h3><p>前三种线程池的构造直接调用 ThreadPoolExecutor 的构造方法。<br><a name="hrYdn"></a></p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>核心线程数为 1</li><li>最大线程数也为 1</li><li>阻塞队列是无界队列 LinkedBlockingQueue，可能会导致 OOM</li><li>keepAliveTime 为 0</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-72.png"><br />工作流程：</p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，将任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</li></ul><p><strong>适用场景</strong><br />适用于串行执行任务的场景，一个任务一个任务地执行。<br><a name="aXPIN"></a></p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即 keepAliveTime 为 0</li><li>阻塞队列为无界队列 LinkedBlockingQueue，可能会导致 OOM</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-73.png"><br />工作流程：</p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到 LinkedBlockingQueue 阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><p><strong>使用场景</strong><br />FixedThreadPool 适用于处理 CPU 密集型的任务，确保 CPU 在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。<br><a name="QS2H8"></a></p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数为 0</li><li>最大线程数为 Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致 OOM</li><li>阻塞队列是 SynchronousQueue</li><li>非核心线程空闲存活时间为 60 秒</li></ul><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-74.png"><br />工作流程：</p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到 SynchronousQueue 队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活 60 秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><p><strong>适用场景</strong><br />用于并发执行大量短期的小任务。<br><a name="TfZGO"></a></p><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>最大线程数为 Integer.MAX_VALUE，也有 OOM 的风险</li><li>阻塞队列是 DelayedWorkQueue</li><li>keepAliveTime 为 0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-75.png"><br /><strong>工作机制</strong></p><ul><li>线程从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前时间。</li><li>线程执行这个 ScheduledFutureTask。</li><li>线程修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间。</li><li>线程把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-76.png"><br /><strong>使用场景</strong><br />周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p>使用无界队列的线程池会导致什么问题吗？</p></blockquote><p>例如 newFixedThreadPool 使用了无界的阻塞队列 LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致 OOM。<br><a name="xe9ES"></a></p><h3 id="64-线程池异常怎么处理知道吗？"><a href="#64-线程池异常怎么处理知道吗？" class="headerlink" title="64.线程池异常怎么处理知道吗？"></a>64.线程池异常怎么处理知道吗？</h3><p>在使用线程池处理任务的时候，任务代码可能抛出 RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。<br />常见的异常处理方式：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-77.png"><br><a name="kAW1S"></a></p><h3 id="65-能说一下线程池有几种状态吗？"><a href="#65-能说一下线程池有几种状态吗？" class="headerlink" title="65.能说一下线程池有几种状态吗？"></a>65.能说一下线程池有几种状态吗？</h3><p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>线程池各个状态切换图：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-78.png"><br /><strong>RUNNING</strong></p><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的 shutdown()方法，可以切换到 SHUTDOWN 状态;</li><li>调用线程池的 shutdownNow()方法，可以切换到 STOP 状态;</li></ul><p><strong>SHUTDOWN</strong></p><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入 TIDYING 状态;</li></ul><p><strong>STOP</strong></p><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入 TIDYING 状态;</li></ul><p><strong>TIDYING</strong></p><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为 0。</li><li>terminated()执行完毕，进入 TERMINATED 状态</li></ul><p><strong>TERMINATED</strong></p><ul><li>该状态表示线程池彻底终止<br><a name="GmKN3"></a></li></ul><h3 id="66-线程池如何实现参数的动态修改？"><a href="#66-线程池如何实现参数的动态修改？" class="headerlink" title="66.线程池如何实现参数的动态修改？"></a>66.线程池如何实现参数的动态修改？</h3><p>线程池提供了几个 setter 方法来设置线程池的参数。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-79.png"><br />这里主要有两个思路：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-80.png"></p><ul><li>在我们微服务的架构下，可以利用配置中心如 Nacos、Apollo 等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。</li><li>如果限制了配置中心的使用，也可以自己去扩展<strong>ThreadPoolExecutor</strong>，重写方法，监听线程池参数变化，来动态修改线程池参数。<br><a name="ELeMo"></a></li></ul><h3 id="67-线程池调优了解吗？（补充）"><a href="#67-线程池调优了解吗？（补充）" class="headerlink" title="67.线程池调优了解吗？（补充）"></a>67.线程池调优了解吗？（补充）</h3><blockquote><p>2024 年 03 月 16 日增补</p></blockquote><p>线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-81.png"><br />上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。<br />事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。<br />事后要注意仔细观察，随时调整。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-82.png"><br />具体的调优案例可以查看参考[7]美团技术博客。<br><a name="IEq26"></a></p><h3 id="68-线程池在使用的时候需要注意什么？（补充）"><a href="#68-线程池在使用的时候需要注意什么？（补充）" class="headerlink" title="68.线程池在使用的时候需要注意什么？（补充）"></a>68.线程池在使用的时候需要注意什么？（补充）</h3><blockquote><p>2024 年 03 月 16 日增补</p></blockquote><p>我认为比较重要的关注点有 3 个：<br />①、选择合适的线程池大小</p><ul><li><strong>过小</strong>的线程池可能会导致任务一直在排队</li><li><strong>过大</strong>的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销</li></ul><p>可以根据业务是 IO 密集型还是 CPU 密集型来选择线程池大小：</p><ul><li>CPU 密集型：指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为 CPU 核心数+1。</li><li>IO 密集型：当执行任务需要大量的 io，比如磁盘 io，网络 io，可能会存在大量的阻塞，所以在 IO 密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 2*CPU 核心数。</li></ul><p>②、任务队列的选择</p><ul><li>使用有界队列可以避免资源耗尽的风险，但是可能会导致任务被拒绝</li><li>使用无界队列虽然可以避免任务被拒绝，但是可能会导致内存耗尽</li></ul><p>一般需要设置有界队列的大小，比如 LinkedBlockingQueue 在构造的时候可以传入参数来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的 oom。<br />③、尽量使用自定义的线程池，而不是使用 Executors 创建的线程池，因为 newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，队列的容量默认无限大，实际使用中出现任务过多时会导致内存溢出；newCachedThreadPool 线程池由于核心线程数无限大，当任务过多的时候会导致创建大量的线程，可能机器负载过高导致服务宕机。<br><a name="JyDvu"></a></p><h3 id="69-你能设计实现一个线程池吗？"><a href="#69-你能设计实现一个线程池吗？" class="headerlink" title="69.你能设计实现一个线程池吗？"></a>69.你能设计实现一个线程池吗？</h3><p>推荐阅读：<a href="https://mp.weixin.qq.com/s/Exy7pRGND9TCjRd9TZK4jg">三分恶线程池原理</a><br />线程池的设计需要考虑这几个关键因素：</p><ol><li>核心线程池类：包含核心线程数、最大线程数。</li><li>工作线程：线程池中实际工作的线程，从任务队列中获取任务并执行。</li><li>任务队列：存放待执行任务的队列，可以使用阻塞队列实现。</li><li>拒绝策略：当任务队列满时，处理新任务的策略。</li></ol><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-83.png"><br />核心线程池类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CustomThreadPoolExecutor is a simple implementation of a thread pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isShutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentPoolSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a CustomThreadPoolExecutor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize    the number of core threads.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime   the time to keep extra threads alive.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit            the time unit for keepAliveTime.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue       the queue to hold runnable tasks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler         the handler to use when execution is blocked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit,</span></span><br><span class="line"><span class="params">                                    BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes a given task using the thread pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to execute.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;ThreadPool is shutdown&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// If current pool size is less than core pool size, create a new worker thread</span></span><br><span class="line">            <span class="keyword">if</span> (currentPoolSize &lt; corePoolSize) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Worker</span>(task).start();</span><br><span class="line">                currentPoolSize++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to add task to the queue, if full create a new worker thread if possible</span></span><br><span class="line">            <span class="keyword">if</span> (!workQueue.offer(task)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentPoolSize &lt; maximumPoolSize) &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Worker</span>(task).start();</span><br><span class="line">                    currentPoolSize++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// If maximum pool size reached, apply the rejection handler</span></span><br><span class="line">                    handler.rejectedExecution(task, <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shuts down the thread pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        isShutdown = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker is an internal class that represents a worker thread in the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable task) &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Gets a task from the work queue, waiting up to keepAliveTime if necessary.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a task to run, or null if the keepAliveTime expires.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> workQueue.poll(keepAliveTime, unit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拒绝策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CustomRejectedExecutionHandler contains several common rejection policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbortPolicy throws a RuntimeException when the task is rejected.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() + <span class="string">&quot; rejected from &quot;</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DiscardPolicy silently discards the rejected task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CallerRunsPolicy runs the rejected task in the caller&#x27;s thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.paicoding.forum.web.javabetter.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Create a thread pool with core size 2, max size 4, and a queue capacity of 2</span></span><br><span class="line">        <span class="type">CustomThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CustomRejectedExecutionHandler</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Submit 10 tasks to the pool</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + index + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shutdown the thread pool</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240727230303.png"><br><a name="Mc61k"></a></p><h3 id="70-单机线程池执行断电了应该怎么处理？"><a href="#70-单机线程池执行断电了应该怎么处理？" class="headerlink" title="70.单机线程池执行断电了应该怎么处理？"></a>70.单机线程池执行断电了应该怎么处理？</h3><p>我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理</code>的已经执行成功的操作。然后重新执行整个阻塞队列。<br />也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。<br><a name="RqB1i"></a></p><h2 id="并发容器和框架"><a href="#并发容器和框架" class="headerlink" title="并发容器和框架"></a>并发容器和框架</h2><p>关于一些并发容器，可以去看看 <a href="https://mp.weixin.qq.com/s/SHkQ7LEOT0itt4bXMoDBPw">面渣逆袭：Java 集合连环三十问 </a>，里面有<code>CopyOnWriteArrayList</code>和<code>ConcurrentHashMap</code>这两种线程安全容器类的问答。。<br><a name="EaRcS"></a></p><h3 id="71-Fork-Join-框架了解吗？"><a href="#71-Fork-Join-框架了解吗？" class="headerlink" title="71.Fork&#x2F;Join 框架了解吗？"></a>71.Fork&#x2F;Join 框架了解吗？</h3><p>Fork&#x2F;Join 框架是 Java7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br />要想掌握 Fork&#x2F;Join 框架，首先需要理解两个点，<strong>分而治之</strong>和<strong>工作窃取算法</strong>。<br /><strong>分而治之</strong><br />Fork&#x2F;Join 框架的定义，其实就体现了分治思想：将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-85.png"><br /><strong>工作窃取算法</strong><br />大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。<br />那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的<strong>工作窃取</strong>。<br />工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。<br /><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-86.png"><br />看一个 Fork&#x2F;Join 框架应用的例子，计算 1~n 之间的和：1+2+3+…+n</p><ul><li>设置一个分割阈值，任务大于阈值就拆分任务</li><li>任务有结果，所以需要继承 RecursiveTask<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canCompute</span> <span class="operator">=</span> (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(start, middle);</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork(); <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.join(); <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(); <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        <span class="type">CountTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>ForkJoinTask 与一般 Task 的主要区别在于它需要实现 compute 方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用 fork 方法时，又会进 compute 方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用 join 方法会等待子任务执行完并得到其结果。</li></ul>]]></content>
    
    
    <summary type="html">八股文系列-并发编程</summary>
    
    
    
    <category term="八股文" scheme="http://ylcheng1789.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="并发编程" scheme="http://ylcheng1789.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>八股文系列-Java集合框架</title>
    <link href="http://ylcheng1789.github.io/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://ylcheng1789.github.io/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2024-09-01T05:22:24.000Z</published>
    <updated>2024-09-01T06:01:13.440Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="1-说说有哪些常见的集合框架？"><a href="#1-说说有哪些常见的集合框架？" class="headerlink" title="1.说说有哪些常见的集合框架？"></a>1.说说有哪些常见的集合框架？</h3><p>Java 集合框架可以分为两条大的支线：<br>①、Collection，主要由 List、Set、Queue 组成：</p><ul><li>List 代表有序、可重复的集合，典型代表就是封装了动态数组的 <a href="https://javabetter.cn/collection/arraylist.html">ArrayList</a> 和封装了链表的 <a href="https://javabetter.cn/collection/linkedlist.html">LinkedList</a>；</li><li>Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；</li><li>Queue 代表队列，典型代表就是双端队列 <a href="https://javabetter.cn/collection/arraydeque.html">ArrayDeque</a>，以及优先级队列 <a href="https://javabetter.cn/collection/PriorityQueue.html">PriorityQueue</a>。</li></ul><p>②、Map，代表键值对的集合，典型代表就是 <a href="https://javabetter.cn/collection/hashmap.html">HashMap</a>。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/gailan-01.png"><br>概览图说明：<br>①、Collection 接口：最基本的集合框架表示方式，提供了添加、删除、清空等基本操作，它主要有三个子接口：</p><ul><li><code>List</code>：一个有序的集合，可以包含重复的元素。实现类包括 ArrayList、LinkedList 等。</li><li><code>Set</code>：一个不包含重复元素的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。</li><li><code>Queue</code>：一个用于保持元素队列的集合。实现类包括 PriorityQueue、ArrayDeque 等。</li></ul><p>②、<code>Map</code> 接口：表示键值对的集合，一个键映射到一个值。键不能重复，每个键只能对应一个值。Map 接口的实现类包括 HashMap、LinkedHashMap、TreeMap 等。<br>集合框架位于 java.util 包下，该包含提供了两个常用的工具类：</p><ul><li><a href="https://javabetter.cn/common-tool/collections.html">Collections</a>：提供了一些对集合进行排序、二分查找、同步的静态方法。</li><li><a href="https://javabetter.cn/common-tool/arrays.html">Arrays</a>：提供了一些对数组进行排序、打印、和 List 进行转换的静态方法。</li></ul><h4 id="简单介绍一下队列-Queue"><a href="#简单介绍一下队列-Queue" class="headerlink" title="简单介绍一下队列 Queue"></a>简单介绍一下队列 Queue</h4><p>Java 中的队列主要通过 java.util.Queue 接口和 java.util.concurrent.BlockingQueue 两个接口来实现。<br>PriorityQueue 是一个基于优先级堆的无界队列，它的元素按照自然顺序排序或者 Comparator 进行排序。<br>ArrayDeque 是一个基于数组的双端队列，可以在两端插入和删除元素。<br>LinkedList，它既可以当作 List 使用，也可以当作 Queue 使用。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/list-war-2-02.png"></p><h4 id="用过哪些集合类，它们的优劣？"><a href="#用过哪些集合类，它们的优劣？" class="headerlink" title="用过哪些集合类，它们的优劣？"></a>用过哪些集合类，它们的优劣？</h4><p>在 Java 中，常用的集合类有 ArrayList、LinkedList、HashMap、LinkedHashMap 等。</p><ol><li>ArrayList：ArrayList 可以看作是一个动态数组，它可以在运行时动态扩容。优点是访问速度快，可以通过索引直接查到元素。缺点是插入和删除元素可能需要移动元素，效率就会降低。</li><li>LinkedList：LinkedList 是一个双向链表，它适合频繁的插入和删除操作。优点是插入和删除元素的时候只需要改变节点的前后指针，缺点是访问元素时需要遍历链表。</li><li>HashMap：HashMap 是一个基于哈希表的键值对集合。优点是插入、删除和查找元素的速度都很快。缺点是它不保留键值对的插入顺序。</li><li>LinkedHashMap：LinkedHashMap 在 HashMap 的基础上增加了一个双向链表来保持键值对的插入顺序。</li></ol><h4 id="队列和栈的区别了解吗？"><a href="#队列和栈的区别了解吗？" class="headerlink" title="队列和栈的区别了解吗？"></a>队列和栈的区别了解吗？</h4><p>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构。在队列中，第一个加入队列的元素会是第一个被移除的。队列常用于处理按顺序来的任务。<br>栈是一种后进先出（LIFO, Last-In-First-Out）的数据结构。在这种结构中，最后一个加入栈的元素会是第一个被移除的。这种特性使得栈非常适合于那些需要访问最新添加的数据元素的场合。</p><h4 id="哪些是线程安全的？"><a href="#哪些是线程安全的？" class="headerlink" title="哪些是线程安全的？"></a>哪些是线程安全的？</h4><p>像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 这些都是线程安全的。</p><h4 id="Java-集合用过哪些？Collection-继承了哪些接口？"><a href="#Java-集合用过哪些？Collection-继承了哪些接口？" class="headerlink" title="Java 集合用过哪些？Collection 继承了哪些接口？"></a>Java 集合用过哪些？Collection 继承了哪些接口？</h4><p>最经常用的就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；以及键值对 HashMap。<br>Collection 继承了 Iterable 接口，这意味着所有实现 Collection 接口的类都必须实现 <code>iterator()</code> 方法，之后就可以使用增强型 for 循环遍历集合中的元素了。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="2-ArrayList-和-LinkedList-有什么区别？"><a href="#2-ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="2.ArrayList 和 LinkedList 有什么区别？"></a>2.ArrayList 和 LinkedList 有什么区别？</h3><p>推荐阅读：<a href="https://javabetter.cn/collection/list-war-2.html">二哥的 Java 进阶之路：ArrayList 和 LinkedList</a><br>ArrayList 和 LinkedList 的区别主要体现在数据结构、用途、是否支持随机访问、内存占用等方面。</p><h4 id="数据结构有什么不同？"><a href="#数据结构有什么不同？" class="headerlink" title="数据结构有什么不同？"></a>数据结构有什么不同？</h4><ul><li>ArrayList 基于数组实现</li><li>LinkedList 基于链表实现</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-2.png"></p><h4 id="用途有什么不同？"><a href="#用途有什么不同？" class="headerlink" title="用途有什么不同？"></a>用途有什么不同？</h4><p>多数情况下，ArrayList 更利于查找，LinkedList 更利于增删<br>①、由于 ArrayList 是基于数组实现的，所以 <code>get(int index)</code> 可以直接通过数组下标获取，时间复杂度是 O(1)；LinkedList 是基于链表实现的，<code>get(int index)</code> 需要遍历链表，时间复杂度是 O(n)。<br>当然，<code>get(E element)</code> 这种查找，两种集合都需要遍历通过 equals 比较获取元素，所以时间复杂度都是 O(n)。<br>②、ArrayList 如果增删的是数组的尾部，直接插入或者删除就可以了，时间复杂度是 O(1)；如果 add 的时候涉及到扩容，时间复杂度会提升到 O(n)。<br>但如果插入的是中间的位置，就需要把插入位置后的元素向前或者向后移动，甚至还有可能触发扩容，效率就会低很多，O(n)。<br>LinkedList 因为是链表结构，插入和删除只需要改变前置节点、后置节点和插入节点的引用就行了，不需要移动元素。<br>如果是在链表的头部插入或者删除，时间复杂度是 O(1)；如果是在链表的中间插入或者删除，时间复杂度是 O(n)，因为需要遍历链表找到插入位置；如果是在链表的尾部插入或者删除，时间复杂度是 O(1)。</p><p>注意，这里有个陷阱，<strong>LinkedList 更利于增删不是体现在时间复杂度上</strong>，因为二者增删的时间复杂度都是 O(n)，都需要遍历列表；而是体现在增删的效率上，因为 LinkedList 的增删只需要改变引用，而 ArrayList 的增删可能需要移动元素。</p><h4 id="是否支持随机访问？"><a href="#是否支持随机访问？" class="headerlink" title="是否支持随机访问？"></a>是否支持随机访问？</h4><p>①、ArrayList 是基于数组的，也实现了 RandomAccess 接口，所以它支持随机访问，可以通过下标直接获取元素。<br>②、LinkedList 是基于链表的，所以它没法根据下标直接获取元素，不支持随机访问，所以它也没有实现 RandomAccess 接口。</p><h4 id="内存占用有何不同？"><a href="#内存占用有何不同？" class="headerlink" title="内存占用有何不同？"></a>内存占用有何不同？</h4><p>ArrayList 是基于数组的，是一块连续的内存空间，所以它的内存占用是比较紧凑的；但如果涉及到扩容，就会重新分配内存，空间是原来的 1.5 倍，存在一定的空间浪费。<br>LinkedList 是基于链表的，每个节点都有一个指向下一个节点和上一个节点的引用，于是每个节点占用的内存空间稍微大一点。</p><h4 id="使用场景有什么不同？"><a href="#使用场景有什么不同？" class="headerlink" title="使用场景有什么不同？"></a>使用场景有什么不同？</h4><p>ArrayList 适用于：</p><ul><li>随机访问频繁：需要频繁通过索引访问元素的场景。</li><li>读取操作远多于写入操作：如存储不经常改变的列表。</li><li>末尾添加元素：需要频繁在列表末尾添加元素的场景。</li></ul><p>LinkedList 适用于：</p><ul><li>频繁插入和删除：在列表中间频繁插入和删除元素的场景。</li><li>不需要快速随机访问：顺序访问多于随机访问的场景。</li><li>队列和栈：由于其双向链表的特性，LinkedList 可以高效地实现队列（FIFO）和栈（LIFO）。</li></ul><h3 id="3-ArrayList-的扩容机制了解吗？"><a href="#3-ArrayList-的扩容机制了解吗？" class="headerlink" title="3.ArrayList 的扩容机制了解吗？"></a>3.ArrayList 的扩容机制了解吗？</h3><p>ArrayList 确切地说，应该叫做动态数组，因为它的底层是通过数组来实现的，当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-5.png"><br>扩容后的新数组长度是原来的 1.5 倍，然后再把原数组的值拷贝到新数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的联想面经同学 7 面试原题：Java 集合类介绍，挑一个讲原理。</li></ol></blockquote><h3 id="4-ArrayList-怎么序列化的知道吗？-为什么用-transient-修饰数组？"><a href="#4-ArrayList-怎么序列化的知道吗？-为什么用-transient-修饰数组？" class="headerlink" title="4.ArrayList 怎么序列化的知道吗？ 为什么用 transient 修饰数组？"></a>4.ArrayList 怎么序列化的知道吗？ 为什么用 transient 修饰数组？</h3><p>ArrayList 的序列化不太一样，它使用<code>transient</code>修饰存储元素的<code>elementData</code>的数组，<code>transient</code>关键字的作用是让被修饰的成员属性不被序列化。<br><strong>为什么最 ArrayList 不直接序列化元素数组呢？</strong><br>出于效率的考虑，数组可能长度 100，但实际只用了 50，剩下的 50 不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。<br><strong>那 ArrayList 怎么序列化呢？</strong><br>ArrayList 通过两个方法<strong>readObject、writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>来进行序列化和反序列化。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-6.png"></p><h3 id="5-快速失败-fail-fast-和安全失败-fail-safe-了解吗？"><a href="#5-快速失败-fail-fast-和安全失败-fail-safe-了解吗？" class="headerlink" title="5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？"></a>5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？</h3><p><strong>快速失败（fail—fast）</strong>：快速失败是 Java 集合的一种错误检测机制</p><ul><li>在用迭代器遍历一个集合对象时，如果线程 A 遍历过程中，线程 B 对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。</li><li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <code> modCount</code> 变量。集合在被遍历期间如果内容发生变化，就会改变<code>modCount</code>的值。每当迭代器使用 hashNext()&#x2F;next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>注意：这里异常的抛出条件是检测到 modCount！&#x3D;expectedmodCount 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。</li><li>场景：java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如 ArrayList 类。</li></ul><p><strong>安全失败（fail—safe）</strong></p><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</li><li>缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>场景：java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如 CopyOnWriteArrayList 类。</li></ul><h3 id="6-有哪几种实现-ArrayList-线程安全的方法？"><a href="#6-有哪几种实现-ArrayList-线程安全的方法？" class="headerlink" title="6.有哪几种实现 ArrayList 线程安全的方法？"></a>6.有哪几种实现 ArrayList 线程安全的方法？</h3><p>可以使用 <code>Collections.synchronizedList()</code> 方法，它将返回一个线程安全的 List。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SynchronizedList</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br></pre></td></tr></table></figure><p>内部是通过 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>加锁来实现的。<br>也可以直接使用 <a href="https://javabetter.cn/thread/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a>，它是线程安全的，遵循写时复制的原则，每当对列表进行修改（例如添加、删除或更改元素）时，都会创建列表的一个新副本，这个新副本会替换旧的列表，而对旧列表的所有读取操作仍然可以继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CopyOnWriteArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>();</span><br></pre></td></tr></table></figure><p>通俗的讲，CopyOnWrite 就是当我们往一个容器添加元素的时候，不直接往容器中添加，而是先复制出一个新的容器，然后在新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。多个线程在读的时候，不需要加锁，因为当前容器不会添加任何元素。这样就实现了线程安全。</p><h4 id="ArrayList-和-Vector-的区别？"><a href="#ArrayList-和-Vector-的区别？" class="headerlink" title="ArrayList 和 Vector 的区别？"></a>ArrayList 和 Vector 的区别？</h4><p>Vector 属于 JDK 1.0 时期的遗留类，已不推荐使用，仍然保留着是因为 Java 希望向后兼容。<br>ArrayList 是在 JDK 1.2 时引入的，用于替代 Vector 作为主要的非同步动态数组实现。因为 Vector 所有的方法都使用 synchronized 关键字进行了同步，单线程环境下效率较低。</p><h3 id="7-CopyOnWriteArrayList-了解多少？"><a href="#7-CopyOnWriteArrayList-了解多少？" class="headerlink" title="7.CopyOnWriteArrayList 了解多少？"></a>7.CopyOnWriteArrayList 了解多少？</h3><p>CopyOnWriteArrayList 就是线程安全版本的 ArrayList。<br>它的名字叫<code>CopyOnWrite</code>——写时复制，已经明示了它的原理。<br>CopyOnWriteArrayList 采用了一种读写分离的并发策略。CopyOnWriteArrayList 容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-7.png"></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 中，毫无疑问，最重要的就是 HashMap，面试基本被盘出包浆了，各种问法，一定要好好准备。</p><h3 id="8-能说一下-HashMap-的底层数据结构吗？"><a href="#8-能说一下-HashMap-的底层数据结构吗？" class="headerlink" title="8.能说一下 HashMap 的底层数据结构吗？"></a>8.能说一下 HashMap 的底层数据结构吗？</h3><p>JDK 8 中 HashMap 的数据结构是<code>数组</code>+<code>链表</code>+<code>红黑树</code>。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-8.png"><br>HashMap 的核心是一个动态数组（<code>Node[] table</code>），用于存储键值对。这个数组的每个元素称为一个“桶”（Bucket），每个桶的索引是通过对键的哈希值进行哈希函数处理得到的。<br>当多个键经哈希处理后得到相同的索引时，会发生哈希冲突。HashMap 通过链表来解决哈希冲突——即将具有相同索引的键值对通过链表连接起来。<br>不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时（且数组的长度大于 64），链表就会转换为红黑树。红黑树的查询效率是 O(logn)，比链表的 O(n) 要快。数组的查询效率是 O(1)。<br>当向 HashMap 中添加一个键值对时，会使用哈希函数计算键的哈希码，确定其在数组中的位置，哈希函数的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当向 HashMap 中添加元素时，如果该位置已有元素（发生哈希冲突），则新元素将被添加到链表的末尾或红黑树中。如果键已经存在，其对应的值将被新值覆盖。<br>当从 HashMap 中获取元素时，也会使用哈希函数计算键的位置，然后根据位置在数组、链表或者红黑树中查找元素。<br>HashMap 的初始容量是 16，随着元素的不断添加，HashMap 的容量（也就是数组大小）可能不足，于是就需要进行扩容，阈值是<code>capacity * loadFactor</code>，capacity 为容量，loadFactor 为负载因子，默认为 0.75。<br>扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。<br>总的来说，HashMap 是一种通过哈希表实现的键值对集合，它通过将键哈希化成数组索引，并在冲突时使用链表或红黑树来存储元素，从而实现快速的查找、插入和删除操作。</p><h3 id="9-你对红黑树了解多少？为什么不用二叉树-平衡树呢？"><a href="#9-你对红黑树了解多少？为什么不用二叉树-平衡树呢？" class="headerlink" title="9.你对红黑树了解多少？为什么不用二叉树&#x2F;平衡树呢？"></a>9.你对红黑树了解多少？为什么不用二叉树&#x2F;平衡树呢？</h3><p>红黑树是一种自平衡的二叉查找树：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色；</li><li>所有的叶子节点都是是黑色的（下图中的 NULL 节点）；</li><li>红色节点的子节点一定是黑色的；</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-9.png"></p><h4 id="为什么不用二叉树？"><a href="#为什么不用二叉树？" class="headerlink" title="为什么不用二叉树？"></a>为什么不用二叉树？</h4><p>二叉树是最基本的树结构，每个节点最多有两个子节点，但是二叉树容易出现极端情况，比如插入的数据是有序的，那么二叉树就会退化成链表，查询效率就会变成 O(n)。</p><h4 id="为什么不用平衡二叉树？"><a href="#为什么不用平衡二叉树？" class="headerlink" title="为什么不用平衡二叉树？"></a>为什么不用平衡二叉树？</h4><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差 1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。<br>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p><h3 id="10-红黑树怎么保持平衡的？"><a href="#10-红黑树怎么保持平衡的？" class="headerlink" title="10.红黑树怎么保持平衡的？"></a>10.红黑树怎么保持平衡的？</h3><p>红黑树有两种方式保持平衡：<code>旋转</code>和<code>染色</code>。</p><h3 id="11-HashMap-的-put-流程知道吗？"><a href="#11-HashMap-的-put-流程知道吗？" class="headerlink" title="11.HashMap 的 put 流程知道吗？"></a>11.HashMap 的 put 流程知道吗？</h3><p>直接看流程图。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-13.jpeg"><br>第一步，通过 hash 方法计算 key 的哈希值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，数组进行第一次扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在链表中插入节点的时候，如果链表长度大于等于 8，则需要把链表转换为红黑树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><p>所有元素处理完后，还需要判断是否超过阈值<code>threshold</code>，超过则扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><h4 id="只重写-equals-没重写-hashcode，map-put-的时候会发生什么"><a href="#只重写-equals-没重写-hashcode，map-put-的时候会发生什么" class="headerlink" title="只重写 equals 没重写 hashcode，map put 的时候会发生什么?"></a>只重写 equals 没重写 hashcode，map put 的时候会发生什么?</h4><p>如果只重写 equals 方法，没有重写 hashcode 方法，那么会导致 equals 相等的两个对象，hashcode 不相等，这样的话，这两个对象会被放到不同的桶中，这样就会导致 get 的时候，找不到对应的值。</p><h3 id="12-HashMap-怎么查找元素的呢？"><a href="#12-HashMap-怎么查找元素的呢？" class="headerlink" title="12.HashMap 怎么查找元素的呢？"></a>12.HashMap 怎么查找元素的呢？</h3><p>先看流程图：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-14.png"><br>HashMap 的查找就简单很多：</p><ol><li>使用扰动函数，获取新的哈希值</li><li>计算数组下标，获取节点</li><li>当前节点和 key 匹配，直接返回</li><li>否则，当前节点是否为树节点，查找红黑树</li><li>否则，遍历链表查找</li></ol><h3 id="13-HashMap-的-hash-函数是怎么设计的"><a href="#13-HashMap-的-hash-函数是怎么设计的" class="headerlink" title="13.HashMap 的 hash 函数是怎么设计的?"></a>13.HashMap 的 hash 函数是怎么设计的?</h3><p>HashMap 的哈希函数是先拿到 key 的 hashcode，是一个 32 位的 int 类型的数值，然后让 hashcode 的高 16 位和低 16 位进行异或操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key的hashCode和key的hashCode右移16位做异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么设计是为了降低哈希碰撞的概率。</p><h3 id="14-为什么-hash-函数能降哈希碰撞？"><a href="#14-为什么-hash-函数能降哈希碰撞？" class="headerlink" title="14.为什么 hash 函数能降哈希碰撞？"></a>14.为什么 hash 函数能降哈希碰撞？</h3><p>在 hash 函数中，先调用了 key 的<code>hashCode()</code> 方法，这将会返回一个 int 类型的哈希值，比如说字符串的 hashCode。<br>int 的范围是 <strong>-2147483648~2147483647</strong>，加起来大概 40 亿上下的浮动。<br>只要 key 的 hashCode 方法设计的比较合理，一般是很难出现碰撞的。但问题是，不可能直接搞一个 40 亿长度的数组啊，那也太铺张浪费了。<br>我们一般会设置一个较小的数组长度，比如说 HashMap 的数组初始大小才 16，当发现容量不满足的时候再扩容，避免浪费。<br>那当数组长度比较小的时候，我们就需要设计一种比较巧妙的 hash 算法，来避免发生哈希冲突，尽可能地让元素均匀地分布在数组当中。<br>要达到这个目的，HashMap 在两方面下足了功夫，第一个就是数组的长度必须是 2 的整数次幂，这样可以保证 <code>hash &amp; (n-1)</code> 的结果能均匀地分布在数组中。<br>其作用就相当于 hash % n，n 为数组的长度，比如说数组长度是 16，hash 值为 20，那么 20 % 16 &#x3D; 4，也就是说 20 这个元素应该放在数组的第 4 个位置；hash 值为 23，那么 23 % 16 &#x3D; 7，也就是说 23 这个元素应该放在数组的第 7 个位置。<br><code>&amp;</code> 操作的结果就是哈希值的高位全部归零，只保留 n 个低位，用来做数组下标访问。<br>比如说 hash &amp; ($2^{4} - 1$) 的结果实际上是取 hash 的低 4 位，这四位能表示的取值范围刚好是 0000 到 1111，也就是 0 到 15，正好是数组长度为 16 的下标范围。<br>以初始长度 16 为例，16-1&#x3D;15。2 进制表示是<code>0000 0000 0000 0000 0000 0000 0000 1111</code>。和某个哈希值做 <code>&amp;</code> 运算，结果就是截取了最低的四位。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-15.png"><br>那问题又来了，那么大一个哈希值，也只取最后 4 位，不就等于哈希值的高位都丢弃了吗？<br>比如说 1111 1111 1111 1111 1111 1111 1111 1111，取最后 4 位，也就是 1111。<br>比如说 1110 1111 1111 1111 1111 1111 1111 1111，取最后 4 位，也是 1111。<br>不就发生哈希冲突了吗？<br>这时候 hash 函数 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 就派上用场了呀。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-16.jpeg"><br>将哈希值无符号右移 16 位，意味着原哈希值的高 16 位被移到了低 16 位的位置。这样，原始哈希值的高 16 位和低 16 位就可以参与到最终用于索引计算的低位中。<br>选择 16 位是因为它是 32 位整数的一半，这样处理既考虑了高位的信息，又没有完全忽视低位原本的信息，尝试达到一个平衡状态。<br>举个例子（数组长度为 16）。</p><ul><li>第一个数：h1 &#x3D; 0001 0010 0011 0100 0101 0110 0111 1000</li><li>第二个数：h2 &#x3D; 0001 0010 0011 0101 0101 0110 0111 1000</li></ul><p>如果没有 hash 函数，直接取低 4 位，那么 h1 和 h2 的低 4 位都是 1000，也就是两个数都会放在数组的第 8 个位置。<br>来看一下 hash 函数的处理过程。<br>①、对于第一个数<code>h1</code>的计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始: 0001 0010 0011 0100 0101 0110 0111 1000</span><br><span class="line">右移: 0000 0000 0000 0000 0001 0010 0011 0100</span><br><span class="line">异或: ---------------------------------------</span><br><span class="line">结果: 0001 0010 0011 0100 0100 0100 0100 1100</span><br></pre></td></tr></table></figure><p>②、对于第二个数<code>h2</code>的计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始: 0001 0010 0011 0101 0101 0110 0111 1000</span><br><span class="line">右移: 0000 0000 0000 0000 0001 0010 0011 0101</span><br><span class="line">异或: ---------------------------------------</span><br><span class="line">结果: 0001 0010 0011 0101 0100 0100 0100 1101</span><br></pre></td></tr></table></figure><p>通过上述计算，我们可以看到<code>h1</code>和<code>h2</code>经过<code>h ^ (h &gt;&gt;&gt; 16)</code>操作后得到了不同的结果。<br>现在，考虑数组长度为 16 时（需要最低 4 位来确定索引）：</p><ul><li>对于<code>h1</code>的最低 4 位是<code>1100</code>（十进制中为 12）</li><li>对于<code>h2</code>的最低 4 位是<code>1101</code>（十进制中为 13）</li></ul><p>这样，<code>h1</code>和<code>h2</code>就会被分别放在数组的第 12 个位置和第 13 个位置上，避免了哈希冲突。</p><h3 id="15-为什么-HashMap-的容量是-2-的倍数呢？"><a href="#15-为什么-HashMap-的容量是-2-的倍数呢？" class="headerlink" title="15.为什么 HashMap 的容量是 2 的倍数呢？"></a>15.为什么 HashMap 的容量是 2 的倍数呢？</h3><p>HashMap 的容量是 2 的倍数，或者说是 2 的整数次幂，是为了快速定位元素的下标：<br>HashMap 在定位元素位置时，先通过 <code>hash(key) = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 计算出哈希值，再通过 <code>hash &amp; (n-1)</code> 来定位元素位置的，n 为数组的大小，也就是 HashMap 的容量。<br>因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0。</p><blockquote><p>a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0。例如 5&amp;3&#x3D;1，5 的二进制是 0101，3 的二进制是 0011，5&amp;3&#x3D;0001&#x3D;1。</p></blockquote><p>2 的整次幂（或者叫 2 的整数倍）刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 <code>hash &amp;(length-1)</code> 的最后一位可能为 0，也可能为 1（取决于 hash 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀分布。<br>换句话说，&amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值。<br>假设某哈希值的二进制为 <code>10100101 11000100 00100101</code>，用它来做 &amp; 运算，我们来看一下结果。<br>我们知道，HashMap 的初始长度为 16，16-1&#x3D;15，二进制是 <code>00000000 00000000 00001111</code>（高位用 0 来补齐）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     10100101 11000100 00100101</span><br><span class="line">&amp; 00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">     00000000 00000000 00000101</span><br></pre></td></tr></table></figure><p>因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定也是 0，只剩下 4 个低位 <code>0101</code>，也就是十进制的 5。<br>这样，哈希值为 <code>10100101 11000100 00100101</code> 的键就会放在数组的第 5 个位置上。</p><h4 id="hashCode-对数组长度取模定位数组下标，这块有没有优化策略？"><a href="#hashCode-对数组长度取模定位数组下标，这块有没有优化策略？" class="headerlink" title="hashCode 对数组长度取模定位数组下标，这块有没有优化策略？"></a>hashCode 对数组长度取模定位数组下标，这块有没有优化策略？</h4><p>从此，两个运算 <code>hash % length</code> 和 <code>hash &amp; (length - 1)</code> 有了完美的闭环。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。</p><h3 id="16-如果初始化-HashMap，传一个-17-容量，它会怎么处理？"><a href="#16-如果初始化-HashMap，传一个-17-容量，它会怎么处理？" class="headerlink" title="16.如果初始化 HashMap，传一个 17 容量，它会怎么处理？"></a>16.如果初始化 HashMap，传一个 17 容量，它会怎么处理？</h3><p>HashMap 会将这个值转换为大于或等于 17 的最小的 2 的幂。这是因为 HashMap 的设计是基于哈希表的，而哈希表的大小最好是 2 的幂，这样可以优化哈希值的计算，并减少哈希冲突。<br>所以，如果你传入 17 作为初始容量，HashMap 实际上会被初始化为大小为 32 的哈希表。<br>在 HashMap 的初始化构造方法中，有这样⼀段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"> <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阀值 threshold 会通过⽅法<code> tableSizeFor()</code> 进⾏计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-HashMap-的时候需要传入容量值吗？"><a href="#初始化-HashMap-的时候需要传入容量值吗？" class="headerlink" title="初始化 HashMap 的时候需要传入容量值吗？"></a>初始化 HashMap 的时候需要传入容量值吗？</h4><p>在创建 HashMap 时可以指定初始容量值。这个容量是指 Map 内部用于存储数据的数组大小。<br>如果预先知道 Map 将存储大量键值对，提前指定一个足够大的初始容量可以减少因扩容导致的重哈希（rehashing）操作，从而提高性能。<br>因为每次扩容时，HashMap 需要新分配一个更大的数组并重新将现有的元素插入到这个新数组中，这个过程相对耗时，尤其是当 Map 中已有大量数据时。<br>当然了，过大的初始容量会浪费内存，特别是当实际存储的元素远少于初始容量时。如果不指定初始容量，HashMap 将使用默认的初始容量 16。</p><h3 id="17-你还知道哪些哈希函数的构造方法呢？"><a href="#17-你还知道哪些哈希函数的构造方法呢？" class="headerlink" title="17.你还知道哪些哈希函数的构造方法呢？"></a>17.你还知道哪些哈希函数的构造方法呢？</h3><p>HashMap 里哈希构造函数的方法叫：</p><ul><li><strong>除留取余法</strong>：<code>H(key)=key%p(p&lt;=N)</code>，关键字除以一个不大于哈希表长度的正整数 p，所得余数为地址，当然 HashMap 里进行了优化改造，效率更高，散列也更均衡。</li></ul><p>除此之外，还有这几种常见的哈希函数构造方法：</p><ul><li><strong>直接定址法</strong>直接根据<code>key</code>来映射到对应的数组位置，例如 1232 放到下标 1232 的位置。</li><li><strong>数字分析法</strong>取<code>key</code>的某些数字（例如十位和百位）作为映射的位置</li><li><strong>平方取中法</strong>取<code>key</code>平方的中间几位作为映射的位置</li><li><strong>折叠法</strong>将<code>key</code>分割成位数相同的几段，然后把它们的叠加和作为映射的位置</li></ul><h3 id="18-解决哈希冲突有哪些方法呢？"><a href="#18-解决哈希冲突有哪些方法呢？" class="headerlink" title="18.解决哈希冲突有哪些方法呢？"></a>18.解决哈希冲突有哪些方法呢？</h3><p>解决哈希冲突的方法我知道的有 3 种：<br>①、再哈希法<br>准备两套哈希算法，当发生哈希冲突的时候，使用另外一种哈希算法，直到找到空槽为止。对哈希算法的设计要求比较高。<br>②、开放地址法<br>遇到哈希冲突的时候，就去寻找下一个空的槽。有 3 种方法：</p><ul><li>线性探测：从冲突的位置开始，依次往后找，直到找到空槽。</li><li>二次探测：从冲突的位置 x 开始，第一次增加 $1^2$ 个位置，第二次增加 $2^2$，直到找到空槽。</li><li>双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数。</li></ul><p>③、拉链法<br>也就是所谓的链地址法，当发生哈希冲突的时候，使用链表将冲突的元素串起来。HashMap 采用的正是拉链法。</p><h4 id="怎么判断-key-相等呢？"><a href="#怎么判断-key-相等呢？" class="headerlink" title="怎么判断 key 相等呢？"></a>怎么判断 key 相等呢？</h4><p><code>HashMap</code>判断两个<code>key</code>是否相等，依赖于<code>key</code>的<code>equals()</code>方法和<code>hashCode()</code>方法，以及 <code>==</code> 运算符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure><p>①、<strong>hashCode()</strong> ：首先，使用<code>key</code>的<code>hashCode()</code>方法计算<code>key</code>的哈希码。由于不同的<code>key</code>可能有相同的哈希码，<code>hashCode()</code>只是第一步筛选。<br>②、<strong>equals()</strong> ：当两个<code>key</code>的哈希码相同时，<code>HashMap</code>还会调用<code>key</code>的<code>equals()</code>方法进行精确比较。只有当<code>equals()</code>方法返回<code>true</code>时，两个<code>key</code>才被认为是完全相同的。<br>③、：当然了，如果两个<code>key</code>的引用指向同一个对象，那么它们的<code>hashCode()</code>和<code>equals()</code>方法都会返回<code>true</code>，所以在 equals 判断之前会优先使用&#96;&#96;运算符判断一次。</p><h3 id="19-为什么-HashMap-链表转红黑树的阈值为-8-呢？"><a href="#19-为什么-HashMap-链表转红黑树的阈值为-8-呢？" class="headerlink" title="19.为什么 HashMap 链表转红黑树的阈值为 8 呢？"></a>19.为什么 HashMap 链表转红黑树的阈值为 8 呢？</h3><p>树化发生在 table 数组的长度大于 64，且链表的长度大于 8 的时候。<br>为什么是 8 呢？源码的注释也给出了答案。<br>红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。<br>阈值为什么要选 8 呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为 8 的情况，发生概率仅为<code>0.00000006</code>。<br>至于红黑树转回链表的阈值为什么是 6，而不是 8？是因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。</p><h3 id="20-扩容在什么时候呢？为什么扩容因子是-0-75？"><a href="#20-扩容在什么时候呢？为什么扩容因子是-0-75？" class="headerlink" title="20.扩容在什么时候呢？为什么扩容因子是 0.75？"></a>20.扩容在什么时候呢？为什么扩容因子是 0.75？</h3><p>HashMap 会在存储的键值对数量超过阈值（即容量 * 加载因子）时进行扩容。<br>默认的加载因子是 0.75，这意味着当 HashMap 填满了大约 75%的容量时，就会进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>默认的初始容量是 16，那就是大于<code>16x0.75=12</code>时，就会触发第一次扩容操作。</p><h4 id="那么为什么选择了-0-75-作为-HashMap-的默认加载因子呢？"><a href="#那么为什么选择了-0-75-作为-HashMap-的默认加载因子呢？" class="headerlink" title="那么为什么选择了 0.75 作为 HashMap 的默认加载因子呢？"></a>那么为什么选择了 0.75 作为 HashMap 的默认加载因子呢？</h4><p>简单来说，这是对<code>空间</code>成本和<code>时间</code>成本平衡的考虑。<br>在 HashMap 中有这样一段注释：<br>我们都知道，HashMap 的散列构造方式是 Hash 取余，负载因子决定元素个数达到多少时候扩容。<br>假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了。<br>我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了。</p><h3 id="21-那扩容机制了解吗？"><a href="#21-那扩容机制了解吗？" class="headerlink" title="21.那扩容机制了解吗？"></a>21.那扩容机制了解吗？</h3><p>扩容时，HashMap 会创建一个新的数组，其容量是原数组容量的两倍。然后将键值对放到新计算出的索引位置上。一部分索引不变，另一部分索引为“原索引+旧容量”。</p><blockquote><p>为了便于理解，我会结合 JDK7 和 JDK8 两个版本来讲。</p></blockquote><p>在 JDK 7 中，定位元素位置的代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就相当于用键的哈希值和数组大小取模，也就是 <code>hashCode % table.length</code>。<br>那我们来假设：</p><ul><li>数组 table 的长度为 2</li><li>键的哈希值为 3、7、5</li></ul><p>取模运算后，键发生了哈希冲突，都到 <code>table[1]</code> 上了。那么扩容前就是这个样子。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-resize-01.png"><br>数组的容量为 2，key 为 3、7、5 的元素在 <code>table[1]</code> 上，需要通过拉链法来解决哈希冲突。<br>假设负载因子 loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。<br>扩容后的数组容量为 4。</p><ul><li>key 3 取模（3%4）后是 3，放在 <code>table[3]</code> 上。</li><li>key 7 取模（7%4）后是 3，放在 <code>table[3]</code> 上的链表头部。</li><li>key 5 取模（5%4）后是 1，放在 <code>table[1]</code> 上。</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-resize-02.png"><br>7 跑到 3 的前面了，因为 JDK 7 使用的是头插法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i];</span><br></pre></td></tr></table></figure><p>同时，扩容后的 5 跑到了下标为 1 的位置。<br>最好的情况就是，扩容后的 7 在 3 的后面，5 在 7 的后面，保持原来的顺序。<br>JDK 8 完全扭转了这个局面，因为 JDK 8 的哈希算法进行了优化，当数组长度为 2 的幂次方时，能够很巧妙地解决 JDK 7 中遇到的问题。<br>JDK 8 的扩容代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = <span class="keyword">new</span> <span class="title class_">Node</span>[newCapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldTab.length; j++) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e = oldTab[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> e.hash;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newIndex</span> <span class="operator">=</span> hash &amp; (newCapacity - <span class="number">1</span>); <span class="comment">// 计算在新数组中的位置</span></span><br><span class="line">        <span class="comment">// 将节点移动到新数组的对应位置</span></span><br><span class="line">        newTab[newIndex] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新索引的计算方式是 <code>hash &amp; (newCapacity - 1)</code>，和 JDK 7 的 <code>h &amp; (length-1)</code>没什么大的差别，差别主要在 hash 方法上，JDK 8 是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过将键的<code>hashCode()</code>返回的 32 位哈希值与这个哈希值无符号右移 16 位的结果进行异或。<br>JDK 7 是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 JDK 8 的哈希算法来计算一下哈希值，就会发现别有洞天。<br>假设扩容前的数组长度为 16（n-1 也就是二进制的 0000 1111，1X${2^0}$+1X${2^1}$+1X${2^2}$+1X${2^3}$&#x3D;1+2+4+8&#x3D;15），key1 为 5（二进制为 0000 0101），key2 为 21（二进制为 0001 0101）。</p><ul><li>key1 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5；</li><li>key2 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5。</li><li>此时哈希冲突了，用拉链法来解决哈希冲突。</li></ul><p>现在，HashMap 进行了扩容，容量为原来的 2 倍，也就是 32（n-1 也就是二进制的 0001 1111，1X${2^0}$+1X${2^1}$+1X${2^2}$+1X${2^3}$+1X${2^4}$&#x3D;1+2+4+8+16&#x3D;31）。</p><ul><li>key1 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5；</li><li>key2 和 n-1 做 &amp; 运算后为 0001 0101，也就是 21&#x3D;5+16，也就是数组扩容前的位置+原数组的长度。</li></ul><p>神奇吧？<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-26.png"><br>换句话说，在 JDK 8 的新 hash 算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定的规律。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-27.png"><br>当然了，这个功劳既属于新的哈希算法，也离不开 n 为 2 的整数次幂这个前提，这是它俩通力合作后的结果 <code>hash &amp; (newCapacity - 1)</code>。</p><h4 id="那你说说扩容的时候每个节点都要进行位运算吗，如果我这个-HashMap-里面有几十万条数据，都要进行位运算吗？"><a href="#那你说说扩容的时候每个节点都要进行位运算吗，如果我这个-HashMap-里面有几十万条数据，都要进行位运算吗？" class="headerlink" title="那你说说扩容的时候每个节点都要进行位运算吗，如果我这个 HashMap 里面有几十万条数据，都要进行位运算吗？"></a>那你说说扩容的时候每个节点都要进行位运算吗，如果我这个 HashMap 里面有几十万条数据，都要进行位运算吗？</h4><p>在 JDK 8 的新 hash 算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定的规律。<br>具体来说，就是判断原哈希值的高位中新增的那一位是否为 1，如果是，该元素会被移动到原位置加上旧容量的位置；如果不是，则保持在原位置。<br>所以，尽管有几十万条数据，每个数据项的位置决定仅需要一次简单的位运算。位运算的计算速度非常快，因此，尽管扩容操作涉及遍历整个哈希表并对每个节点进行操作，但这部分操作的计算成本是相对较低的。</p><h3 id="22-JDK-8-对-HashMap-主要做了哪些优化呢？为什么？"><a href="#22-JDK-8-对-HashMap-主要做了哪些优化呢？为什么？" class="headerlink" title="22.JDK 8 对 HashMap 主要做了哪些优化呢？为什么？"></a>22.JDK 8 对 HashMap 主要做了哪些优化呢？为什么？</h3><p>相比较 JDK 7，JDK 8 的 HashMap 主要做了四点优化：<br>①、底层数据结构由数组 + 链表改成了数组 + 链表或红黑树的结构。<br>原因：如果多个键映射到了同一个哈希值，链表会变得很长，在最坏的情况下，当所有的键都映射到同一个桶中时，性能会退化到 O(n)，而红黑树的时间复杂度是 O(logn)。<br>②、链表的插入方式由头插法改为了尾插法。<br>原因：头插法虽然简单快捷，但扩容后容易改变原来链表的顺序。<br>③、扩容的时机由插入时判断改为插入后判断。<br>原因：可以避免在每次插入时都进行不必要的扩容检查，因为有可能插入后仍然不需要扩容。<br>④、优化了哈希算法。<br>JDK 7 进行了多次移位和异或操作来计算元素的哈希值。<br>JDK 8 优化了这个算法，只进行了一次异或操作，但仍然能有效地减少冲突。<br>并且能够保证扩容后，元素的新位置要么是原位置，要么是原位置加上旧容量大小。</p><h3 id="23-你能自己设计实现一个-HashMap-吗？"><a href="#23-你能自己设计实现一个-HashMap-吗？" class="headerlink" title="23.你能自己设计实现一个 HashMap 吗？"></a>23.你能自己设计实现一个 HashMap 吗？</h3><p>这道题<strong>快手</strong>常考。<br>不要慌，红黑树版咱们多半是写不出来，但是数组+链表版还是问题不大的，详细可见： <a href="https://mp.weixin.qq.com/s/Z9yoRZW5itrtgbS-cj0bUg">手写 HashMap，快手面试官直呼内行！</a>。<br>整体的设计：</p><ul><li>散列函数：hashCode()+除留余数法</li><li>冲突解决：链地址法</li><li>扩容：节点重新 hash 获取位置</li></ul><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-29.png"><br>完整代码：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-30.png"></p><h3 id="24-HashMap-是线程安全的吗？多线程下会有什么问题？"><a href="#24-HashMap-是线程安全的吗？多线程下会有什么问题？" class="headerlink" title="24.HashMap 是线程安全的吗？多线程下会有什么问题？"></a>24.HashMap 是线程安全的吗？多线程下会有什么问题？</h3><p>推荐阅读：<a href="https://javabetter.cn/collection/hashmap.html#_04%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">HashMap 详解</a><br>HashMap 不是线程安全的，主要有以下几个问题：<br>①、多线程下扩容会死循环。JDK1.7 中的 HashMap 使用的是头插法插入元素，在多线程的环境下，扩容的时候就有可能导致出现环形链表，造成死循环。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-thread-nosafe-07.png"><br>不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序。<br>②、多线程的 put 可能会导致元素的丢失。因为计算出来的位置可能会被其他线程的 put 覆盖。本来哈希冲突是应该用链表的，但多线程时由于没有加锁，相同位置的元素可能就被干掉了。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-thread-nosafe-10.png"><br>③、put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而导致出现扩容，线程 2 此时执行 get，就有可能出现这个问题。<br>因为线程 1 执行完 table &#x3D; newTab 之后，线程 2 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。</p><h3 id="25-有什么办法能解决-HashMap-线程不安全的问题呢？"><a href="#25-有什么办法能解决-HashMap-线程不安全的问题呢？" class="headerlink" title="25.有什么办法能解决 HashMap 线程不安全的问题呢？"></a>25.有什么办法能解决 HashMap 线程不安全的问题呢？</h3><p>在 Java 中，有 3 种线程安全的 Map 实现，最常用的是<a href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a>和<code>Collections.synchronizedMap(Map)</code>包装器。<br>Hashtable 也是线程安全的，但它的使用已经不再推荐使用，因为 ConcurrentHashMap 提供了更高的并发性和性能。<br>①、HashTable 是直接在方法上加 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>，比较粗暴。<br>②、<code>Collections.synchronizedMap</code> 返回的是 <a href="https://javabetter.cn/common-tool/collections.html">Collections</a> 工具类的内部类。<br>内部是通过 synchronized 对象锁来保证线程安全的。<br>③、<a href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a> 在 JDK 7 中使用分段锁，在 JKD 8 中使用了 <a href="https://javabetter.cn/thread/cas.html">CAS（Compare-And-Swap）</a>+ <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>，性能得到进一步提升。</p><h3 id="26-HashMap-内部节点是有序的吗？"><a href="#26-HashMap-内部节点是有序的吗？" class="headerlink" title="26.HashMap 内部节点是有序的吗？"></a>26.HashMap 内部节点是有序的吗？</h3><p>HashMap 是无序的，根据 hash 值随机插入。如果想使用有序的 Map，可以使用 LinkedHashMap 或者 TreeMap。</p><h3 id="27-讲讲-LinkedHashMap-怎么实现有序的？"><a href="#27-讲讲-LinkedHashMap-怎么实现有序的？" class="headerlink" title="27.讲讲 LinkedHashMap 怎么实现有序的？"></a>27.讲讲 LinkedHashMap 怎么实现有序的？</h3><p>LinkedHashMap 维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-33.png"><br>可以实现按插入的顺序或访问顺序排序。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-34.png"></p><h3 id="28-讲讲-TreeMap-怎么实现有序的？"><a href="#28-讲讲-TreeMap-怎么实现有序的？" class="headerlink" title="28.讲讲 TreeMap 怎么实现有序的？"></a>28.讲讲 TreeMap 怎么实现有序的？</h3><p>TreeMap 通过 key 的比较器来决定元素的顺序，如果没有指定比较器，那么 key 必须实现 <a href="https://javabetter.cn/collection/comparable-omparator.html">Comparable 接口</a>。<br>TreeMap 的底层是红黑树，红黑树是一种自平衡的二叉查找树，每个节点都大于其左子树中的任何节点，小于其右子节点树种的任何节点。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-35.png"><br>插入或者删除元素时通过旋转和着色来保持树的平衡。<br>查找的时候通过从根节点开始，利用二叉查找树的性质，逐步向左或者右子树递归查找，直到找到目标元素。</p><h3 id="29-TreeMap-和-HashMap-的区别"><a href="#29-TreeMap-和-HashMap-的区别" class="headerlink" title="29.TreeMap 和 HashMap 的区别"></a>29.TreeMap 和 HashMap 的区别</h3><p>①、HashMap 是基于数组+链表+红黑树实现的，put 元素的时候会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，然后将元素插入到数组中，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。<br>get 元素的时候同样会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，如果遇到链表或者红黑树，会通过 key 的 equals 方法来判断是否是要找的元素。<br>②、TreeMap 是基于红黑树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。<br>get 元素的时候会通过 key 的比较器来判断元素的位置，然后递归查找。<br>由于 HashMap 是基于哈希表实现的，所以在没有发生哈希冲突的情况下，HashMap 的查找效率是 O(1)。适用于查找操作比较频繁的场景。<br>而 TreeMap 是基于红黑树实现的，所以 TreeMap 的查找效率是 O(logn)。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="30-讲讲-HashSet-的底层实现？"><a href="#30-讲讲-HashSet-的底层实现？" class="headerlink" title="30.讲讲 HashSet 的底层实现？"></a>30.讲讲 HashSet 的底层实现？</h3><p>HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 ArrayList 和 LinkedList 可能更适合；如果我们需要存储键值对并根据键进行查找，那么 HashMap 可能更适合。<br>HashSet 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 HashSet 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashSet 对象</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;沉默&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;王二&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;陈清扬&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;沉默&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 HashSet 的元素个数</span></span><br><span class="line">System.out.println(<span class="string">&quot;HashSet size: &quot;</span> + set.size()); <span class="comment">// output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 HashSet</span></span><br><span class="line"><span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet 会自动去重，因为它是用 HashMap 实现的，HashMap 的键是唯一的（哈希值），相同键的值会覆盖掉原来的值，于是第二次 set.add(“沉默”) 的时候就覆盖了第一次的 set.add(“沉默”)。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-36.png"></p><h4 id="HashSet-和-ArrayList-的区别"><a href="#HashSet-和-ArrayList-的区别" class="headerlink" title="HashSet 和 ArrayList 的区别"></a>HashSet 和 ArrayList 的区别</h4><ul><li>ArrayList 是基于动态数组实现的，HashSet 是基于 HashMap 实现的。</li><li>ArrayList 允许重复元素和 null 值，可以有多个相同的元素；HashSet 保证每个元素唯一，不允许重复元素，基于元素的 hashCode 和 equals 方法来确定元素的唯一性。</li><li>ArrayList 保持元素的插入顺序，可以通过索引访问元素；HashSet 不保证元素的顺序，元素的存储顺序依赖于哈希算法，并且可能随着元素的添加或删除而改变。</li></ul><h4 id="HashSet-怎么判断元素重复，重复了是否-put"><a href="#HashSet-怎么判断元素重复，重复了是否-put" class="headerlink" title="HashSet 怎么判断元素重复，重复了是否 put"></a>HashSet 怎么判断元素重复，重复了是否 put</h4><p>HashSet 的 add 方法是通过调用 HashMap 的 put 方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 HashSet 判断元素重复的逻辑底层依然是 HashMap 的底层逻辑：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-13.jpeg"><br>HashMap 在插入元素时，通常需要三步：<br>第一步，通过 hash 方法计算 key 的哈希值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，数组进行第一次扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，HashSet 通过元素的哈希值来判断元素是否重复，如果重复了，会覆盖原来的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">八股文系列-Java集合框架</summary>
    
    
    
    <category term="八股文" scheme="http://ylcheng1789.github.io/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="Java集合" scheme="http://ylcheng1789.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>我的博客优化历程—自动初始化Gitalk</title>
    <link href="http://ylcheng1789.github.io/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/"/>
    <id>http://ylcheng1789.github.io/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/</id>
    <published>2024-08-11T13:01:24.000Z</published>
    <updated>2024-08-30T14:50:41.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>Gitalk。它是一个基于 GitHub Issue 和 Preact 开发的评论插件，除了 GitHub 账号之外不需要其他依赖，也不需要注册其他账号。</p><p>本文简要介绍一下如何在博客使用 Gitalk 评论区，并移除其他评论区的过程。对于具体的细节则不会做过多解释，主要展示步骤。</p><p>本文运行环境：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node:</span> <span class="string">v18.16.1</span></span><br><span class="line"><span class="attr">npm:</span> <span class="number">9.5</span><span class="number">.1</span></span><br><span class="line"><span class="attr">hexo:</span> <span class="number">6.3</span><span class="number">.0</span></span><br><span class="line"><span class="attr">hexo-cli:</span> <span class="number">4.3</span><span class="number">.1</span></span><br><span class="line"><span class="attr">NexT:</span> <span class="number">8.17</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h1 id="注册-GitHub-Application"><a href="#注册-GitHub-Application" class="headerlink" title="注册 GitHub Application"></a>注册 GitHub Application</h1><p>使用 Gitalk 的前提是：</p><ol><li>一个公共的 GitHub 存储库用于存储评论</li><li>创建一个 GitHub Application</li></ol><p>其中第一步当前已经满足，你的博客本身就是你的 GitHub 公共存储库，直接使用即可。当然你也可以新建一个存储库专门用于评论区。下面完成第二步。</p><p><a href="https://github.com/settings/applications/new">点击这里</a>申请 GitHub Application，网页标题为 “Register a new OAuth application”。需要填写如下内容：</p><ul><li>Application name：应用名称，我在这里填写了 <code>blog</code>。</li><li>Homepage URL：你的应用主页，这里填写博客主页地址。记住要携带 <code>https</code> 协议，如果你的博客是个人域名，请使用域名而不是 <code>*.github.io</code>。</li><li>Application description：你的应用描述，任何语言皆可。用你自己喜欢的文字描述。</li><li>Authorization callback URL：这里要填写当前使用插件页面的域名，与 Homepage URL 相同即可。</li></ul><p>点击 “Register application”，在新页面可以看到 Client ID，先记下。随后在 “Client secrets” 右侧点击 “Generate a new client secret”，并记下生成的 client secret。它只会显示一次，如果没有记下或者丢失了，就只好重建新的再删除旧的了。</p><p>以上准备工作完毕。如果你需要一个存储库专门用于评论区，直接在 GitHub <a href="https://github.com/new">新建 repository</a> 即可，这里就不赘述了。</p><p><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408302205615.png"></p><h1 id="配置-Gitalk"><a href="#配置-Gitalk" class="headerlink" title="配置 Gitalk"></a>配置 Gitalk</h1><p>在<code>_config.yml</code> 中进行配置：</p><p>_config.next.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comments System （评论系统）</span></span><br><span class="line"><span class="comment"># 评论配置</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">gitalk</span> <span class="comment"># Valine,Disqus</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gitalk</span></span><br><span class="line"><span class="comment"># https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>    <span class="comment">#是否开启Gitalk评论</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">Ov23liwBeMYsKAurz69S</span>                            <span class="comment">#生成的clientID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">***</span>    <span class="comment">#生成的clientSecret</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">***</span>    <span class="comment">#仓库名称</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">***</span>    <span class="comment">#github用户名</span></span><br><span class="line">  <span class="attr">admin:</span>  <span class="comment"># GitHub repo 的拥有者和合作者，这些人具有初始化 issue 的权限</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">***</span></span><br><span class="line">  <span class="attr">distractionFreeMode:</span> <span class="literal">true</span> <span class="comment">#是否启用类似FB的阴影遮罩</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="string">&#x27;gitalk&#x27;</span></span><br></pre></td></tr></table></figure><p>如果你之前有其他的评论区，记得取消掉。具体方法就是查看附近的评论区设置，如果有 <code>enable: true</code> 要改为 <code>false</code>。</p><h1 id="评论区批量初始化"><a href="#评论区批量初始化" class="headerlink" title="评论区批量初始化"></a>评论区批量初始化</h1><p>现在部署之后应该可以看到 Gitalk 评论区，但是处于未初始化的状态，而且每一篇文章都是这样的。显示的文字如下：</p><p><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408302205616.png"></p><p>如果是全新的博客或许可以手动初始化，但是对于老博客来讲，这个成本有点高，因此需要批量初始化。本部分参考了<a href="https://blog.jijian.link/2020-01-10/hexo-gitalk-auto-init/">这篇文章</a>与<a href="https://www.toimc.com/hexo-usage-3/">这篇文章</a>，并做了一些修改与优化。</p><h1 id="申请-Personal-Access-Token"><a href="#申请-Personal-Access-Token" class="headerlink" title="申请 Personal Access Token"></a>申请 Personal Access Token</h1><p>因为 GitHub API 对接口请求有限制，OAuth 方式限制太低，不足以用于初始化评论区，因此需要 Personal Access Token 的方式来完成。在<a href="https://github.com/settings/tokens/new">这里</a>申请一个新的 Token，网页标题为 “New personal access token (classic)”。填写如下信息：</p><ul><li>Note：Token 的使用目的，例如 <code>hexo-blog-comments-init</code>。</li><li>Expiration：选择 “No expiration”，也就是无过期时间。</li><li>Select scopes：选择 Token 的权限。这里需要以下权限：<ul><li><code>repo:status</code></li><li><code>repo_deployment</code></li><li><code>public_repo</code></li></ul></li></ul><p>点击 “Generate token”，获取新的 Token。这里 Token 只会出现一次，请务必记下，否则又要重新创建了。</p><p><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408302205617.png"></p><h1 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h1><p>在项目根目录下运行命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i request xml-parser blueimp-md5 moment hexo-generator-sitemap md5 -S</span><br></pre></td></tr></table></figure><h1 id="配置-hexo-generator-sitemap"><a href="#配置-hexo-generator-sitemap" class="headerlink" title="配置 hexo-generator-sitemap"></a>配置 <code>hexo-generator-sitemap</code></h1><p>安装 <code>hexo-generator-sitemap</code>，随后在<code>_config.yml</code> 添加或修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">  <span class="attr">template:</span> <span class="string">sitemap-template.xml</span></span><br></pre></td></tr></table></figure><p>在项目根目录新建文件 <code>sitemap-template.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">urlset</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span></span><br><span class="line">  &#123;% for post in posts %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loc</span>&gt;</span>&#123;&#123; post.permalink | uriencode &#125;&#125;<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">    &#123;% if post.updated %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>&#123;&#123; post.updated.toISOString() &#125;&#125;<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    &#123;% elif post.date %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>&#123;&#123; post.date.toISOString() &#125;&#125;<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">date</span>&gt;</span>&#123;&#123; post.date &#125;&#125;<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; post.title + &#x27; | &#x27; + config.title &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;# nunjucks 模版语法 https://github.com/mozilla/nunjucks #&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>&#123;&#123; post.description | default(post.excerpt) | default(post.content) | default(config.description) | striptags | truncate(200, true, &#x27;&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">urlset</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后使用 <code>hexo clean &amp; hexo g</code> 可以看到生成了 <code>public/sitemap.xml</code>。</p><h1 id="添加自动初始化脚本"><a href="#添加自动初始化脚本" class="headerlink" title="添加自动初始化脚本"></a>添加自动初始化脚本</h1><p>新建文件 <code>source/_scripts/gitalk-auto-init.js</code>，并写入如下内容（注意 <code>config</code> 中的配置信息要符合你的博客）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> xmlParser = <span class="built_in">require</span>(<span class="string">&#x27;xml-parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment">// GitHub repository 所有者，可以是个人或者组织。对应Gitalk配置中的owner</span></span><br><span class="line">  <span class="attr">repo</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment">// 储存评论issue的github仓库名，仅需要仓库名字即可。对应 Gitalk配置中的repo</span></span><br><span class="line">  <span class="attr">token</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment">// 前面申请的 personal access token</span></span><br><span class="line">  <span class="attr">sitemap</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../../public/sitemap.xml&#x27;</span>), <span class="comment">// 自己站点的 sitemap 文件地址</span></span><br><span class="line">  <span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 是否启用缓存，启用缓存会将已经初始化的数据写入配置的 gitalkCacheFile 文件，下一次直接通过缓存文件判断</span></span><br><span class="line">  <span class="attr">gitalkCacheFile</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./gitalk-init-cache.json&#x27;</span>), <span class="comment">// 用于保存 gitalk 已经初始化的 id 列表</span></span><br><span class="line">  <span class="attr">gitalkErrorFile</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./gitalk-init-error.json&#x27;</span>), <span class="comment">// 用于保存 gitalk 初始化报错的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = <span class="string">&#x27;https://api.github.com/repos/&#x27;</span> + config.<span class="property">username</span> + <span class="string">&#x27;/&#x27;</span> + config.<span class="property">repo</span> + <span class="string">&#x27;/issues&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 读取 sitemap 文件</span></span><br><span class="line"><span class="comment">* 远程 sitemap 文件获取可参考 https://www.npmjs.com/package/sitemapper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sitemapXmlReader</span> = (<span class="params">file</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(file, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> sitemap = <span class="title function_">xmlParser</span>(data);</span><br><span class="line">    <span class="keyword">let</span> ret = [];</span><br><span class="line">    sitemap.<span class="property">root</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">url</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> loc = url.<span class="property">children</span>.<span class="title function_">find</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">name</span> === <span class="string">&#x27;loc&#x27;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (!loc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> title = url.<span class="property">children</span>.<span class="title function_">find</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">name</span> === <span class="string">&#x27;title&#x27;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> desc = url.<span class="property">children</span>.<span class="title function_">find</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">name</span> === <span class="string">&#x27;desc&#x27;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> date = url.<span class="property">children</span>.<span class="title function_">find</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">name</span> === <span class="string">&#x27;date&#x27;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      ret.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: loc.<span class="property">content</span>,</span><br><span class="line">        <span class="attr">title</span>: title.<span class="property">content</span>,</span><br><span class="line">        <span class="attr">desc</span>: desc.<span class="property">content</span>,</span><br><span class="line">        <span class="attr">date</span>: date.<span class="property">content</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 gitalk 使用的 id</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getGitalkId</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url: u,</span></span><br><span class="line"><span class="params">  date</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> link = url.<span class="title function_">parse</span>(u);</span><br><span class="line">  <span class="comment">// 链接不存在，不需要初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!link || !link.<span class="property">pathname</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!date) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">md5</span>(link.<span class="property">pathname</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过以请求判断是否已经初始化</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; gitalk 初始化的id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">[boolean, boolean]</span>&#125; 第一个值表示是否出错，第二个值 false 表示没初始化， true 表示已经初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getIsInitByRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;token &#x27;</span> + config.<span class="property">token</span>,</span><br><span class="line">      <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">url</span>: api + <span class="string">&#x27;?labels=&#x27;</span> + id + <span class="string">&#x27;,Gitalk&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">request</span>(options, <span class="keyword">function</span> (<span class="params">err, response, body</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>([err, <span class="literal">false</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">statusCode</span> != <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>([response, <span class="literal">false</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(body);</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>([<span class="literal">false</span>, <span class="literal">true</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>([<span class="literal">false</span>, <span class="literal">false</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过缓存判断是否已经初始化</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; gitalk 初始化的id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125; false 表示没初始化， true 表示已经初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> getIsInitByCache = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断缓存文件是否存在</span></span><br><span class="line">  <span class="keyword">let</span> gitalkCache = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    gitalkCache = <span class="built_in">require</span>(config.<span class="property">gitalkCacheFile</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!gitalkCache) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gitalkCache.<span class="title function_">find</span>(<span class="function">(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        id: itemId</span></span></span><br><span class="line"><span class="params"><span class="function">      &#125;</span>) =&gt;</span> (itemId === id))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据缓存，判断链接是否已经初始化</span></span><br><span class="line"><span class="comment">// 第一个值表示是否出错，第二个值 false 表示没初始化， true 表示已经初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">idIsInit</span> = <span class="keyword">async</span> (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!config.<span class="property">cache</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">getIsInitByRequest</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果通过缓存查询到的数据是未初始化，则再通过请求判断是否已经初始化，防止多次初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getIsInitByCache</span>(id) === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">getIsInitByRequest</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="literal">false</span>, <span class="literal">true</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">gitalkInit</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  id,</span></span><br><span class="line"><span class="params">  title,</span></span><br><span class="line"><span class="params">  desc</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//创建issue</span></span><br><span class="line">  <span class="keyword">const</span> reqBody = &#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>: title,</span><br><span class="line">    <span class="string">&#x27;labels&#x27;</span>: [id, <span class="string">&#x27;Gitalk&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;body&#x27;</span>: url + <span class="string">&#x27;\r\n\r\n&#x27;</span> + desc</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;token &#x27;</span> + config.<span class="property">token</span>,</span><br><span class="line">      <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">url</span>: api,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(reqBody),</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">request</span>(options, <span class="keyword">function</span> (<span class="params">err, response, body</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>([err, <span class="literal">false</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">statusCode</span> != <span class="number">201</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>([response, <span class="literal">false</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>([<span class="literal">false</span>, <span class="literal">true</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 写入内容</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; fileName 文件名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; content 内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">write</span> = <span class="keyword">async</span> (<span class="params">fileName, content, flag = <span class="string">&#x27;w+&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">open</span>(fileName, flag, <span class="keyword">function</span> (<span class="params">err, fd</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>([err, <span class="literal">false</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fs.<span class="title function_">writeFile</span>(fd, content, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>([err, <span class="literal">false</span>]);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fs.<span class="title function_">close</span>(fd, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>([err, <span class="literal">false</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_">resolve</span>([<span class="literal">false</span>, <span class="literal">true</span>]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">init</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urls = <span class="title function_">sitemapXmlReader</span>(config.<span class="property">sitemap</span>);</span><br><span class="line">  <span class="comment">// 报错的数据</span></span><br><span class="line">  <span class="keyword">const</span> errorData = [];</span><br><span class="line">  <span class="comment">// 已经初始化的数据</span></span><br><span class="line">  <span class="keyword">const</span> initializedData = [];</span><br><span class="line">  <span class="comment">// 成功初始化数据</span></span><br><span class="line">  <span class="keyword">const</span> successData = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      url,</span><br><span class="line">      date,</span><br><span class="line">      title,</span><br><span class="line">      desc</span><br><span class="line">    &#125; = item;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">getGitalkId</span>(&#123;</span><br><span class="line">      url,</span><br><span class="line">      date</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`id: 生成失败 [ <span class="subst">$&#123;id&#125;</span> ] `</span>);</span><br><span class="line">      errorData.<span class="title function_">push</span>(&#123;</span><br><span class="line">        ...item,</span><br><span class="line">        <span class="attr">info</span>: <span class="string">&#x27;id 生成失败&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [err, res] = <span class="keyword">await</span> <span class="title function_">idIsInit</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Error: 查询评论异常 [ <span class="subst">$&#123;title&#125;</span> ] , 信息：`</span>, err || <span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">      errorData.<span class="title function_">push</span>(&#123;</span><br><span class="line">        ...item,</span><br><span class="line">        <span class="attr">info</span>: <span class="string">&#x27;查询评论异常&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(`--- Gitalk 已经初始化 --- [ $&#123;title&#125; ] `);</span></span><br><span class="line">      initializedData.<span class="title function_">push</span>(&#123;</span><br><span class="line">        id,</span><br><span class="line">        url,</span><br><span class="line">        title,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Gitalk 初始化开始... [ <span class="subst">$&#123;title&#125;</span> ] `</span>);</span><br><span class="line">    <span class="keyword">const</span> [e, r] = <span class="keyword">await</span> <span class="title function_">gitalkInit</span>(&#123;</span><br><span class="line">      id,</span><br><span class="line">      url,</span><br><span class="line">      title,</span><br><span class="line">      desc</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (e || !r) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Error: Gitalk 初始化异常 [ <span class="subst">$&#123;title&#125;</span> ] , 信息：`</span>, e || <span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">      errorData.<span class="title function_">push</span>(&#123;</span><br><span class="line">        ...item,</span><br><span class="line">        <span class="attr">info</span>: <span class="string">&#x27;初始化异常&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    successData.<span class="title function_">push</span>(&#123;</span><br><span class="line">      id,</span><br><span class="line">      url,</span><br><span class="line">      title,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Gitalk 初始化成功! [ <span class="subst">$&#123;title&#125;</span> ] - <span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 空输出，用于换行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------- 运行结果 ---------&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 空输出，用于换行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (errorData.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`报错数据： <span class="subst">$&#123;errorData.length&#125;</span> 条。参考文件 <span class="subst">$&#123;config.gitalkErrorFile&#125;</span>。`</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">write</span>(config.<span class="property">gitalkErrorFile</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(errorData, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`本次成功： <span class="subst">$&#123;successData.length&#125;</span> 条。`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入缓存</span></span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">cache</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`写入缓存： <span class="subst">$&#123;(initializedData.length + successData.length)&#125;</span> 条，已初始化 <span class="subst">$&#123;initializedData.length&#125;</span> 条，本次成功： <span class="subst">$&#123;successData.length&#125;</span> 条。参考文件 <span class="subst">$&#123;config.gitalkCacheFile&#125;</span>。`</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">write</span>(config.<span class="property">gitalkCacheFile</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(initializedData.<span class="title function_">concat</span>(successData), <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`已初始化： <span class="subst">$&#123;initializedData.length&#125;</span> 条。`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>随后在 <code>package.json</code> 新增：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate &amp;&amp; node source/_scripts/gitalk-auto-init.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;talk&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node source/_scripts/gitalk-auto-init.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h1 id="本地运行测试"><a href="#本地运行测试" class="headerlink" title="本地运行测试"></a>本地运行测试</h1><p>执行 <code>hexo clean; npm run build; hexo s</code> 进行本地部署。这里使用 <code>npm run build</code> 的原因是上面在 <code>package.json</code> 中进行了定义，使它兼具了 <code>hexo g</code> 与 Gitalk 批量脚本的功能。也可以不使用 <code>npm run build</code> 而单独执行这两条命令。</p><p>日志中应该出现如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gitalk 初始化开始... [ xxx | xxx ]</span><br><span class="line">Gitalk 初始化成功! [ xxx | xxx ] - xxxxxxxxx</span><br></pre></td></tr></table></figure><p>这说明 Issue 评论区正在建立中。你可以去实际的评论区 GitHub 仓库里查看 Issues 是否存在来验证是否成功。</p><h1 id="不为某些文章生成评论区"><a href="#不为某些文章生成评论区" class="headerlink" title="不为某些文章生成评论区"></a>不为某些文章生成评论区</h1><p>在本地测试中发现，无论文章是否具有 <code>comments: false</code>，都生成了对应的评论区 Issue（虽然评论区依旧是关闭的，但是 Issue 存在）。如果不想看到此类行为，则需要做一些修改。</p><p>首先修改 <code>sitemap-template.xml</code>，加入如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">urlset</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span></span><br><span class="line">  &#123;% for post in posts %&#125;</span><br><span class="line">+ &#123;% if post.comments %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loc</span>&gt;</span>&#123;&#123; post.permalink | uriencode &#125;&#125;<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">    &#123;% if post.updated %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>&#123;&#123; post.updated.toISOString() &#125;&#125;<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    &#123;% elif post.date %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>&#123;&#123; post.date.toISOString() &#125;&#125;<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">date</span>&gt;</span>&#123;&#123; post.date &#125;&#125;<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; post.title + &#x27; | &#x27; + config.title &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;# nunjucks 模版语法 https://github.com/mozilla/nunjucks #&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>&#123;&#123; post.description | default(post.excerpt) | default(post.content) | default(config.description) | striptags | truncate(200, true, &#x27;&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">+ &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">urlset</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是为了在 <code>public/sitemap.xml</code> 生成时检测评论区是否开启，如果不开启，则直接不生成对应内容。</p><p>随后重新部署验证。可能需要清理一下已经存在的 Issues。</p><h1 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h1><p>最后，修改工作流的如下内容（首先需要配置博客的自动部署，详情可以参考 <a href="/20211125-hexo-blog-guide/" title="Hexo静态博客指南：本站是如何诞生的（2021年版）">Hexo 静态博客指南：本站是如何诞生的（2021 年版）</a>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    # Deploy</span><br><span class="line">    - name: Deploy hexo</span><br><span class="line">      run: |</span><br><span class="line">        hexo clean</span><br><span class="line">-       hexo generate</span><br><span class="line">+       npm run build</span><br><span class="line">        hexo deploy</span><br></pre></td></tr></table></figure><p>随后提交代码出发自动部署即可。</p><h1 id="Secondary-rate-limits-受限问题"><a href="#Secondary-rate-limits-受限问题" class="headerlink" title="Secondary rate limits 受限问题"></a>Secondary rate limits 受限问题</h1><p>虽然 Personal Access Token 有每日 5000 次的限制，足够使用，但仍然可能出发 GitHub 的 Secondary rate limits：</p><p>这会让远程部署报错。你可以尝试更改请求间隔来规避这个问题。示例更改代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getIsInitByRequest</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;token &#x27;</span> + config.<span class="property">token</span>,</span><br><span class="line">      <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">url</span>: api + <span class="string">&#x27;?labels=&#x27;</span> + id + <span class="string">&#x27;,Gitalk&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 增加等待时间3000ms</span></span><br><span class="line">      <span class="title function_">request</span>(options, <span class="keyword">function</span> (<span class="params">err, response, body</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">resolve</span>([err, <span class="literal">false</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">statusCode</span> != <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">resolve</span>([response, <span class="literal">false</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(body);</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">resolve</span>([<span class="literal">false</span>, <span class="literal">true</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>([<span class="literal">false</span>, <span class="literal">false</span>]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">3000</span>); <span class="comment">// 3000ms</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">gitalkInit</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  id,</span></span><br><span class="line"><span class="params">  title,</span></span><br><span class="line"><span class="params">  desc</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建issue</span></span><br><span class="line">  <span class="keyword">const</span> reqBody = &#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>: title,</span><br><span class="line">    <span class="string">&#x27;labels&#x27;</span>: [id, <span class="string">&#x27;Gitalk&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;body&#x27;</span>: url + <span class="string">&#x27;\r\n\r\n&#x27;</span> + desc</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;token &#x27;</span> + config.<span class="property">token</span>,</span><br><span class="line">      <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">url</span>: api,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(reqBody),</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 增加等待时间3000ms</span></span><br><span class="line">      <span class="title function_">request</span>(options, <span class="keyword">function</span> (<span class="params">err, response, body</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">resolve</span>([err, <span class="literal">false</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">statusCode</span> != <span class="number">201</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">resolve</span>([response, <span class="literal">false</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>([<span class="literal">false</span>, <span class="literal">true</span>]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">3000</span>); <span class="comment">// 3000ms</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面省略</span></span><br></pre></td></tr></table></figure><p>之后进行重新部署测试。这可能会拉长部署时间，但只要生成了本地缓存文件就可以加速。</p><h1 id="关于权限与安全问题的讨论"><a href="#关于权限与安全问题的讨论" class="headerlink" title="关于权限与安全问题的讨论"></a>关于权限与安全问题的讨论</h1><p>对 Gitalk 这类基于 GitHub Issues 的评论系统，权限与安全是绕不开的话题。该系统面临的主要问题如下：</p><ol><li>对作者：<code>client_id</code> 与 <code>client_secret</code> 直接暴露在前端，可能会有安全隐患；</li><li>对评论者：首次使用时需要授权 GitHub 账户，而该授权竟然要求所有公开仓库的读写权限，权限过于夸张，如果有恶意网站，甚至可以删光所有公共仓库。</li></ol><p>关于第一点，<a href="https://carl-zk.github.io/blog/2020/03/03/gitalk-%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/">这里</a>有详细讨论。也有 <a href="https://github.com/gitalk/gitalk/issues/150">Issue</a> 针对这个问题做了说明，简要概括如下：</p><ol><li>虽然 Gitalk 使用了第三方代理服务器来获取 <code>access_token</code> 属于违反 OAuth2.0 规范，但是作为一个评论系统来说安全性可以不必担心，因为 GitHub 已经对 <code>access_token</code> 做了只读限制；</li><li>获取或修改 GitHub 用户数据，需要 <code>token</code>，为了拿到 <code>token</code>，除了需要 OAuth App 的 <code>client_id</code> 和 <code>client_secret</code> 外，还需要一个 Authorization Code；</li><li>这个 <code>code</code> 是 GitHub 登录授权完成时，在跳转回 <code>redirect_uri</code> 的查询参数拿到的， <code>redirect_uri</code> 必须是在 OAuth App 配置的 callback URL 域名下；</li><li>这样即使别人用了你的 <code>client_id</code> 和 <code>client_secret</code> ，跳转之后也拿不到 code，所以，有 <code>client_id</code> 和 <code>client_secret</code> 也做不了什么。</li></ol><p>虽然如此，而且作为静态博客引擎，这样做是没有办法的办法，但是暴露 <code>client_id</code> 与 <code>client_secret</code> 终究是不太推荐的做法。</p><p>对于第二点，讨论更为广泛，<a href="https://github.com/gitalk/gitalk/issues/95">Issue</a> 与<a href="https://v2ex.com/t/535608">帖子</a>都有涉及。为什么需要这么高的权限，简而言之就是 GitHub OAuth 权限设计目前只能做到这样的粒度。Gitalk 源码中，开发者没有保存 <code>access_token</code>，只是将它保存到了 localStorage 中。但是可能会存在恶意的攻击者来扩展这一点。这对于评论者而言是一种伤害，如此之大的权限可能会降低评论者评论的意愿，毕竟网站有无恶意是很难判断的。目前的解决方案有两种：</p><ol><li>点击评论区的统计数字，可以跳转到相应的 GitHub Issue 页面，在页面评论可以绕过验证；</li><li>采用更安全的评论系统，例如 <a href="https://utteranc.es/">utterances</a> 这类 App，它的权限仅限于某个仓库，可以一定程度上降低破坏性。</li></ol><p>那么本博客该如何做？本着精益求精的原则，估计是又要迁移到 utterances 上了…… 刚刚迁移评论系统还没多久，就发现了这个问题。生命在于折腾，utterances 迁移会后续写文章处理。</p>]]></content>
    
    
    <summary type="html">我的博客优化历程—自动初始化Gitalk</summary>
    
    
    
    <category term="Bufferfly博客" scheme="http://ylcheng1789.github.io/categories/Bufferfly%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Bufferfly博客" scheme="http://ylcheng1789.github.io/tags/Bufferfly%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—10.服务端客户端的实现及其通信规则</title>
    <link href="http://ylcheng1789.github.io/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/"/>
    <id>http://ylcheng1789.github.io/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/</id>
    <published>2024-06-11T13:01:24.000Z</published>
    <updated>2024-08-30T14:53:22.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>NYDB 被设计为 C&#x2F;S 结构，类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果。</p><h2 id="C-S-通信"><a href="#C-S-通信" class="headerlink" title="C&#x2F;S 通信"></a>C&#x2F;S 通信</h2><p>MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。当然如果嫌麻烦的话，其实直接用明文也不是不可以。</p><p>传输的最基本结构，是 Package：</p><pre><code>public class Package &#123;    byte[] data;    Exception err;&#125;</code></pre><p>每个 Package 在发送前，由 Encoder 编码为字节数组，在对方收到后同样会由 Encoder 解码成 Package 对象。编码和解码的规则如下：</p><pre><code>[Flag][data]</code></pre><p>若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；如果 flag 为 1，表示发送的是错误，data 是 Exception.getMessage() 的错误提示信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] encode(Package pkg) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pkg.getErr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">err</span> <span class="operator">=</span> pkg.getErr();</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Intern server error!&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(err.getMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                msg = err.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>&#125;, msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>&#125;, pkg.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">decode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Package</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, <span class="number">1</span>, data.length))));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> Error.InvalidPkgDataException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码之后的信息会通过 Transporter 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。这样在发送和接收数据时，就可以很简单地使用 BufferedReader 和 Writer 来直接按行读写了。</p><pre><code>public class Transporter &#123;    private Socket socket;    private BufferedReader reader;    private BufferedWriter writer;    public Transporter(Socket socket) throws IOException &#123;        this.socket = socket;        this.reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));    &#125;    public void send(byte[] data) throws Exception &#123;        String raw = hexEncode(data);        writer.write(raw);        writer.flush();    &#125;    public byte[] receive() throws Exception &#123;        String line = reader.readLine();        if(line == null) &#123;            close();        &#125;        return hexDecode(line);    &#125;    public void close() throws IOException &#123;        writer.close();        reader.close();        socket.close();    &#125;    private String hexEncode(byte[] buf) &#123;        return Hex.encodeHexString(buf, true)+&quot;\n&quot;;    &#125;    private byte[] hexDecode(String buf) throws DecoderException &#123;        return Hex.decodeHex(buf);    &#125;&#125;</code></pre><p>Packager 则是 Encoder 和 Transporter 的结合体，直接对外提供 send 和 receive 方法：</p><pre><code>public class Packager &#123;    private Transporter transpoter;    private Encoder encoder;    public Packager(Transporter transpoter, Encoder encoder) &#123;        this.transpoter = transpoter;        this.encoder = encoder;    &#125;    public void send(Package pkg) throws Exception &#123;        byte[] data = encoder.encode(pkg);        transpoter.send(data);    &#125;    public Package receive() throws Exception &#123;        byte[] data = transpoter.receive();        return encoder.decode(data);    &#125;    public void close() throws Exception &#123;        transpoter.close();    &#125;&#125;</code></pre><h2 id="Server-和-Client-的实现"><a href="#Server-和-Client-的实现" class="headerlink" title="Server 和 Client 的实现"></a>Server 和 Client 的实现</h2><p>Server 和 Client，偷懒直接使用了 Java 的 socket。</p><p>Server 启动一个 ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理。这部分应该直接背板了。</p><p>HandleSocket 类实现了 Runnable 接口，在建立连接后初始化 Packager，随后就循环接收来自客户端的数据并处理：</p><pre><code>Packager packager = null;try &#123;    Transporter t = new Transporter(socket);    Encoder e = new Encoder();    packager = new Packager(t, e);&#125; catch(IOException e) &#123;    e.printStackTrace();    try &#123;        socket.close();    &#125; catch (IOException e1) &#123;        e1.printStackTrace();    &#125;    return;&#125;Executor exe = new Executor(tbm);while(true) &#123;    Package pkg = null;    try &#123;        pkg = packager.receive();    &#125; catch(Exception e) &#123;        break;    &#125;    byte[] sql = pkg.getData();    byte[] result = null;    Exception e = null;    try &#123;        result = exe.execute(sql);    &#125; catch (Exception e1) &#123;        e = e1;        e.printStackTrace();    &#125;    pkg = new Package(result, e);    try &#123;        packager.send(pkg);    &#125; catch (Exception e1) &#123;        e1.printStackTrace();        break;    &#125;&#125;</code></pre><p>处理的核心是 Executor 类，Executor 调用 Parser 获取到对应语句的结构化信息对象，并根据对象的类型，调用 TBM 的不同方法进行处理。具体不再赘述。</p><p>top.guoziyang.mydb.backend.Launcher 类，则是服务器的启动入口。这个类解析了命令行参数。很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。</p><pre><code>private static void createDB(String path) &#123;    TransactionManager tm = TransactionManager.create(path);    DataManager dm = DataManager.create(path, DEFALUT_MEM, tm);    VersionManager vm = new VersionManagerImpl(tm, dm);    TableManager.create(path, vm, dm);    tm.close();    dm.close();&#125;private static void openDB(String path, long mem) &#123;    TransactionManager tm = TransactionManager.open(path);    DataManager dm = DataManager.open(path, mem, tm);    VersionManager vm = new VersionManagerImpl(tm, dm);    TableManager tbm = TableManager.open(path, vm, dm);    new Server(port, tbm).start();&#125;</code></pre><p>客户端连接服务器的过程，也是背板。客户端有一个简单的 Shell，实际上只是读入用户的输入，并调用 Client.execute()。</p><pre><code>public byte[] execute(byte[] stat) throws Exception &#123;    Package pkg = new Package(stat, null);    Package resPkg = rt.roundTrip(pkg);    if(resPkg.getErr() != null) &#123;        throw resPkg.getErr();    &#125;    return resPkg.getData();&#125;</code></pre><p>RoundTripper 类实际上实现了单次收发动作：</p><pre><code>public Package roundTrip(Package pkg) throws Exception &#123;    packager.send(pkg);    return packager.receive();&#125;</code></pre><p>最后附上客户端的启动入口，很简单，把 Shell run 起来即可：</p><pre><code>public class Launcher &#123;    public static void main(String[] args) throws UnknownHostException, IOException &#123;        Socket socket = new Socket(&quot;127.0.0.1&quot;, 9999);        Encoder e = new Encoder();        Transporter t = new Transporter(socket);        Packager packager = new Packager(t, e);        Client client = new Client(packager);        Shell shell = new Shell(client);        shell.run();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">一起写个数据库—10.服务端客户端的实现及其通信规则</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—9.字段与表管理</title>
    <link href="http://ylcheng1789.github.io/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://ylcheng1789.github.io/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/</id>
    <published>2024-06-10T13:01:24.000Z</published>
    <updated>2024-08-30T14:53:10.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章概述 TBM，即表管理器的实现。TBM 实现了对字段结构和表结构的管理。同时简要介绍 MYDB 使用的类 SQL 语句的解析。</p><h2 id="SQL-解析器"><a href="#SQL-解析器" class="headerlink" title="SQL 解析器"></a>SQL 解析器</h2><p>Parser 实现了对类 SQL 语句的结构化解析，将语句中包含的信息封装为对应语句的类，这些类可见 top.guoziyang.mydb.backend.parser.statement 包。</p><p>MYDB 实现的 SQL 语句语法如下：</p><pre><code>&lt;begin statement&gt;    begin [isolation level (read committed|repeatable read)]        begin isolation level read committed&lt;commit statement&gt;    commit&lt;abort statement&gt;    abort&lt;create statement&gt;    create table &lt;table name&gt;    &lt;field name&gt; &lt;field type&gt;    &lt;field name&gt; &lt;field type&gt;    ...    &lt;field name&gt; &lt;field type&gt;    [(index &lt;field name list&gt;)]        create table students        id int32,        name string,        age int32,        (index id name)&lt;drop statement&gt;    drop table &lt;table name&gt;        drop table students&lt;select statement&gt;    select (*|&lt;field name list&gt;) from &lt;table name&gt; [&lt;where statement&gt;]        select * from student where id = 1        select name from student where id &gt; 1 and id &lt; 4        select name, age, id from student where id = 12&lt;insert statement&gt;    insert into &lt;table name&gt; values &lt;value list&gt;        insert into student values 5 &quot;Zhang Yuanjia&quot; 22&lt;delete statement&gt;    delete from &lt;table name&gt; &lt;where statement&gt;        delete from student where name = &quot;Zhang Yuanjia&quot;&lt;update statement&gt;    update &lt;table name&gt; set &lt;field name&gt;=&lt;value&gt; [&lt;where statement&gt;]        update student set name = &quot;ZYJ&quot; where id = 5&lt;where statement&gt;    where &lt;field name&gt; (&gt;|&lt;|=) &lt;value&gt; [(and|or) &lt;field name&gt; (&gt;|&lt;|=) &lt;value&gt;]        where age &gt; 10 or age &lt; 3&lt;field name&gt; &lt;table name&gt;    [a-zA-Z][a-zA-Z0-9_]*&lt;field type&gt;    int32 int64 string&lt;value&gt;    .*</code></pre><p>parser 包的 Tokenizer 类，对语句进行逐字节解析，根据空白符或者上述词法规则，将语句切割成多个 token。对外提供了 <code>peek()</code>、<code>pop()</code> 方法方便取出 Token 进行解析。切割的实现不赘述。</p><p>Parser 类则直接对外提供了 <code>Parse(byte[] statement)</code> 方法，核心就是一个调用 Tokenizer 类分割 Token，并根据词法规则包装成具体的 Statement 类并返回。解析过程很简单，仅仅是根据第一个 Token 来区分语句类型，并分别处理，不再赘述。</p><p>虽然根据编译原理，词法分析应当写一个自动机去做的，但是又不是不能用</p><h2 id="字段与表管理"><a href="#字段与表管理" class="headerlink" title="字段与表管理"></a>字段与表管理</h2><p>注意，这里的字段与表管理，不是管理各个条目中不同的字段的数值等信息，而是管理表和字段的结构数据，例如表名、表字段信息和字段索引等。</p><p>由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p><pre><code>[FieldName][TypeName][IndexUid]</code></pre><p>这里 FieldName 和 TypeName，以及后面的表明，存储的都是字节形式的字符串。这里规定一个字符串的存储方式，以明确其存储边界。</p><pre><code>[StringLength][StringData]</code></pre><p>TypeName 为字段的类型，限定为 int32、int64 和 string 类型。如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根，否则该字段为 0。</p><p>根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p><pre><code>public static Field loadField(Table tb, long uid) &#123;    byte[] raw = null;    try &#123;        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);    &#125; catch (Exception e) &#123;        Panic.panic(e);    &#125;    assert raw != null;    return new Field(uid, tb).parseSelf(raw);&#125;private Field parseSelf(byte[] raw) &#123;    int position = 0;    ParseStringRes res = Parser.parseString(raw);    fieldName = res.str;    position += res.next;    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));    fieldType = res.str;    position += res.next;    this.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+8));    if(index != 0) &#123;        try &#123;            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);        &#125; catch(Exception e) &#123;            Panic.panic(e);        &#125;    &#125;    return this;&#125;</code></pre><p>创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p><pre><code>private void persistSelf(long xid) throws Exception &#123;    byte[] nameRaw = Parser.string2Byte(fieldName);    byte[] typeRaw = Parser.string2Byte(fieldType);    byte[] indexRaw = Parser.long2Byte(index);    this.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));&#125;</code></pre><p>一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p><pre><code>[TableName][NextTable][Field1Uid][Field2Uid]...[FieldNUid]</code></pre><p>这里由于每个 Entry 中的数据，字节数是确定的，于是无需保存字段的个数。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。</p><p>对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where 只支持两个条件的与和或。例如有条件的 Delete，计算 Where，最终就需要获取到条件范围内所有的 UID。MYDB 只支持已索引字段作为 Where 的条件。计算 Where 的范围，具体可以查看 Table 的 <code>parseWhere()</code> 和 <code>calWhere()</code> 方法，以及 Field 类的 <code>calExp()</code> 方法。</p><p>由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须保存一个链表的头节点，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。</p><p>MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期通过操作系统重命名文件的原子性，来保证操作的原子性。</p><pre><code>public void update(byte[] data) &#123;    File tmp = new File(path + BOOTER_TMP_SUFFIX);    try &#123;        tmp.createNewFile();    &#125; catch (Exception e) &#123;        Panic.panic(e);    &#125;    if(!tmp.canRead() || !tmp.canWrite()) &#123;        Panic.panic(Error.FileCannotRWException);    &#125;    try(FileOutputStream out = new FileOutputStream(tmp)) &#123;        out.write(data);        out.flush();    &#125; catch(IOException e) &#123;        Panic.panic(e);    &#125;    try &#123;        Files.move(tmp.toPath(), new File(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);    &#125; catch(IOException e) &#123;        Panic.panic(e);    &#125;    file = new File(path+BOOTER_SUFFIX);    if(!file.canRead() || !file.canWrite()) &#123;        Panic.panic(Error.FileCannotRWException);    &#125;&#125;</code></pre><h2 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h2><p>TBM 层对外提供服务的是 TableManager 接口，如下：</p><pre><code>public interface TableManager &#123;    BeginRes begin(Begin begin);    byte[] commit(long xid) throws Exception;    byte[] abort(long xid);    byte[] show(long xid);    byte[] create(long xid, Create create) throws Exception;    byte[] insert(long xid, Insert insert) throws Exception;    byte[] read(long xid, Select select) throws Exception;    byte[] update(long xid, Update update) throws Exception;    byte[] delete(long xid, Delete delete) throws Exception;&#125;</code></pre><p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 C&#x2F;S 结构），这些方法直接返回执行的结果，例如错误信息或者结果信息的字节数组（可读）。</p><p>各个方法的具体实现很简单，不再赘述，无非是调用 VM 的相关方法。唯一值得注意的一个小点是，在创建新表时，采用的时头插法，所以每次创建表都需要更新 Booter 文件。</p>]]></content>
    
    
    <summary type="html">一起写个数据库—9.字段与表管理</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—8.索引管理器</title>
    <link href="http://ylcheng1789.github.io/2024/06/09/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%948.%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://ylcheng1789.github.io/2024/06/09/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%948.%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2024-06-09T13:01:24.000Z</published>
    <updated>2024-08-30T14:53:00.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的非聚簇索引。目前 MYDB 只支持基于索引查找数据，不支持全表扫描。感兴趣的同学可以自行实现。</p><p>在依赖关系图中可以看到，IM 直接基于 DM，而没有基于 VM。索引的数据被直接插入数据库文件中，而不需要经过版本管理。</p><p>本节不赘述 B+ 树算法，更多描述实现。</p><h2 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h2><p>二叉树由一个个 Node 组成，每个 Node 都存储在一条 DataItem 中。结构如下：</p><pre><code>[LeafFlag][KeyNumber][SiblingUid][Son0][Key0][Son1][Key1]...[SonN][KeyN]</code></pre><p>其中 LeafFlag 标记了该节点是否是个叶子节点；KeyNumber 为该节点中 key 的个数；SiblingUid 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（SonN）和 KeyN。最后的一个 KeyN 始终为 MAX_VALUE，以此方便查找。</p><p>Node 类持有了其 B+ 树结构的引用，DataItem 的引用和 SubArray 的引用，用于方便快速修改数据和释放数据。</p><pre><code>public class Node &#123;    BPlusTree tree;    DataItem dataItem;    SubArray raw;    long uid;    ...&#125;</code></pre><p>于是生成一个根节点的数据可以写成如下：</p><pre><code>static byte[] newRootRaw(long left, long right, long key)  &#123;    SubArray raw = new SubArray(new byte[NODE_SIZE], 0, NODE_SIZE);    setRawIsLeaf(raw, false);    setRawNoKeys(raw, 2);    setRawSibling(raw, 0);    setRawKthSon(raw, left, 0);    setRawKthKey(raw, key, 0);    setRawKthSon(raw, right, 1);    setRawKthKey(raw, Long.MAX_VALUE, 1);    return raw.raw;&#125;</code></pre><p>该根节点的初始两个子节点为 left 和 right, 初始键值为 key。</p><p>类似的，生成一个空的根节点数据：</p><pre><code>static byte[] newNilRootRaw()  &#123;    SubArray raw = new SubArray(new byte[NODE_SIZE], 0, NODE_SIZE);    setRawIsLeaf(raw, true);    setRawNoKeys(raw, 0);    setRawSibling(raw, 0);    return raw.raw;&#125;</code></pre><p>Node 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 searchNext 方法和 leafSearchRange 方法。</p><p>searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</p><pre><code>public SearchNextRes searchNext(long key) &#123;    dataItem.rLock();    try &#123;        SearchNextRes res = new SearchNextRes();        int noKeys = getRawNoKeys(raw);        for(int i = 0; i &lt; noKeys; i ++) &#123;            long ik = getRawKthKey(raw, i);            if(key &lt; ik) &#123;                res.uid = getRawKthSon(raw, i);                res.siblingUid = 0;                return res;            &#125;        &#125;        res.uid = 0;        res.siblingUid = getRawSibling(raw);        return res;    &#125; finally &#123;        dataItem.rUnLock();    &#125;&#125;</code></pre><p>leafSearchRange 方法在当前节点进行范围查找，范围是 [leftKey, rightKey]，这里约定如果 rightKey 大于等于该节点的最大的 key, 则还同时返回兄弟节点的 UID，方便继续搜索下一个节点。</p><pre><code>public LeafSearchRangeRes leafSearchRange(long leftKey, long rightKey) &#123;    dataItem.rLock();    try &#123;        int noKeys = getRawNoKeys(raw);        int kth = 0;        while(kth &lt; noKeys) &#123;            long ik = getRawKthKey(raw, kth);            if(ik &gt;= leftKey) &#123;                break;            &#125;            kth ++;        &#125;        List&lt;Long&gt; uids = new ArrayList&lt;&gt;();        while(kth &lt; noKeys) &#123;            long ik = getRawKthKey(raw, kth);            if(ik &lt;= rightKey) &#123;                uids.add(getRawKthSon(raw, kth));                kth ++;            &#125; else &#123;                break;            &#125;        &#125;        long siblingUid = 0;        if(kth == noKeys) &#123;            siblingUid = getRawSibling(raw);        &#125;        LeafSearchRangeRes res = new LeafSearchRangeRes();        res.uids = uids;        res.siblingUid = siblingUid;        return res;    &#125; finally &#123;        dataItem.rUnLock();    &#125;&#125;</code></pre><p>由于 B+ 树在插入删除时，会动态调整，根节点不是固定节点，于是设置一个 bootDataItem，该 DataItem 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 SUPER_XID。</p><pre><code>public class BPlusTree &#123;    DataItem bootDataItem;    private long rootUid() &#123;        bootLock.lock();        try &#123;            SubArray sa = bootDataItem.data();            return Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+8));        &#125; finally &#123;            bootLock.unlock();        &#125;    &#125;    private void updateRootUid(long left, long right, long rightKey) throws Exception &#123;        bootLock.lock();        try &#123;            byte[] rootRaw = Node.newRootRaw(left, right, rightKey);            long newRootUid = dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);            bootDataItem.before();            SubArray diRaw = bootDataItem.data();            System.arraycopy(Parser.long2Byte(newRootUid), 0, diRaw.raw, diRaw.start, 8);            bootDataItem.after(TransactionManagerImpl.SUPER_XID);        &#125; finally &#123;            bootLock.unlock();        &#125;    &#125;&#125;</code></pre><p>IM 对上层模块主要提供两种能力：插入索引和搜索节点。向 B+ 树插入节点和搜索节点的算法和实现，不再赘述。</p><p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 Entry，实际的操作是设置其 XMAX。如果不去删除对应索引的话，当后续再次尝试读取该 Entry 时，是可以通过索引寻找到的，但是由于设置了 XMAX，寻找不到合适的版本而返回一个找不到内容的错误。</p><h2 id="可能的错误与恢复"><a href="#可能的错误与恢复" class="headerlink" title="可能的错误与恢复"></a>可能的错误与恢复</h2><p>B+ 树在操作过程中，可能出现两种错误，分别是节点内部错误和节点间关系错误。</p><p>当节点内部错误发生时，即当 Ti 在对节点的数据进行更改时，MYDB 发生了崩溃。由于 IM 依赖于 DM，在数据库重启后，Ti 会被撤销（undo），对节点的错误影响会被消除。</p><p>如果出现了节点间错误，那么一定是下面这种情况：某次对 u 节点的插入操作创建了新节点 v, 此时 sibling(u)&#x3D;v，但是 v 却并没有被插入到父节点中。</p><pre><code>[parent]    |    v   [u] -&gt; [v]</code></pre><p>正确的状态应当如下：</p><pre><code>[ parent ] |      | v      v[u] -&gt; [v]</code></pre><p>这时，如果要对节点进行插入或者搜索操作，如果失败，就会继续迭代它的兄弟节点，最终还是可以找到 v 节点。唯一的缺点仅仅是，无法直接通过父节点找到 v 了，只能间接地通过 u 获取到 v。</p>]]></content>
    
    
    <summary type="html">一起写个数据库—8.索引管理器</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—7.死锁检测与VM的实现</title>
    <link href="http://ylcheng1789.github.io/2024/06/08/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%947.%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8EVM%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://ylcheng1789.github.io/2024/06/08/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%947.%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8EVM%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-06-08T13:01:24.000Z</published>
    <updated>2024-08-30T14:52:48.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节将收尾 VM 层，介绍一下 MVCC 可能导致的版本跳跃问题，以及 MYDB 如何避免 2PL 导致的死锁，并将其整合为 Version Manager。</p><h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>说到版本跳跃之前，顺便提一嘴，MVCC 的实现，使得 MYDB 在撤销或是回滚事务很简单：只需要将这个事务标记为 aborted 即可。根据前一章提到的可见性，每个事务都只能看到其他 committed 的事务所产生的数据，一个 aborted 事务产生的数据，就不会对其他事务产生任何影响了，也就相当于，这个事务不曾存在过。</p><p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p><pre><code>T1 beginT2 beginR1(X) // T1读取x0R2(X) // T2读取x0U1(X) // T1将X更新到x1T1 commitU2(X) // T2将X更新到x2T2 commit</code></pre><p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。</p><p>读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。解决版本跳跃的思路也很简单：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚。</p><p>上一节中就总结了，Ti 不可见的 Tj，有两种情况：</p><ol><li>XID(Tj) &gt; XID(Ti)</li><li>Tj in SP(Ti)</li></ol><p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并检查该最新版本的创建者对当前事务是否可见：</p><pre><code>public static boolean isVersionSkip(TransactionManager tm, Transaction t, Entry e) &#123;    long xmax = e.getXmax();    if(t.level == 0) &#123;        return false;    &#125; else &#123;        return tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid || t.isInSnapshot(xmax));  &#125;&#125;</code></pre><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。</p><p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p><pre><code>public class LockTable &#123;        private Map&lt;Long, List&lt;Long&gt;&gt; x2u;  // 某个XID已经获得的资源的UID列表    private Map&lt;Long, Long&gt; u2x;        // UID被某个XID持有    private Map&lt;Long, List&lt;Long&gt;&gt; wait; // 正在等待UID的XID列表    private Map&lt;Long, Lock&gt; waitLock;   // 正在等待资源的XID的锁    private Map&lt;Long, Long&gt; waitU;      // XID正在等待的UID    private Lock lock;    ...&#125;</code></pre><p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p><pre><code>// 不需要等待则返回null，否则返回锁对象// 会造成死锁则抛出异常public Lock add(long xid, long uid) throws Exception &#123;    lock.lock();    try &#123;        if(isInList(x2u, xid, uid)) &#123;            return null;        &#125;        if(!u2x.containsKey(uid)) &#123;            u2x.put(uid, xid);            putIntoList(x2u, xid, uid);            return null;        &#125;        waitU.put(xid, uid);        putIntoList(wait, xid, uid);        if(hasDeadLock()) &#123;            waitU.remove(xid);            removeFromList(wait, uid, xid);            throw Error.DeadlockException;        &#125;        Lock l = new ReentrantLock();        l.lock();        waitLock.put(xid, l);        return l;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>调用 add，如果需要等待的话，会返回一个上了锁的 Lock 对象。调用方在获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的，例如：</p><pre><code>Lock l = lt.add(xid, uid);if(l != null) &#123;    l.lock();   // 阻塞在这一步    l.unlock();&#125;</code></pre><p>查找图中是否有环的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p><p>实现很简单：</p><pre><code>private boolean hasDeadLock() &#123;    xidStamp = new HashMap&lt;&gt;();    stamp = 1;    for(long xid : x2u.keySet()) &#123;        Integer s = xidStamp.get(xid);        if(s != null &amp;&amp; s &gt; 0) &#123;            continue;        &#125;        stamp ++;        if(dfs(xid)) &#123;            return true;        &#125;    &#125;    return false;&#125;private boolean dfs(long xid) &#123;    Integer stp = xidStamp.get(xid);    if(stp != null &amp;&amp; stp == stamp) &#123;        return true;    &#125;    if(stp != null &amp;&amp; stp &lt; stamp) &#123;        return false;    &#125;    xidStamp.put(xid, stamp);    Long uid = waitU.get(xid);    if(uid == null) return false;    Long x = u2x.get(uid);    assert x != null;    return dfs(x);&#125;</code></pre><p>在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p><pre><code>public void remove(long xid) &#123;    lock.lock();    try &#123;        List&lt;Long&gt; l = x2u.get(xid);        if(l != null) &#123;            while(l.size() &gt; 0) &#123;                Long uid = l.remove(0);                selectNewXID(uid);            &#125;        &#125;        waitU.remove(xid);        x2u.remove(xid);        waitLock.remove(xid);    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p><pre><code>// 从等待队列中选择一个xid来占用uidprivate void selectNewXID(long uid) &#123;    u2x.remove(uid);    List&lt;Long&gt; l = wait.get(uid);    if(l == null) return;    assert l.size() &gt; 0;    while(l.size() &gt; 0) &#123;        long xid = l.remove(0);        if(!waitLock.containsKey(xid)) &#123;            continue;        &#125; else &#123;            u2x.put(uid, xid);            Lock lo = waitLock.remove(xid);            waitU.remove(xid);            lo.unlock();            break;        &#125;    &#125;    if(l.size() == 0) wait.remove(uid);&#125;</code></pre><p>从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了。</p><h2 id="VM-的实现"><a href="#VM-的实现" class="headerlink" title="VM 的实现"></a>VM 的实现</h2><p>VM 层通过 VersionManager 接口，向上层提供功能，如下：</p><pre><code>public interface VersionManager &#123;    byte[] read(long xid, long uid) throws Exception;    long insert(long xid, byte[] data) throws Exception;    boolean delete(long xid, long uid) throws Exception;    long begin(int level);    void commit(long xid) throws Exception;    void abort(long xid);&#125;</code></pre><p>同时，VM 的实现类还被设计为 Entry 的缓存，需要继承 <code>AbstractCache&lt;Entry&gt;</code>。需要实现的获取到缓存和从缓存释放的方法很简单：</p><pre><code>@Overrideprotected Entry getForCache(long uid) throws Exception &#123;    Entry entry = Entry.loadEntry(this, uid);    if(entry == null) &#123;        throw Error.NullEntryException;    &#125;    return entry;&#125;@Overrideprotected void releaseForCache(Entry entry) &#123;    entry.remove();&#125;</code></pre><p><code>begin()</code> 开启一个事务，并初始化事务的结构，将其存放在 activeTransaction 中，用于检查和快照使用：</p><pre><code>@Overridepublic long begin(int level) &#123;    lock.lock();    try &#123;        long xid = tm.begin();        Transaction t = Transaction.newTransaction(xid, level, activeTransaction);        activeTransaction.put(xid, t);        return xid;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p><code>commit()</code> 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p><pre><code>@Overridepublic void commit(long xid) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    try &#123;        if(t.err != null) &#123;            throw t.err;        &#125;    &#125; catch(NullPointerException n) &#123;        System.out.println(xid);        System.out.println(activeTransaction.keySet());        Panic.panic(n);    &#125;    lock.lock();    activeTransaction.remove(xid);    lock.unlock();    lt.remove(xid);    tm.commit(xid);&#125;</code></pre><p>abort 事务的方法则有两种，手动和自动。手动指的是调用 abort() 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚：</p><pre><code>private void internAbort(long xid, boolean autoAborted) &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    if(!autoAborted) &#123;        activeTransaction.remove(xid);    &#125;    lock.unlock();    if(t.autoAborted) return;    lt.remove(xid);    tm.abort(xid);&#125;</code></pre><p><code>read()</code> 方法读取一个 entry，注意判断下可见性即可：</p><pre><code>@Overridepublic byte[] read(long xid, long uid) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    if(t.err != null) &#123;        throw t.err;    &#125;    Entry entry = super.get(uid);    try &#123;        if(Visibility.isVisible(tm, t, entry)) &#123;            return entry.data();        &#125; else &#123;            return null;        &#125;    &#125; finally &#123;        entry.release();    &#125;&#125;</code></pre><p><code>insert()</code> 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p><pre><code>@Overridepublic long insert(long xid, byte[] data) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    if(t.err != null) &#123;        throw t.err;    &#125;    byte[] raw = Entry.wrapEntryRaw(xid, data);    return dm.insert(xid, raw);&#125;</code></pre><p><code>delete()</code> 方法看起来略为复杂：</p><pre><code>@Overridepublic boolean delete(long xid, long uid) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    if(t.err != null) &#123;        throw t.err;    &#125;    Entry entry = super.get(uid);    try &#123;        if(!Visibility.isVisible(tm, t, entry)) &#123;            return false;        &#125;        Lock l = null;        try &#123;            l = lt.add(xid, uid);        &#125; catch(Exception e) &#123;            t.err = Error.ConcurrentUpdateException;            internAbort(xid, true);            t.autoAborted = true;            throw t.err;        &#125;        if(l != null) &#123;            l.lock();            l.unlock();        &#125;        if(entry.getXmax() == xid) &#123;            return false;        &#125;        if(Visibility.isVersionSkip(tm, t, entry)) &#123;            t.err = Error.ConcurrentUpdateException;            internAbort(xid, true);            t.autoAborted = true;            throw t.err;        &#125;        entry.setXmax(xid);        return true;    &#125; finally &#123;        entry.release();    &#125;&#125;</code></pre><p>实际上主要是前置的三件事：一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 XMAX。</p>]]></content>
    
    
    <summary type="html">一起写个数据库—7.死锁检测与VM的实现</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—6.记录的版本与事务隔离</title>
    <link href="http://ylcheng1789.github.io/2024/06/07/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%946.%E8%AE%B0%E5%BD%95%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://ylcheng1789.github.io/2024/06/07/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%946.%E8%AE%B0%E5%BD%95%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</id>
    <published>2024-06-07T13:01:24.000Z</published>
    <updated>2024-08-30T14:52:13.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从这一章开始，我们开始讨论 Version Manager。</p><blockquote><p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</p></blockquote><p>类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的事务和数据版本的管理核心。</p><h2 id="2PL-与-MVCC"><a href="#2PL-与-MVCC" class="headerlink" title="2PL 与 MVCC"></a>2PL 与 MVCC</h2><h3 id="冲突与-2PL"><a href="#冲突与-2PL" class="headerlink" title="冲突与 2PL"></a>冲突与 2PL</h3><p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：</p><ol><li>这两个操作是由不同的事务执行的</li><li>这两个操作操作的是同一个数据项</li><li>这两个操作至少有一个是更新操作</li></ol><p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p><ol><li>两个不同事务的 U 操作冲突</li><li>两个不同事务的 U、R 操作冲突</li></ol><p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。</p><p>现在我们先抛开冲突不谈，记得在第四章举的例子吗，在并发情况下，两个事务同时操作 x。假设 x 的初值是 0：</p><pre><code>T1 beginT2 beginR1(x) // T1读到0R2(x) // T2读到0U1(0+1) // T1尝试把x+1U2(0+1) // T2尝试把x+1T1 commitT2 commit</code></pre><p>最后 x 的结果是 1，这个结果显然与期望的不符。</p><p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。MYDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p><p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p><p>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。</p><p>MYDB 通过 MVCC，降低了事务的阻塞概率。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p><p>还记得我们在第四章中，为了保证数据的可恢复，VM 层传递到 DM 的操作序列需要满足以下两个规则：</p><blockquote><p>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。<br>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p></blockquote><p>由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。</p><h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>对于一条记录来说，MYDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。</p><p>一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p><pre><code>public class Entry &#123;    private static final int OF_XMIN = 0;    private static final int OF_XMAX = OF_XMIN+8;    private static final int OF_DATA = OF_XMAX+8;    private long uid;    private DataItem dataItem;    private VersionManager vm;    public static Entry loadEntry(VersionManager vm, long uid) throws Exception &#123;        DataItem di = ((VersionManagerImpl)vm).dm.read(uid);        return newEntry(vm, di, uid);    &#125;    public void remove() &#123;        dataItem.release();    &#125;&#125;</code></pre><p>我们规定，一条 Entry 中存储的数据格式如下：</p><pre><code>[XMIN] [XMAX] [DATA]</code></pre><p>XMIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。它们的作用将在下一节中说明。DATA 就是这条记录持有的数据。根据这个结构，在创建记录时调用的 <code>wrapEntryRaw()</code> 方法如下：</p><pre><code>public static byte[] wrapEntryRaw(long xid, byte[] data) &#123;    byte[] xmin = Parser.long2Byte(xid);    byte[] xmax = new byte[8];    return Bytes.concat(xmin, xmax, data);&#125;</code></pre><p>同样，如果要获取记录中持有的数据，也就需要按照这个结构来解析：</p><pre><code>// 以拷贝的形式返回内容public byte[] data() &#123;    dataItem.rLock();    try &#123;        SubArray sa = dataItem.data();        byte[] data = new byte[sa.end - sa.start - OF_DATA];        System.arraycopy(sa.raw, sa.start+OF_DATA, data, 0, data.length);        return data;    &#125; finally &#123;        dataItem.rUnLock();    &#125;&#125;</code></pre><p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 DataItem 执行 <code>before()</code> 方法，这个在设置 XMAX 的值中体现了：</p><pre><code>public void setXmax(long xid) &#123;    dataItem.before();    try &#123;        SubArray sa = dataItem.data();        System.arraycopy(Parser.long2Byte(xid), 0, sa.raw, sa.start+OF_XMAX, 8);    &#125; finally &#123;        dataItem.after(xid);    &#125;&#125;</code></pre><p><code>before()</code> 和 <code>after()</code> 是在 DataItem 一节中就已经确定的数据项修改规则。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是版本可见性的概念就诞生了。</p><p>版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p><p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 XMIN 和 XMAX：</p><ul><li>XMIN：创建该版本的事务编号</li><li>XMAX：删除该版本的事务编号</li></ul><p>XMIN 应当在版本创建时填写，而 XMAX 则在版本被删除，或者有新版本出现时填写。</p><p>XMAX 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XMAX，这样，这个版本对每一个 XMAX 之后的事务都是不可见的，也就等价于删除了。</p><p>如此，在读提交下，版本对事务的可见性逻辑如下：</p><pre><code>(XMIN == Ti and                             // 由Ti创建且    XMAX == NULL                            // 还未被删除)or                                          // 或(XMIN is commited and                       // 由一个已提交的事务创建且    (XMAX == NULL or                        // 尚未删除或    (XMAX != Ti and XMAX is not commited)   // 由一个未提交的事务删除))</code></pre><p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要从最新版本开始，依次向前检查可见性，如果为 true，就可以直接返回。</p><p>以下方法判断某个记录对事务 t 是否可见：</p><pre><code>private static boolean readCommitted(TransactionManager tm, Transaction t, Entry e) &#123;    long xid = t.xid;    long xmin = e.getXmin();    long xmax = e.getXmax();    if(xmin == xid &amp;&amp; xmax == 0) return true;    if(tm.isCommitted(xmin)) &#123;        if(xmax == 0) return true;        if(xmax != xid) &#123;            if(!tm.isCommitted(xmax)) &#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;</code></pre><p>这里的 Transaction 结构只提供了一个 XID。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决不可重复读的问题。</p><p>不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。如下面的结果，加入 X 初始值为 0：</p><pre><code>T1 beginR1(X) // T1 读得 0T2 beginU2(X) // 将 X 修改为 1T2 commitR1(X) // T1 读的 1</code></pre><p>可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。</p><p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p><p>:::primary<br>事务只能读取它开始时, 就已经结束的那些事务产生的数据版本<br>:::</p><p>这条规定，增加于，事务需要忽略：</p><ol><li>在本事务后开始的事务的数据;</li><li>本事务开始时还是 active 状态的事务的数据</li></ol><p>对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。</p><p>于是，可重复读的判断逻辑如下：</p><pre><code>(XMIN == Ti and                 // 由Ti创建且 (XMAX == NULL or               // 尚未被删除))or                              // 或(XMIN is commited and           // 由一个已提交的事务创建且 XMIN &lt; XID and                 // 这个事务小于Ti且 XMIN is not in SP(Ti) and      // 这个事务在Ti开始前提交且 (XMAX == NULL or               // 尚未被删除或  (XMAX != Ti and               // 由其他事务删除但是   (XMAX is not commited or     // 这个事务尚未提交或XMAX &gt; Ti or                    // 这个事务在Ti开始之后才开始或XMAX is in SP(Ti)               // 这个事务在Ti开始前还未提交))))</code></pre><p>于是，需要提供一个结构，来抽象一个事务，以保存快照数据：</p><pre><code>public class Transaction &#123;    public long xid;    public int level;    public Map&lt;Long, Boolean&gt; snapshot;    public Exception err;    public boolean autoAborted;    public static Transaction newTransaction(long xid, int level, Map&lt;Long, Transaction&gt; active) &#123;        Transaction t = new Transaction();        t.xid = xid;        t.level = level;        if(level != 0) &#123;            t.snapshot = new HashMap&lt;&gt;();            for(Long x : active.keySet()) &#123;                t.snapshot.put(x, true);            &#125;        &#125;        return t;    &#125;    public boolean isInSnapshot(long xid) &#123;        if(xid == TransactionManagerImpl.SUPER_XID) &#123;            return false;        &#125;        return snapshot.containsKey(xid);    &#125;&#125;</code></pre><p>构造方法中的 active，保存着当前所有 active 的事务。于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p><pre><code>private static boolean repeatableRead(TransactionManager tm, Transaction t, Entry e) &#123;    long xid = t.xid;    long xmin = e.getXmin();    long xmax = e.getXmax();    if(xmin == xid &amp;&amp; xmax == 0) return true;    if(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;        if(xmax == 0) return true;        if(xmax != xid) &#123;            if(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;</code></pre>]]></content>
    
    
    <summary type="html">一起写个数据库—6.记录的版本与事务隔离</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—5.页面索引与DM层的实现</title>
    <link href="http://ylcheng1789.github.io/2024/06/06/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%945.%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E4%B8%8EDM%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://ylcheng1789.github.io/2024/06/06/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%945.%E9%A1%B5%E9%9D%A2%E7%B4%A2%E5%BC%95%E4%B8%8EDM%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-06-06T13:01:24.000Z</published>
    <updated>2024-08-30T14:54:24.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节将为 DM 层做收尾，介绍一个实现简单的页面索引。并且实现了 DM 层对于上层的抽象：DataItem。</p><h2 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h2><p>页面索引，缓存了每一页的空闲空间。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而无需从磁盘或者缓存中检查每一个页面的信息。</p><p>MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 40 个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p><p>PageIndex 的实现也很简单，一个 List 类型的数组。</p><pre><code>public class PageIndex &#123;    // 将一页划成40个区间    private static final int INTERVALS_NO = 40;    private static final int THRESHOLD = PageCache.PAGE_SIZE / INTERVALS_NO;    private List&lt;PageInfo&gt;[] lists;&#125;</code></pre><p>从 PageIndex 中获取页面也很简单，算出区间号，直接取即可：</p><pre><code>public PageInfo select(int spaceSize) &#123;    int number = spaceSize / THRESHOLD;    if(number &lt; INTERVALS_NO) number ++;    while(number &lt;= INTERVALS_NO) &#123;        if(lists[number].size() == 0) &#123;            number ++;            continue;        &#125;        return lists[number].remove(0);    &#125;    return null;&#125;</code></pre><p>返回的 PageInfo 中包含页号和空闲空间大小的信息。</p><p>可以注意到，被选择的页，会直接从 PageIndex 中移除，这意味着，同一个页面是不允许并发写的。在上层模块使用完这个页面后，需要将其重新插入 PageIndex：</p><pre><code>public void add(int pgno, int freeSpace) &#123;    int number = freeSpace / THRESHOLD;    lists[number].add(new PageInfo(pgno, freeSpace));&#125;</code></pre><p>在 DataManager 被创建时，需要获取所有页面并填充 PageIndex：</p><pre><code>// 初始化pageIndexvoid fillPageIndex() &#123;    int pageNumber = pc.getPageNumber();    for(int i = 2; i &lt;= pageNumber; i ++) &#123;        Page pg = null;        try &#123;            pg = pc.getPage(i);        &#125; catch (Exception e) &#123;            Panic.panic(e);        &#125;        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));        pg.release();    &#125;&#125;</code></pre><p>注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存。</p><h2 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h2><p>DataItem 是 DM 层向上层提供的数据抽象。上层模块通过地址，向 DM 请求到对应的 DataItem，再获取到其中的数据。</p><p>DataItem 的实现很简单：</p><pre><code>public class DataItemImpl implements DataItem &#123;    private SubArray raw;    private byte[] oldRaw;    private DataManagerImpl dm;    private long uid;    private Page pg;&#125;</code></pre><p>保存一个 dm 的引用是因为其释放依赖 dm 的释放（dm 同时实现了缓存接口，用于缓存 DataItem），以及修改数据时落日志。</p><p>DataItem 中保存的数据，结构如下：</p><pre><code>[ValidFlag] [DataSize] [Data]</code></pre><p>其中 ValidFlag 占用 1 字节，标识了该 DataItem 是否有效。删除一个 DataItem，只需要简单地将其有效位设置为 0。DataSize 占用 2 字节，标识了后面 Data 的长度。</p><p>上层模块在获取到 DataItem 后，可以通过 <code>data()</code> 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 SubArray。</p><pre><code>@Overridepublic SubArray data() &#123;    return new SubArray(raw.raw, raw.start+OF_DATA, raw.end);&#125;</code></pre><p>在上层模块试图对 DataItem 进行修改时，需要遵循一定的流程：在修改之前需要调用 <code>before()</code> 方法，想要撤销修改时，调用 <code>unBefore()</code> 方法，在修改完成后，调用 <code>after()</code> 方法。整个流程，主要是为了保存前相数据，并及时落日志。DM 会保证对 DataItem 的修改是原子性的。</p><pre><code>@Overridepublic void before() &#123;    wLock.lock();    pg.setDirty(true);    System.arraycopy(raw.raw, raw.start, oldRaw, 0, oldRaw.length);&#125;@Overridepublic void unBefore() &#123;    System.arraycopy(oldRaw, 0, raw.raw, raw.start, oldRaw.length);    wLock.unlock();&#125;@Overridepublic void after(long xid) &#123;    dm.logDataItem(xid, this);    wLock.unlock();&#125;</code></pre><p><code>after()</code> 方法，主要就是调用 dm 中的一个方法，对修改操作落日志，不赘述。</p><p>在使用完 DataItem 后，也应当及时调用 release() 方法，释放掉 DataItem 的缓存（由 DM 缓存 DataItem）。</p><pre><code>@Overridepublic void release() &#123;    dm.releaseDataItem(this);&#125;</code></pre><h2 id="DM-层的实现"><a href="#DM-层的实现" class="headerlink" title="DM 层的实现"></a>DM 层的实现</h2><p>DataManager 是 DM 层直接对外提供方法的类，同时，也实现成 DataItem 对象的缓存。DataItem 存储的 key，是由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节。</p><p>DataItem 缓存，<code>getForCache()</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p><pre><code>@Overrideprotected DataItem getForCache(long uid) throws Exception &#123;    short offset = (short)(uid &amp; ((1L &lt;&lt; 16) - 1));    uid &gt;&gt;&gt;= 32;    int pgno = (int)(uid &amp; ((1L &lt;&lt; 32) - 1));    Page pg = pc.getPage(pgno);    return DataItem.parseDataItem(pg, offset, this);&#125;</code></pre><p>DataItem 缓存释放，需要将 DataItem 写回数据源，由于对文件的读写是以页为单位进行的，只需要将 DataItem 所在的页 release 即可：</p><pre><code>@Overrideprotected void releaseForCache(DataItem di) &#123;    di.page().release();&#125;</code></pre><p>从已有文件创建 DataManager 和从空文件创建 DataManager 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p><pre><code>public static DataManager create(String path, long mem, TransactionManager tm) &#123;    PageCache pc = PageCache.create(path, mem);    Logger lg = Logger.create(path);    DataManagerImpl dm = new DataManagerImpl(pc, lg, tm);    dm.initPageOne();    return dm;&#125;public static DataManager open(String path, long mem, TransactionManager tm) &#123;    PageCache pc = PageCache.open(path, mem);    Logger lg = Logger.open(path);    DataManagerImpl dm = new DataManagerImpl(pc, lg, tm);    if(!dm.loadCheckPageOne()) &#123;        Recover.recover(tm, lg, pc);    &#125;    dm.fillPageIndex();    PageOne.setVcOpen(dm.pageOne);    dm.pc.flushPage(dm.pageOne);    return dm;&#125;</code></pre><p>其中，初始化第一页，和校验第一页，基本都是调用 PageOne 类中的方法实现的：</p><pre><code>// 在创建文件时初始化PageOnevoid initPageOne() &#123;    int pgno = pc.newPage(PageOne.InitRaw());    assert pgno == 1;    try &#123;        pageOne = pc.getPage(pgno);    &#125; catch (Exception e) &#123;        Panic.panic(e);    &#125;    pc.flushPage(pageOne);&#125;// 在打开已有文件时时读入PageOne，并验证正确性boolean loadCheckPageOne() &#123;    try &#123;        pageOne = pc.getPage(1);    &#125; catch (Exception e) &#123;        Panic.panic(e);    &#125;    return PageOne.checkVc(pageOne);&#125;</code></pre><p>DM 层提供了三个功能供上层使用，分别是读、插入和修改。修改是通过读出的 DataItem 实现的，于是 DataManager 只需要提供 <code>read()</code> 和 <code>insert()</code> 方法。</p><p><code>read()</code> 根据 UID 从缓存中获取 DataItem，并校验有效位：</p><pre><code>@Overridepublic DataItem read(long uid) throws Exception &#123;    DataItemImpl di = (DataItemImpl)super.get(uid);    if(!di.isValid()) &#123;        di.release();        return null;    &#125;    return di;&#125;</code></pre><p><code>insert()</code> 方法，在 pageIndex 中获取一个足以存储插入内容的页面的页号，获取页面后，首先需要写入插入日志，接着才可以通过 pageX 插入数据，并返回插入位置的偏移。最后需要将页面信息重新插入 pageIndex。</p><pre><code>@Overridepublic long insert(long xid, byte[] data) throws Exception &#123;    byte[] raw = DataItem.wrapDataItemRaw(data);    if(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;        throw Error.DataTooLargeException;    &#125;    // 尝试获取可用页    PageInfo pi = null;    for(int i = 0; i &lt; 5; i ++) &#123;        pi = pIndex.select(raw.length);        if (pi != null) &#123;            break;        &#125; else &#123;            int newPgno = pc.newPage(PageX.initRaw());            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);        &#125;    &#125;    if(pi == null) &#123;        throw Error.DatabaseBusyException;    &#125;    Page pg = null;    int freeSpace = 0;    try &#123;        pg = pc.getPage(pi.pgno);        // 首先做日志        byte[] log = Recover.insertLog(xid, pg, raw);        logger.log(log);        // 再执行插入操作        short offset = PageX.insert(pg, raw);        pg.release();        return Types.addressToUid(pi.pgno, offset);    &#125; finally &#123;        // 将取出的pg重新插入pIndex        if(pg != null) &#123;            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));        &#125; else &#123;            pIndex.add(pi.pgno, freeSpace);        &#125;    &#125;&#125;</code></pre><p>DataManager 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置第一页的字节校验：</p><pre><code>@Overridepublic void close() &#123;    super.close();    logger.close();    PageOne.setVcClose(pageOne);    pageOne.release();    pc.close();&#125;</code></pre><p>以上，DM 层完结。</p>]]></content>
    
    
    <summary type="html">一起写个数据库—5.页面索引与DM层的实现</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—4.日志文件与恢复策略</title>
    <link href="http://ylcheng1789.github.io/2024/06/05/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%944.%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://ylcheng1789.github.io/2024/06/05/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%944.%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5/</id>
    <published>2024-06-05T13:01:24.000Z</published>
    <updated>2024-08-30T14:51:51.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库奔溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。</p><h2 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h2><p>日志的二进制文件，按照如下的格式进行排布：</p><pre><code>[XChecksum][Log1][Log2][Log3]...[LogN][BadTail]</code></pre><p>其中 XChecksum 是一个四字节的整数，是对后续所有日志计算的校验和。Log1 ~ LogN 是常规的日志数据，BadTail 是在数据库崩溃时，没有来得及写完的日志数据，这个 BadTail 不一定存在。</p><p>每条日志的格式如下：</p><pre><code>[Size][Checksum][Data]</code></pre><p>其中，Size 是一个四字节整数，标识了 Data 段的字节数。Checksum 则是该条日志的校验和。</p><p>单条日志的校验和，其实就是通过一个指定的种子实现的：</p><pre><code>private int calChecksum(int xCheck, byte[] log) &#123;    for (byte b : log) &#123;        xCheck = xCheck * SEED + b;    &#125;    return xCheck;&#125;</code></pre><p>这样，对所有日志求出校验和，求和就能得到日志文件的校验和了。</p><p>Logger 被实现成迭代器模式，通过 <code>next()</code> 方法，不断地从文件中读取下一条日志，并将其中的 Data 解析出来并返回。<code>next()</code> 方法的实现主要依靠 <code>internNext()</code>，大致如下，其中 position 是当前日志文件读到的位置偏移：</p><pre><code>private byte[] internNext() &#123;    if(position + OF_DATA &gt;= fileSize) &#123;        return null;    &#125;    // 读取size    ByteBuffer tmp = ByteBuffer.allocate(4);    fc.position(position);    fc.read(tmp);    int size = Parser.parseInt(tmp.array());    if(position + size + OF_DATA &gt; fileSize) &#123;        return null;    &#125;    // 读取checksum+data    ByteBuffer buf = ByteBuffer.allocate(OF_DATA + size);    fc.position(position);    fc.read(buf);    byte[] log = buf.array();    // 校验 checksum    int checkSum1 = calChecksum(0, Arrays.copyOfRange(log, OF_DATA, log.length));    int checkSum2 = Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));    if(checkSum1 != checkSum2) &#123;        return null;    &#125;    position += log.length;    return log;&#125;</code></pre><p>在打开一个日志文件时，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。</p><pre><code>private void checkAndRemoveTail() &#123;    rewind();    int xCheck = 0;    while(true) &#123;        byte[] log = internNext();        if(log == null) break;        xCheck = calChecksum(xCheck, log);    &#125;    if(xCheck != xChecksum) &#123;        Panic.panic(Error.BadLogFileException);    &#125;    // 截断文件到正常日志的末尾    truncate(position);    rewind();&#125;</code></pre><p>向日志文件写入日志时，也是首先将数据包裹成日志格式，写入文件后，再更新文件的校验和，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p><pre><code>public void log(byte[] data) &#123;    byte[] log = wrapLog(data);    ByteBuffer buf = ByteBuffer.wrap(log);    lock.lock();    try &#123;        fc.position(fc.size());        fc.write(buf);    &#125; catch(IOException e) &#123;        Panic.panic(e);    &#125; finally &#123;        lock.unlock();    &#125;    updateXChecksum(log);&#125;private void updateXChecksum(byte[] log) &#123;    this.xChecksum = calChecksum(this.xChecksum, log);    fc.position(0);    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));    fc.force(false);&#125;private byte[] wrapLog(byte[] data) &#123;    byte[] checksum = Parser.int2Byte(calChecksum(0, data));    byte[] size = Parser.int2Byte(data.length);    return Bytes.concat(size, checksum, data);&#125;</code></pre><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><p>恢复策略来自于 NYADB2 的恢复策略，比较烧脑（我感觉）。</p><p>DM 为上层模块，提供了两种操作，分别是插入新数据（I）和更新现有数据（U）。至于为啥没有删除数据，这个会在 VM 一节叙述。</p><p>DM 的日志策略很简单，一句话就是：</p><blockquote><p>在进行 I 和 U 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。</p></blockquote><p>这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后没有来得及同步到磁盘，数据库就发生了崩溃，后续也可以通过磁盘上的日志恢复该数据。</p><p>对于两种数据操作，DM 记录的日志如下：</p><ul><li>(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x</li><li>(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</li></ul><p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p><pre><code>(Ti, x, x), ..., (Ti, x, x), (Tj, x, x), ..., (Tj, x, x), (Tk, x, x), ..., (Tk, x, x)</code></pre><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下利用日志恢复很简单，假设日志中最后一个事务是 Ti：</p><ol><li>对 Ti 之前所有的事务的日志，进行重做（redo）</li><li>接着检查 Ti 的状态（XID 文件），如果 Ti 的状态是已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）</li></ol><p>接着，是如何对事务 T 进行 redo：</p><ol><li>正序扫描事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li></ol><p>undo 也很好理解：</p><ol><li>倒序扫描事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx</li></ol><p>注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>经过以上的操作，就能保证了 MYDB 在单线程下的恢复性。对于多线程的情况下呢？我们来考虑下面的两种情况。</p><p>第一种：</p><pre><code>T1 beginT2 beginT2 U(x)T1 R(x)...T1 commitMYDB break down</code></pre><p>在系统崩溃时，T2 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，会撤销 T2，它对数据库的影响会被消除。但是由于 T1 读取了 T2 更新的值，既然 T2 被撤销，那么 T1 也应当被撤销。这种情况，就是级联回滚。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p><blockquote><p>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</p></blockquote><p>第二种情况，假设 x 的初值是 0</p><pre><code>T1 beginT2 beginT1 set x = x+1 // 产生的日志为(T1, U, A, 0, 1)T2 set x = x+1 // 产生的日志为(T1, U, A, 1, 2)T2 commitMYDB break down</code></pre><p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，会对 T1 进行撤销，对 T2 进行重做，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p><blockquote><p>出现这种问题的原因, 归根结底是因为我们的日志太过简单, 仅仅记录了”前相”和”后相”. 并单纯的依靠”前相”undo, 依靠”后相”redo. 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p></blockquote><p>解决方法有两种：</p><ol><li>增加日志种类</li><li>限制数据库操作</li></ol><p>MYDB 采用的是限制数据库操作，需要保证：</p><blockquote><p>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p></blockquote><p>在 MYDB 中，由于 VM 的存在，传递到 DM 层，真正执行的操作序列，都可以保证规定 1 和规定 2。VM 如何保证这两条规定，会在 VM 层一节中说明（VM 的坑还挺大）。有了这两条规定，并发情况下日志的恢复也就很简单了：</p><ol><li>重做所有崩溃时已完成（committed 或 aborted）的事务</li><li>撤销所有崩溃时未完成（active）的事务</li></ol><p>在恢复后，数据库就会恢复到所有已完成事务结束，所有未完成事务尚未开始的状态。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先规定两种日志的格式：</p><pre><code>private static final byte LOG_TYPE_INSERT = 0;private static final byte LOG_TYPE_UPDATE = 1;updateLog:[LogType] [XID] [UID] [OldRaw] [NewRaw]insertLog:[LogType] [XID] [Pgno] [Offset] [Raw]</code></pre><p>和原理中描述的类似，recover 例程主要也是两步：重做所有已完成事务，撤销所有未完成事务：</p><pre><code>private static void redoTranscations(TransactionManager tm, Logger lg, PageCache pc) &#123;    lg.rewind();    while(true) &#123;        byte[] log = lg.next();        if(log == null) break;        if(isInsertLog(log)) &#123;            InsertLogInfo li = parseInsertLog(log);            long xid = li.xid;            if(!tm.isActive(xid)) &#123;                doInsertLog(pc, log, REDO);            &#125;        &#125; else &#123;            UpdateLogInfo xi = parseUpdateLog(log);            long xid = xi.xid;            if(!tm.isActive(xid)) &#123;                doUpdateLog(pc, log, REDO);            &#125;        &#125;    &#125;&#125;private static void undoTranscations(TransactionManager tm, Logger lg, PageCache pc) &#123;    Map&lt;Long, List&lt;byte[]&gt;&gt; logCache = new HashMap&lt;&gt;();    lg.rewind();    while(true) &#123;        byte[] log = lg.next();        if(log == null) break;        if(isInsertLog(log)) &#123;            InsertLogInfo li = parseInsertLog(log);            long xid = li.xid;            if(tm.isActive(xid)) &#123;                if(!logCache.containsKey(xid)) &#123;                    logCache.put(xid, new ArrayList&lt;&gt;());                &#125;                logCache.get(xid).add(log);            &#125;        &#125; else &#123;            UpdateLogInfo xi = parseUpdateLog(log);            long xid = xi.xid;            if(tm.isActive(xid)) &#123;                if(!logCache.containsKey(xid)) &#123;                    logCache.put(xid, new ArrayList&lt;&gt;());                &#125;                logCache.get(xid).add(log);            &#125;        &#125;    &#125;    // 对所有active log进行倒序undo    for(Entry&lt;Long, List&lt;byte[]&gt;&gt; entry : logCache.entrySet()) &#123;        List&lt;byte[]&gt; logs = entry.getValue();        for (int i = logs.size()-1; i &gt;= 0; i --) &#123;            byte[] log = logs.get(i);            if(isInsertLog(log)) &#123;                doInsertLog(pc, log, UNDO);            &#125; else &#123;                doUpdateLog(pc, log, UNDO);            &#125;        &#125;        tm.abort(entry.getKey());    &#125;&#125;</code></pre><p>updateLog 和 insertLog 的重做和撤销处理，分别合并成一个方法来实现：</p><pre><code>private static void doUpdateLog(PageCache pc, byte[] log, int flag) &#123;    int pgno;    short offset;    byte[] raw;    if(flag == REDO) &#123;        UpdateLogInfo xi = parseUpdateLog(log);        pgno = xi.pgno;        offset = xi.offset;        raw = xi.newRaw;    &#125; else &#123;        UpdateLogInfo xi = parseUpdateLog(log);        pgno = xi.pgno;        offset = xi.offset;        raw = xi.oldRaw;    &#125;    Page pg = null;    try &#123;        pg = pc.getPage(pgno);    &#125; catch (Exception e) &#123;        Panic.panic(e);    &#125;    try &#123;        PageX.recoverUpdate(pg, raw, offset);    &#125; finally &#123;        pg.release();    &#125;&#125;private static void doInsertLog(PageCache pc, byte[] log, int flag) &#123;    InsertLogInfo li = parseInsertLog(log);    Page pg = null;    try &#123;        pg = pc.getPage(li.pgno);    &#125; catch(Exception e) &#123;        Panic.panic(e);    &#125;    try &#123;        if(flag == UNDO) &#123;            DataItem.setDataItemRawInvalid(li.raw);        &#125;        PageX.recoverInsert(pg, li.raw, li.offset);    &#125; finally &#123;        pg.release();    &#125;&#125;</code></pre><p>注意，<code>doInsertLog()</code> 方法中的删除，使用的是 <code>DataItem.setDataItemRawInvalid(li.raw);</code>，dataItem 将在下一节中说明，大致的作用，就是将该条 DataItem 的有效位设置为无效，来进行逻辑删除。</p>]]></content>
    
    
    <summary type="html">一起写个数据库—4.日志文件与恢复策略</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—3.数据页的缓存与管理</title>
    <link href="http://ylcheng1789.github.io/2024/06/04/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%943.%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>http://ylcheng1789.github.io/2024/06/04/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%943.%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E7%AE%A1%E7%90%86/</id>
    <published>2024-06-04T13:01:24.000Z</published>
    <updated>2024-08-30T14:51:38.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要内容就是 DM 模块向下对文件系统的抽象部分。DM 将文件系统抽象成页面，每次对文件系统的读写都是以页面为单位的。同样，从文件系统读进来的数据也是以页面为单位进行缓存的。</p><h2 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h2><p>这里参考大部分数据库的设计，将默认数据页大小定为 8K。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p><p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要定义出页面的结构。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。</p><p>定义一个页面如下：</p><pre><code>public class PageImpl implements Page &#123;    private int pageNumber;    private byte[] data;    private boolean dirty;    private Lock lock;        private PageCache pc;&#125;</code></pre><p>其中，pageNumber 是这个页面的页号，<strong>该页号从 1 开始</strong>。data 就是这个页实际包含的字节数据。dirty 标志着这个页面是否是脏页面，在缓存驱逐的时候，脏页面需要被写回磁盘。这里保存了一个 PageCache（还未定义）的引用，用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</p><p>定义页面缓存的接口如下：</p><pre><code>public interface PageCache &#123;    int newPage(byte[] initData);    Page getPage(int pgno) throws Exception;    void close();    void release(Page page);    void truncateByBgno(int maxPgno);    int getPageNumber();    void flushPage(Page pg);&#125;</code></pre><p>页面缓存的具体实现类，需要继承抽象缓存框架，并且实现 <code>getForCache()</code> 和 <code>releaseForCache()</code> 两个抽象方法。由于数据源就是文件系统，<code>getForCache()</code> 直接从文件中读取，并包裹成 Page 即可：</p><pre><code>@Overrideprotected Page getForCache(long key) throws Exception &#123;    int pgno = (int)key;    long offset = PageCacheImpl.pageOffset(pgno);    ByteBuffer buf = ByteBuffer.allocate(PAGE_SIZE);    fileLock.lock();    try &#123;        fc.position(offset);        fc.read(buf);    &#125; catch(IOException e) &#123;        Panic.panic(e);    &#125;    fileLock.unlock();    return new PageImpl(pgno, buf.array(), this);&#125;private static long pageOffset(int pgno) &#123;    // 页号从 1 开始    return (pgno-1) * PAGE_SIZE;&#125;</code></pre><p>而 <code>releaseForCache()</code> 驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p><pre><code>@Overrideprotected void releaseForCache(Page pg) &#123;    if(pg.isDirty()) &#123;        flush(pg);        pg.setDirty(false);    &#125;&#125;private void flush(Page pg) &#123;    int pgno = pg.getPageNumber();    long offset = pageOffset(pgno);    fileLock.lock();    try &#123;        ByteBuffer buf = ByteBuffer.wrap(pg.getData());        fc.position(offset);        fc.write(buf);        fc.force(false);    &#125; catch(IOException e) &#123;        Panic.panic(e);    &#125; finally &#123;        fileLock.unlock();    &#125;&#125;</code></pre><p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p><pre><code>public int newPage(byte[] initData) &#123;    int pgno = pageNumbers.incrementAndGet();    Page pg = new PageImpl(pgno, initData, null);    flush(pg);  // 新建的页面需要立刻写回    return pgno;&#125;</code></pre><p>提一点，同一条数据是不允许跨页存储的，这一点会从后面的章节中体现。这意味着，单条数据的大小不能超过数据库页面的大小。</p><h2 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h2><h3 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h3><p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是用来做启动检查。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。</p><p>这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p><p>启动时设置初始字节：</p><pre><code>public static void setVcOpen(Page pg) &#123;    pg.setDirty(true);    setVcOpen(pg.getData());&#125;private static void setVcOpen(byte[] raw) &#123;    System.arraycopy(RandomUtil.randomBytes(LEN_VC), 0, raw, OF_VC, LEN_VC);&#125;</code></pre><p>关闭时拷贝字节：</p><pre><code>public static void setVcClose(Page pg) &#123;    pg.setDirty(true);    setVcClose(pg.getData());&#125;private static void setVcClose(byte[] raw) &#123;    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);&#125;</code></pre><p>校验字节：</p><pre><code>public static boolean checkVc(Page pg) &#123;    return checkVc(pg.getData());&#125;private static boolean checkVc(byte[] raw) &#123;    return Arrays.compare(raw, OF_VC, OF_VC+LEN_VC, raw, OF_VC+LEN_VC, OF_VC+2*LEN_VC) == 0;&#125;</code></pre><p>似乎就是这个 <code>Arrays.compare()</code> 方法不兼容 JDK8，可以使用其他等价的方法替换。</p><h3 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h3><p>MYDB 对于普通数据页的管理就比较简单了。一个普通页面以一个 2 字节无符号数起始，表示这一页的空闲位置的偏移。剩下的部分都是实际存储的数据。</p><p>所以对普通页的管理，基本都是围绕着对 FSO（Free Space Offset）进行的。例如向页面插入数据：</p><pre><code>// 将raw插入pg中，返回插入位置public static short insert(Page pg, byte[] raw) &#123;    pg.setDirty(true);    short offset = getFSO(pg.getData());    System.arraycopy(raw, 0, pg.getData(), offset, raw.length);    setFSO(pg.getData(), (short)(offset + raw.length));    return offset;&#125;</code></pre><p>在写入之前获取 FSO，来确定写入的位置，并在写入之后更新 FSO。FSO 的操作如下：</p><pre><code>private static void setFSO(byte[] raw, short ofData) &#123;    System.arraycopy(Parser.short2Byte(ofData), 0, raw, OF_FREE, OF_DATA);&#125;// 获取pg的FSOpublic static short getFSO(Page pg) &#123;    return getFSO(pg.getData());&#125;private static short getFSO(byte[] raw) &#123;    return Parser.parseShort(Arrays.copyOfRange(raw, 0, 2));&#125;// 获取页面的空闲空间大小public static int getFreeSpace(Page pg) &#123;    return PageCache.PAGE_SIZE - (int)getFSO(pg.getData());&#125;</code></pre>]]></content>
    
    
    <summary type="html">一起写个数据库—3.数据页的缓存与管理</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—2.引用计数缓存框架和共享内存数组</title>
    <link href="http://ylcheng1789.github.io/2024/06/03/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%942.%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84/"/>
    <id>http://ylcheng1789.github.io/2024/06/03/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%942.%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84/</id>
    <published>2024-06-03T13:01:24.000Z</published>
    <updated>2024-08-30T14:51:25.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从这一章中，我们开始讨论 MYDB 中最底层的模块 —— Data Manager：</p><blockquote><p>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</p></blockquote><p>DM 的功能其实可以归纳为两点：上层模块和文件系统之间的一个抽象层，向下直接读写文件，向上提供数据的包装；另外就是日志功能。</p><p>可以注意到，无论是向上还是向下，DM 都提供了一个缓存的功能，用内存操作来保证效率。</p><h2 id="引用计数缓存框架"><a href="#引用计数缓存框架" class="headerlink" title="引用计数缓存框架"></a>引用计数缓存框架</h2><h3 id="why-not-LRU"><a href="#why-not-LRU" class="headerlink" title="why not LRU?"></a>why not LRU?</h3><p>由于分页管理和数据项（DataItem）管理都涉及缓存，这里设计一个更通用的缓存框架。</p><p>看到这里，估计你们也开始犯嘀咕了，为啥使用引用计数策略，而不使用极为先进的 LRU 策略呢？</p><p>这里首先从缓存的接口设计说起，如果使用 LRU 缓存，那么只需要设计一个 <code>get(key)</code> 接口即可，释放缓存可以在缓存满了之后自动完成。设想这样一个场景：某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，这个资源恰好是刚刚被驱逐的资源。那么上层模块就发现，这个数据在缓存里消失了，这时候就陷入了一种尴尬的境地：是否有必要做回源操作？</p><ol><li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li><li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源</li><li>放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题</li></ol><p>当然我们可以记录下资源的最后修改时间，并且让缓存记录下资源被驱逐的时间。但是……</p><blockquote><p>如无必要，无增实体。 —— 奥卡姆剃刀</p></blockquote><p>问题的根源还是，LRU 策略中，资源驱逐不可控，上层模块无法感知。而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。</p><p>这就是引用计数法了。增加了一个方法 <code>release(key)</code>，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p><p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><code>AbstractCache&lt;T&gt;</code> 是一个抽象类，内部有两个抽象方法，留给实现类去实现具体的操作：</p><pre><code>/** * 当资源不在缓存时的获取行为 */protected abstract T getForCache(long key) throws Exception;/** * 当资源被驱逐时的写回行为 */protected abstract void releaseForCache(T obj);</code></pre><p>引用计数嘛，除了普通的缓存功能，还需要另外维护一个计数。除此以外，为了应对多线程场景，还需要记录哪些资源正在从数据源获取中（从数据源获取资源是一个相对费时的操作）。于是有下面三个 Map：</p><pre><code>private HashMap&lt;Long, T&gt; cache;                     // 实际缓存的数据private HashMap&lt;Long, Integer&gt; references;          // 资源的引用个数private HashMap&lt;Long, Boolean&gt; getting;             // 正在被获取的资源</code></pre><p>于是，在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看（</p><pre><code>while(true) &#123;    lock.lock();    if(getting.containsKey(key)) &#123;        // 请求的资源正在被其他线程获取        lock.unlock();        try &#123;            Thread.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();            continue;        &#125;        continue;    &#125;    ...&#125;</code></pre><p>当然如果资源在缓存中，就可以直接获取并返回了，记得要给资源的引用数 +1。否则，如果缓存没满的话，就在 getting 中注册一下，该线程准备从数据源获取资源了。</p><pre><code>while(true) &#123;    if(cache.containsKey(key)) &#123;        // 资源在缓存中，直接返回        T obj = cache.get(key);        references.put(key, references.get(key) + 1);        lock.unlock();        return obj;    &#125;    // 尝试获取该资源    if(maxResource &gt; 0 &amp;&amp; count == maxResource) &#123;        lock.unlock();        throw Error.CacheFullException;    &#125;    count ++;    getting.put(key, true);    lock.unlock();    break;&#125;</code></pre><p>从数据源获取资源就比较简单了，直接调用那个抽象方法即可，获取完成记得从 getting 中删除 key。</p><pre><code>T obj = null;try &#123;    obj = getForCache(key);&#125; catch(Exception e) &#123;    lock.lock();    count --;    getting.remove(key);    lock.lock();    throw e;&#125;lock.lock();getting.remove(key);cache.put(key, obj);references.put(key, 1);lock.unlock();</code></pre><p>释放一个缓存就简单多了，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构了：</p><pre><code>/** * 强行释放一个缓存 */protected void release(long key) &#123;    lock.lock();    try &#123;        int ref = references.get(key)-1;        if(ref == 0) &#123;            T obj = cache.get(key);            releaseForCache(obj);            references.remove(key);            cache.remove(key);            count --;        &#125; else &#123;            references.put(key, ref);        &#125;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>缓存应当还有以一个安全关闭的功能，在关闭时，需要将缓存中所有的资源强行回源。</p><p>这样，一个简单的缓存框架就实现完了，其他的缓存只需要继承这个类，并实现那两个抽象方法即可。</p><h2 id="共享内存数组"><a href="#共享内存数组" class="headerlink" title="共享内存数组"></a>共享内存数组</h2><p>这里得提一个 Java 很蛋疼的地方。</p><p>Java 中，将数组看作一个对象，在内存中，也是以对象的形式存储的。而 c、cpp 和 go 之类的语言，数组是用指针来实现的。这就是为什么有一种说法：</p><blockquote><p>只有 Java 有真正的数组</p></blockquote><p>但这对这个项目似乎不是一个好消息。譬如 golang，可以执行下面语句：</p><pre><code>var array1 [10]int64array2 := array1[5:]</code></pre><p>这种情况下，array2 和 array1 的第五个元素到最后一个元素，是共用同一片内存的，即使这两个数组的长度不同。</p><p>这在 Java 中是无法实现的（什么是高级语言啊~）。</p><p>在 Java 中，当你执行类似 subArray 的操作时，只会在底层进行一个复制，无法同一片内存。</p><p>于是，我写了一个 SubArray 类，来（松散地）规定这个数组的可使用范围：</p><pre><code>public class SubArray &#123;    public byte[] raw;    public int start;    public int end;    public SubArray(byte[] raw, int start, int end) &#123;        this.raw = raw;        this.start = start;        this.end = end;    &#125;&#125;</code></pre><p>说实话，这是一个很丑的方案，但是暂时也只能这样了。如果有其他解决方案的同学，可以在底下留言，我也不想写得这么丑&#x2F;(ㄒoㄒ)&#x2F;~~</p>]]></content>
    
    
    <summary type="html">一起写个数据库—2.引用计数缓存框架和共享内存数组</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—1.从最简单的TM开始</title>
    <link href="http://ylcheng1789.github.io/2024/06/02/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%941.%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84TM%E5%BC%80%E5%A7%8B/"/>
    <id>http://ylcheng1789.github.io/2024/06/02/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%941.%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84TM%E5%BC%80%E5%A7%8B/</id>
    <published>2024-06-02T13:01:24.000Z</published>
    <updated>2024-08-30T14:53:45.205Z</updated>
    
    <content type="html"><![CDATA[<p>如第 0 章所述：</p><blockquote><p>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</p></blockquote><h2 id="XID-文件"><a href="#XID-文件" class="headerlink" title="XID 文件"></a>XID 文件</h2><p>下面主要是规则的定义了。</p><p>在 MYDB 中，每一个事务都有一个 XID，这个 ID 唯一标识了这个事务。事务的 XID 从 1 开始标号，并自增，不可重复。并特殊规定 XID 0 是一个超级事务（Super Transaction）。当一些操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。XID 为 0 的事务的状态永远是 committed。</p><p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。MYDB 中，每个事务都有下面的三种状态：</p><ol start="0"><li>active，正在进行，尚未结束</li><li>committed，已提交</li><li>aborted，已撤销（回滚）</li></ol><p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p><p>TransactionManager 提供了一些接口供其他模块调用，用来创建事务和查询事务状态。更具体的：</p><pre><code>public interface TransactionManager &#123;    long begin();                       // 开启一个新事务    void commit(long xid);              // 提交一个事务    void abort(long xid);               // 取消一个事务    boolean isActive(long xid);         // 查询一个事务的状态是否是正在进行的状态    boolean isCommitted(long xid);      // 查询一个事务的状态是否是已提交    boolean isAborted(long xid);        // 查询一个事务的状态是否是已取消    void close();                       // 关闭TM&#125;</code></pre><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>规则很简单，剩下的就是编码了。首先定义一些必要的常量：</p><pre><code>// XID文件头长度static final int LEN_XID_HEADER_LENGTH = 8;// 每个事务的占用长度private static final int XID_FIELD_SIZE = 1;// 事务的三种状态private static final byte FIELD_TRAN_ACTIVE   = 0;private static final byte FIELD_TRAN_COMMITTED = 1;private static final byte FIELD_TRAN_ABORTED  = 2;// 超级事务，永远为commited状态public static final long SUPER_XID = 0;// XID 文件后缀static final String XID_SUFFIX = &quot;.xid&quot;;</code></pre><p>文件读写都采用了 NIO 方式的 FileChannel，读写方式都和传统 IO 的 Input&#x2F;Output Stream 都有一些区别，不过区别主要是接口方面，熟悉使用即可。</p><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。</p><pre><code>private void checkXIDCounter() &#123;    long fileLen = 0;    try &#123;        fileLen = file.length();    &#125; catch (IOException e1) &#123;        Panic.panic(Error.BadXIDFileException);    &#125;    if(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;        Panic.panic(Error.BadXIDFileException);    &#125;    ByteBuffer buf = ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);    try &#123;        fc.position(0);        fc.read(buf);    &#125; catch (IOException e) &#123;        Panic.panic(e);    &#125;    this.xidCounter = Parser.parseLong(buf.array());    long end = getXidPosition(this.xidCounter + 1);    if(end != fileLen) &#123;        Panic.panic(Error.BadXIDFileException);    &#125;&#125;</code></pre><p>对于校验没有通过的，会直接通过 panic 方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p><p>我们可以先写一个小的方法，用来获取 xid 的状态在文件中的偏移：</p><pre><code>// 根据事务xid取得其在xid文件中对应的位置private long getXidPosition(long xid) &#123;    return LEN_XID_HEADER_LENGTH + (xid-1)*XID_FIELD_SIZE;&#125;</code></pre><p><code>begin()</code> 方法会开始一个事务，更具体的，首先设置 xidCounter+1 事务的状态为 committed，随后 xidCounter 自增，并更新文件头。</p><pre><code>// 开始一个事务，并返回XIDpublic long begin() &#123;    counterLock.lock();    try &#123;        long xid = xidCounter + 1;        updateXID(xid, FIELD_TRAN_ACTIVE);        incrXIDCounter();        return xid;    &#125; finally &#123;        counterLock.unlock();    &#125;&#125;// 更新xid事务的状态为statusprivate void updateXID(long xid, byte status) &#123;    long offset = getXidPosition(xid);    byte[] tmp = new byte[XID_FIELD_SIZE];    tmp[0] = status;    ByteBuffer buf = ByteBuffer.wrap(tmp);    try &#123;        fc.position(offset);        fc.write(buf);    &#125; catch (IOException e) &#123;        Panic.panic(e);    &#125;    try &#123;        fc.force(false);    &#125; catch (IOException e) &#123;        Panic.panic(e);    &#125;&#125;// 将XID加一，并更新XID Headerprivate void incrXIDCounter() &#123;    xidCounter ++;    ByteBuffer buf = ByteBuffer.wrap(Parser.long2Byte(xidCounter));    try &#123;        fc.position(0);        fc.write(buf);    &#125; catch (IOException e) &#123;        Panic.panic(e);    &#125;    try &#123;        fc.force(false);    &#125; catch (IOException e) &#123;        Panic.panic(e);    &#125;&#125;</code></pre><p>注意，这里的所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据，fileChannel 的 <code>force()</code> 方法，强制同步缓存内容到文件中，类似于 BIO 中的 <code>flush()</code> 方法。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</p><p><code>commit()</code> 和 <code>abort()</code> 方法就可以直接借助 <code>updateXID()</code> 方法实现。</p><p>同样，<code>isActive()</code>、<code>isCommitted()</code> 和 <code>isAborted()</code> 都是检查一个 xid 的状态，可以用一个通用的方法解决：</p><pre><code>// 检测XID事务是否处于status状态private boolean checkXID(long xid, byte status) &#123;    long offset = getXidPosition(xid);    ByteBuffer buf = ByteBuffer.wrap(new byte[XID_FIELD_SIZE]);    try &#123;        fc.position(offset);        fc.read(buf);    &#125; catch (IOException e) &#123;        Panic.panic(e);    &#125;    return buf.array()[0] == status;&#125;</code></pre><p>当然，检查之间记得排除 SUPER_XID。</p><p>另外就是两个静态方法：<code>create()</code> 和 <code>open()</code>，分别表示创建一个 xid 文件并创建 TM 和从一个已有的 xid 文件来创建 TM。从零创建 XID 文件时需要写一个空的 XID 文件头，即设置 xidCounter 为 0，否则后续在校验时会不合法：</p><pre><code>public static TransactionManagerImpl create(String path) &#123;    ...    // 写空XID文件头    ByteBuffer buf = ByteBuffer.wrap(new byte[TransactionManagerImpl.LEN_XID_HEADER_LENGTH]);    try &#123;        fc.position(0);        fc.write(buf);    &#125; catch (IOException e) &#123;        Panic.panic(e);    &#125;    ...&#125;</code></pre><p>TM 就这么结束了，看起来也没什么难的嘛（￣ c￣）y-～</p><p>不着急，真正困难的 DM 还在后面，那可不是一章就能讲完的了~</p>]]></content>
    
    
    <summary type="html">一起写个数据库—1.从最简单的TM开始</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一起写个数据库—0.项目结构和一些不得不说的话</title>
    <link href="http://ylcheng1789.github.io/2024/06/01/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%940.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
    <id>http://ylcheng1789.github.io/2024/06/01/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%940.%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E8%AF%9D/</id>
    <published>2024-06-01T13:01:24.000Z</published>
    <updated>2024-08-30T14:50:55.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言（一些废话）"><a href="#前言（一些废话）" class="headerlink" title="前言（一些废话）"></a>前言（一些废话）</h2><p>或许是造轮子上瘾了，也有可能更有可能只是觉得需要补一补数据库的基本原理，大概花了大半个月，利用下班到半夜这段时间，我做完了这个项目。</p><p>和数据库也算有点渊源的，在学校开设数据库系统这门课的时候，我恰巧在深圳实习。于是乎，上网课成了我实习期间名正言顺的摸鱼理由，除了听课，其他啥都干。同样，操作系统也是在那个时候教授的，因为我对 OS 还是有点兴趣的，所以学得没有 DB 那么烂。</p><p>很快副作用就来了，字节二面的时候，面试官问我对数据库了解怎么样，本着坦诚清晰的原则，我说“一点也不了解”，于是又问我 redis 呢，我也只好说“也不了解”。好在面试官倒也没计较，还让我过了。就是不知道这俩“不知道”有没有拖烂我的面评……</p><p>工作之后，组里的内容和数据库倒也没有什么关系，本以为就此远离了数据库和 CRUD，没想到变化来得如此的快，隔壁资管组急缺人，向部门申请调人力支援，于是我就被弄过去支援了。资管对于一致性要求颇高，自然不能像原来一样，啥数据都往 redis 塞，没塞进去也没关系了……</p><h2 id="契机"><a href="#契机" class="headerlink" title="契机"></a>契机</h2><p>某天在 Github 网上冲浪的时候，偶然就看到了 <a href="https://github.com/qw4990">@qw4990</a> 大佬的数据库项目：<a href="https://github.com/qw4990/NYADB2">NYADB2</a>。这是一个用 golang 实现的一个简单的数据库，分层设计及其优秀，代码也便于阅读。出于对 Java 的念念不忘，我就依据这个项目的基本架构，写一个 Java 版的 DB，实现过程中，有许多细节都参照了这个项目。</p><p>令人汗颜的是，这个项目是作者本科的兴趣项目，也许这就是大佬吧（逃</p><p>RESPECT</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：</p><ol><li>Transaction Manager（TM）</li><li>Data Manager（DM）</li><li>Version Manager（VM）</li><li>Index Manager（IM）</li><li>Table Manager（TBM）</li></ol><p>五个模块的依赖关系如下：</p><p><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291847248.jpeg" alt="MYDB 模块依赖"><br>从这个依赖图中，拓扑排序一下就能看出实现顺序。本教程的实现顺序是 TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p><p>每个模块的职责如下：</p><ol><li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li><li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li><li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li><li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li><li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li></ol><h2 id="开发环境和运行示例"><a href="#开发环境和运行示例" class="headerlink" title="开发环境和运行示例"></a>开发环境和运行示例</h2><p>项目开发时使用的 WSL2 和 JDK11，如果要在 Windows 上执行，请替换启动参数中的路径为 Windows，JDK 版本要保证在 11 或以上，<strong>不兼容</strong> JDK 8。</p><p>首先执行以下命令以 &#x2F;tmp&#x2F;mydb 作为路径创建数据库：</p><pre><code>mvn exec:java -Dexec.mainClass=&quot;top.guoziyang.mydb.backend.Launcher&quot; -Dexec.args=&quot;-create /tmp/mydb&quot;</code></pre><p>本文原载于我的博客：<a href="https://ziyang.moe/article/mydb0.html">https://ziyang.moe/article/mydb0.html</a></p><p>项目地址：<a href="https://github.com/CN-GuoZiyang/MYDB">https://github.com/CN-GuoZiyang/MYDB</a></p><h2 id="前言（一些废话）-1"><a href="#前言（一些废话）-1" class="headerlink" title="前言（一些废话）"></a>前言（一些废话）</h2><p>或许是造轮子上瘾了，也有可能更有可能只是觉得需要补一补数据库的基本原理，大概花了大半个月，利用下班到半夜这段时间，我做完了这个项目。</p><p>和数据库也算有点渊源的，在学校开设数据库系统这门课的时候，我恰巧在深圳实习。于是乎，上网课成了我实习期间名正言顺的摸鱼理由，除了听课，其他啥都干。同样，操作系统也是在那个时候教授的，因为我对 OS 还是有点兴趣的，所以学得没有 DB 那么烂。</p><p>很快副作用就来了，字节二面的时候，面试官问我对数据库了解怎么样，本着坦诚清晰的原则，我说“一点也不了解”，于是又问我 redis 呢，我也只好说“也不了解”。好在面试官倒也没计较，还让我过了。就是不知道这俩“不知道”有没有拖烂我的面评……</p><p>工作之后，组里的内容和数据库倒也没有什么关系，本以为就此远离了数据库和 CRUD，没想到变化来得如此的快，隔壁资管组急缺人，向部门申请调人力支援，于是我就被弄过去支援了。资管对于一致性要求颇高，自然不能像原来一样，啥数据都往 redis 塞，没塞进去也没关系了……</p><h2 id="契机-1"><a href="#契机-1" class="headerlink" title="契机"></a>契机</h2><p>某天在 Github 网上冲浪的时候，偶然就看到了 <a href="https://github.com/qw4990">@qw4990</a> 大佬的数据库项目：<a href="https://github.com/qw4990/NYADB2">NYADB2</a>。这是一个用 golang 实现的一个简单的数据库，分层设计及其优秀，代码也便于阅读。出于对 Java 的念念不忘，我就依据这个项目的基本架构，写一个 Java 版的 DB，实现过程中，有许多细节都参照了这个项目。</p><p>令人汗颜的是，这个项目是作者本科的兴趣项目，也许这就是大佬吧（逃</p><p>RESPECT</p><h2 id="整体结构-1"><a href="#整体结构-1" class="headerlink" title="整体结构"></a>整体结构</h2><p>MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：</p><ol><li>Transaction Manager（TM）</li><li>Data Manager（DM）</li><li>Version Manager（VM）</li><li>Index Manager（IM）</li><li>Table Manager（TBM）</li></ol><p>五个模块的依赖关系如下：</p><p><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291847248.jpeg" alt="MYDB 模块依赖"><br>从这个依赖图中，拓扑排序一下就能看出实现顺序。本教程的实现顺序是 TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p><p>每个模块的职责如下：</p><ol><li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li><li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li><li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li><li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li><li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li></ol><h2 id="开发环境和运行示例-1"><a href="#开发环境和运行示例-1" class="headerlink" title="开发环境和运行示例"></a>开发环境和运行示例</h2><p>项目开发时使用的 WSL2 和 JDK11，如果要在 Windows 上执行，请替换启动参数中的路径为 Windows，JDK 版本要保证在 11 或以上，<strong>不兼容</strong> JDK 8。</p><p>首先执行以下命令以 &#x2F;tmp&#x2F;mydb 作为路径创建数据库：</p><pre><code>mvn exec:java -Dexec.mainClass=&quot;top.guoziyang.mydb.backend.Launcher&quot; -Dexec.args=&quot;-create /tmp/mydb&quot;</code></pre><p>随后通过以下命令以默认参数启动数据库服务：</p><pre><code>mvn exec:java -Dexec.mainClass=&quot;top.guoziyang.mydb.backend.Launcher&quot; -Dexec.args=&quot;-open /tmp/mydb&quot;</code></pre><p>这时数据库服务就已经启动在本机的 9999 端口。重新启动一个终端，执行以下命令启动客户端连接数据库：</p><pre><code>mvn exec:java -Dexec.mainClass=&quot;top.guoziyang.mydb.client.Launcher&quot;</code></pre><p>会启动一个交互式命令行，就可以在这里输入类 SQL 语法，回车会发送语句到服务，并输出执行的结果。</p><p>一个执行示例：<br><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291847249.png" alt="请添加图片描述"></p><p>随后通过以下命令以默认参数启动数据库服务：</p><pre><code>mvn exec:java -Dexec.mainClass=&quot;top.guoziyang.mydb.backend.Launcher&quot; -Dexec.args=&quot;-open /tmp/mydb&quot;</code></pre><p>这时数据库服务就已经启动在本机的 9999 端口。重新启动一个终端，执行以下命令启动客户端连接数据库：</p><pre><code>mvn exec:java -Dexec.mainClass=&quot;top.guoziyang.mydb.client.Launcher&quot;</code></pre><p>会启动一个交互式命令行，就可以在这里输入类 SQL 语法，回车会发送语句到服务，并输出执行的结果。</p><p>一个执行示例：<br><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291847249.png" alt="请添加图片描述"></p>]]></content>
    
    
    <summary type="html">一起写个数据库—0.项目结构和一些不得不说的话</summary>
    
    
    
    <category term="MYDB" scheme="http://ylcheng1789.github.io/categories/MYDB/"/>
    
    
    <category term="MySQL" scheme="http://ylcheng1789.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-AOP切面编程</title>
    <link href="http://ylcheng1789.github.io/2024/05/12/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://ylcheng1789.github.io/2024/05/12/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-12T08:18:17.000Z</published>
    <updated>2024-08-29T09:10:54.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-AOP基础"><a href="#1-AOP基础" class="headerlink" title="1. AOP基础"></a>1. AOP基础</h2><p>学习完spring的事务管理之后，接下来我们进入到AOP的学习。 AOP也是spring框架的第二大核心，我们先来学习AOP的基础。</p><p>在AOP基础这个阶段，我们首先介绍一下什么是AOP，再通过一个快速入门程序，让大家快速体验AOP程序的开发。最后再介绍AOP当中所涉及到的一些核心的概念。</p><h3 id="1-1-AOP概述"><a href="#1-1-AOP概述" class="headerlink" title="1.1 AOP概述"></a>1.1 AOP概述</h3><p>什么是AOP？</p><ul><li>AOP英文全称：Aspect Oriented Programming（面向切面编程、面向方面编程），其实说白了，面向切面编程就是面向特定方法编程。</li></ul><p>那什么又是面向方法编程呢，为什么又需要面向方法编程呢？来我们举个例子做一个说明：</p><p>比如，我们这里有一个项目，项目中开发了很多的业务功能。</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104855599-70d041ce-a181-4a3f-8199-c7a63c627b6d.png"></p><p>然而有一些业务功能执行效率比较低，执行耗时较长，我们需要针对于这些业务方法进行优化。 那首先第一步就需要定位出执行耗时比较长的业务方法，再针对于业务方法再来进行优化。</p><p>此时我们就需要统计当前这个项目当中每一个业务方法的执行耗时。那么统计每一个业务方法的执行耗时该怎么实现？</p><p>可能多数人首先想到的就是在每一个业务方法运行之前，记录这个方法运行的开始时间。在这个方法运行完毕之后，再来记录这个方法运行的结束时间。拿结束时间减去开始时间，不就是这个方法的执行耗时吗？</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104855725-f857e5a9-1996-4441-86c8-cfd1347bdbba.png"><br>以上分析的实现方式是可以解决需求问题的。但是对于一个项目来讲，里面会包含很多的业务模块，每个业务模块又包含很多增删改查的方法，如果我们要在每一个模块下的业务方法中，添加记录开始时间、结束时间、计算执行耗时的代码，就会让程序员的工作变得非常繁琐。</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104855829-9a430163-ef1e-4b11-b188-fedcd7a21e88.png"><br>而AOP面向方法编程，就可以做到在不改动这些原始方法的基础上，针对特定的方法进行功能的增强。</p><blockquote><p>AOP的作用：在程序运行期间在不修改源代码的基础上对已有方法进行增强（无侵入性: 解耦）</p></blockquote><p>我们要想完成统计各个业务方法执行耗时的需求，我们只需要定义一个模板方法，将记录方法执行耗时这一部分公共的逻辑代码，定义在模板方法当中，在这个方法开始运行之前，来记录这个方法运行的开始时间，在方法结束运行的时候，再来记录方法运行的结束时间，中间就来运行原始的业务方法。</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104855932-9c96f2ae-f948-4d11-8d65-c24a66f5290f.png"><br>而中间运行的原始业务方法，可能是其中的一个业务方法，比如：我们只想通过 部门管理的 list 方法的执行耗时，那就只有这一个方法是原始业务方法。  而如果，我们是先想统计所有部门管理的业务方法执行耗时，那此时，所有的部门管理的业务方法都是 原始业务方法。 <strong>那面向这样的指定的一个或多个方法进行编程，我们就称之为 面向切面编程。</strong></p><p>那此时，当我们再调用部门管理的 list 业务方法时啊，并不会直接执行 list 方法的逻辑，而是会执行我们所定义的 模板方法 ， 然后再模板方法中：</p><ul><li>记录方法运行开始时间</li><li>运行原始的业务方法（那此时原始的业务方法，就是 list 方法）</li><li>记录方法运行结束时间，计算方法执行耗时</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104856042-2626d21c-cb6a-48a5-a77d-99b539190c06.png"><br>不论，我们运行的是那个业务方法，最后其实运行的就是我们定义的模板方法，而在模板方法中，就完成了原始方法执行耗时的统计操作 。(那这样呢，我们就通过一个模板方法就完成了指定的一个或多个业务方法执行耗时的统计)</p><p>而大家会发现，这个流程，我们是不是似曾相识啊？</p><p>对了，就是和我们之前所学习的动态代理技术是非常类似的。 我们所说的模板方法，其实就是代理对象中所定义的方法，那代理对象中的方法以及根据对应的业务需要， 完成了对应的业务功能，当运行原始业务方法时，就会运行代理对象中的方法，从而实现统计业务方法执行耗时的操作。</p><p>其实，AOP面向切面编程和OOP面向对象编程一样，它们都仅仅是一种编程思想，而动态代理技术是这种思想最主流的实现方式。而Spring的AOP是Spring框架的高级技术，旨在管理bean对象的过程中底层使用动态代理机制，对特定的方法进行编程(功能增强)。</p><blockquote><p>AOP的优势：</p><ol><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ol></blockquote><h3 id="1-2-AOP快速入门"><a href="#1-2-AOP快速入门" class="headerlink" title="1.2 AOP快速入门"></a>1.2 AOP快速入门</h3><p>在了解了什么是AOP后，我们下面通过一个快速入门程序，体验下AOP的开发，并掌握Spring中AOP的开发步骤。</p><p><strong>需求：</strong>统计各个业务层方法执行耗时。</p><p><strong>实现步骤：</strong></p><ol><li>导入依赖：在pom.xml中导入AOP的依赖</li><li>编写AOP程序：针对于特定方法根据业务需要进行编程</li></ol><blockquote><p>为演示方便，可以自建新项目或导入提供的<code>springboot-aop-quickstart</code>项目工程</p></blockquote><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>AOP程序：TimeAspect</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//当前类为切面类</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//记录方法执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录方法执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算方法执行耗时</span></span><br><span class="line">        log.info(pjp.getSignature()+<span class="string">&quot;执行耗时: &#123;&#125;毫秒&quot;</span>,end-begin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动SpringBoot服务测试程序：</p><ul><li>查询3号部门信息</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104856159-864dc44b-c2bf-4d6d-9aee-3cba91412f1b.png"></p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104856278-6384883d-781a-4564-a869-e1b2745f5a9b.png"></p><blockquote><p>我们可以再测试下：查询所有部门信息（同样执行AOP程序）</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104856384-09f1e105-f091-4334-a275-64f8f9ac2c41.png"></p></blockquote><p>我们通过AOP入门程序完成了业务方法执行耗时的统计，那其实AOP的功能远不止于此，常见的应用场景如下：</p><ul><li>记录系统的操作日志</li><li>权限控制</li><li>事务管理：我们前面所讲解的Spring事务管理，底层其实也是通过AOP来实现的，只要添加@Transactional注解之后，AOP程序自动会在原始方法运行前先来开启事务，在原始方法运行完毕之后提交或回滚事务</li></ul><p>这些都是AOP应用的典型场景。</p><p>通过入门程序，我们也应该感受到了AOP面向切面编程的一些优势：</p><ul><li>代码无侵入：没有修改原始的业务方法，就已经对原始的业务方法进行了功能的增强或者是功能的改变 </li><li>减少了重复代码 </li><li>提高开发效率 </li><li>维护方便</li></ul><h3 id="1-3-AOP核心概念"><a href="#1-3-AOP核心概念" class="headerlink" title="1.3 AOP核心概念"></a>1.3 AOP核心概念</h3><p>通过SpringAOP的快速入门，感受了一下AOP面向切面编程的开发方式。下面我们再来学习AOP当中涉及到的一些核心概念。</p><p><strong>1. 连接点：JoinPoint</strong>，可以被AOP控制的方法（暗含方法执行时的相关信息）</p><pre><code>连接点指的是可以被aop控制的方法。例如：入门程序当中所有的业务方法都是可以被aop控制的方法。![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706104856530-87584748-a1cb-4c8b-ad78-798700d025c3.png#averageHue=%23fdd7d6&amp;id=YCiZK&amp;originHeight=593&amp;originWidth=614&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)在SpringAOP提供的JoinPoint当中，封装了连接点方法在执行时的相关信息。（后面会有具体的讲解）</code></pre><p><strong>2. 通知：Advice</strong>，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）</p><pre><code>在入门程序中是需要统计各个业务方法的执行耗时的，此时我们就需要在这些业务方法运行开始之前，先记录这个方法运行的开始时间，在每一个业务方法运行结束的时候，再来记录这个方法运行的结束时间。但是在AOP面向切面编程当中，我们只需要将这部分重复的代码逻辑抽取出来单独定义。抽取出来的这一部分重复的逻辑，也就是共性的功能。![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706104856655-cbf83365-e484-487b-8992-6b5e17c4e40a.png#averageHue=%23cceddb&amp;id=arddk&amp;originHeight=365&amp;originWidth=895&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)</code></pre><p><strong>3. 切入点：PointCut</strong>，匹配连接点的条件，通知仅会在切入点方法执行时被应用</p><pre><code>在通知当中，我们所定义的共性功能到底要应用在哪些方法上？此时就涉及到了切入点pointcut概念。切入点指的是匹配连接点的条件。通知仅会在切入点方法运行时才会被应用。在aop的开发当中，我们通常会通过一个切入点表达式来描述切入点(后面会有详解)。![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706104856760-a9cda4c5-9303-4a38-a731-42d066b94b1a.png#averageHue=%23cceddb&amp;id=cRcvX&amp;originHeight=386&amp;originWidth=890&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)假如：切入点表达式改为DeptServiceImpl.list()，此时就代表仅仅只有list这一个方法是切入点。只有list()方法在运行的时候才会应用通知。</code></pre><p><strong>4. 切面：Aspect</strong>，描述通知与切入点的对应关系（通知+切入点）</p><pre><code>当通知和切入点结合在一起，就形成了一个切面。通过切面就能够描述当前aop程序需要针对于哪个原始方法，在什么时候执行什么样的操作。![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706104856928-891fee85-6bb0-4b14-a17b-763dac0fa860.png#averageHue=%23e2dcb6&amp;id=ERZEv&amp;originHeight=468&amp;originWidth=966&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)切面所在的类，我们一般称为**切面类**（被@Aspect注解标识的类）</code></pre><p><strong>5. 目标对象：Target</strong>，通知所应用的对象</p><pre><code>目标对象指的就是通知所应用的对象，我们就称之为目标对象。![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706104857091-b54b27f4-3f73-42c4-956b-bc35d0862594.png#averageHue=%23fddad9&amp;id=U6gFT&amp;originHeight=630&amp;originWidth=636&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)</code></pre><p>AOP的核心概念我们介绍完毕之后，接下来我们再来分析一下我们所定义的通知是如何与目标对象结合在一起，对目标对象当中的方法进行功能增强的。</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857289-1203a2de-c045-4cdb-b025-d4d7c3763483.png"><br>Spring的AOP底层是基于动态代理技术来实现的，也就是说在程序运行的时候，会自动的基于动态代理技术为目标对象生成一个对应的代理对象。在代理对象当中就会对目标对象当中的原始方法进行功能的增强。</p><h2 id="2-AOP进阶"><a href="#2-AOP进阶" class="headerlink" title="2. AOP进阶"></a>2. AOP进阶</h2><p>AOP的基础知识学习完之后，下面我们对AOP当中的各个细节进行详细的学习。主要分为4个部分：</p><ol><li>通知类型</li><li>通知顺序</li><li>切入点表达式</li><li>连接点</li></ol><p>我们先来学习第一部分通知类型。</p><h3 id="2-1-通知类型"><a href="#2-1-通知类型" class="headerlink" title="2.1 通知类型"></a>2.1 通知类型</h3><p>在入门程序当中，我们已经使用了一种功能最为强大的通知类型：Around环绕通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//记录方法执行开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//执行原始方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="comment">//记录方法执行结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//计算方法执行耗时</span></span><br><span class="line">    log.info(pjp.getSignature()+<span class="string">&quot;执行耗时: &#123;&#125;毫秒&quot;</span>,end-begin);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只要我们在通知方法上加上了@Around注解，就代表当前通知是一个环绕通知。</p></blockquote><p>Spring中AOP的通知类型：</p><ul><li>@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</li><li>@Before：前置通知，此注解标注的通知方法在目标方法前被执行</li><li><a href="/After">@After </a> ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 </li><li><a href="/AfterReturning">@AfterReturning </a> ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 </li><li><a href="/AfterThrowing">@AfterThrowing </a> ： 异常后通知，此注解标注的通知方法发生异常后执行</li></ul><p>下面我们通过代码演示，来加深对于不同通知类型的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect1</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;around before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用目标对象的原始方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原始方法如果执行时有异常，环绕通知中的后置代码不会在执行了</span></span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;around after ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回后通知（程序在正常执行的情况下，会执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知（程序在出现异常的情况下，执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterThrowing ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动SpringBoot服务，进行测试：</p><p><strong>1. 没有异常情况下：</strong></p><ul><li>使用postman测试查询所有部门数据</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857403-13ec42d9-d7f8-4289-a93e-a3fcac19e549.png"></p><ul><li>查看idea中控制台日志输出</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857527-2825d422-39cd-4787-8871-4edb90114857.png"></p><blockquote><p>程序没有发生异常的情况下，@AfterThrowing标识的通知方法不会执行。</p></blockquote><p><strong>2. 出现异常情况下：</strong></p><p>修改DeptServiceImpl业务实现类中的代码： 添加异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Dept&gt; deptList = deptMapper.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deptList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动SpringBoot服务，测试发生异常情况下通知的执行：</p><ul><li>查看idea中控制台日志输出</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857667-fb1ec8a0-4e26-4e50-a1c3-deda0d25a12c.png"></p><blockquote><p>程序发生异常的情况下：</p><ul><li>@AfterReturning标识的通知方法不会执行，@AfterThrowing标识的通知方法执行了 </li><li>@Around环绕通知中原始方法调用时有异常，通知中的环绕后的代码逻辑也不会在执行了 （因为原始方法调用已经出异常了）</li></ul></blockquote><p>在使用通知时的注意事项：</p><ul><li>@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行</li><li>@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。</li></ul><p>五种常见的通知类型，我们已经测试完毕了，此时我们再来看一下刚才所编写的代码，有什么问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//后置通知</span></span><br><span class="line"><span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回后通知（程序在正常执行的情况下，会执行的后置通知）</span></span><br><span class="line"><span class="meta">@AfterReturning(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常通知（程序在出现异常的情况下，执行的后置通知）</span></span><br><span class="line"><span class="meta">@AfterThrowing(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure><p>我们发现啊，每一个注解里面都指定了切入点表达式，而且这些切入点表达式都一模一样。此时我们的代码当中就存在了大量的重复性的切入点表达式，假如此时切入点表达式需要变动，就需要将所有的切入点表达式一个一个的来改动，就变得非常繁琐了。</p><p>怎么来解决这个切入点表达式重复的问题？ 答案就是：<strong>抽取</strong></p><p>Spring提供了@PointCut注解，该注解的作用是将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切入点方法（公共的切入点表达式）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知（引用切入点）</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;around before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用目标对象的原始方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">//原始方法在执行时：发生异常</span></span><br><span class="line">        <span class="comment">//后续代码不在执行</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;around after ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回后通知（程序在正常执行的情况下，会执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知（程序在出现异常的情况下，执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterThrowing ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：当切入点方法使用private修饰时，仅能在当前切面类中引用该表达式， 当外部其他切面类中也要引用当前类中的切入点表达式，就需要把private改为public，而在引用的时候，具体的语法为：</p><p>全类名.方法名()，具体形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect2</span> &#123;</span><br><span class="line">    <span class="comment">//引用MyAspect1切面类中的切入点表达式</span></span><br><span class="line">    <span class="meta">@Before(&quot;com.itheima.aspect.MyAspect1.pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect2 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-通知顺序"><a href="#2-2-通知顺序" class="headerlink" title="2.2 通知顺序"></a>2.2 通知顺序</h3><p>讲解完了Spring中AOP所支持的5种通知类型之后，接下来我们再来研究通知的执行顺序。</p><p>当在项目开发当中，我们定义了多个切面类，而多个切面类中多个切入点都匹配到了同一个目标方法。此时当目标方法在运行的时候，这多个切面类当中的这些通知方法都会运行。</p><p>此时我们就有一个疑问，这多个通知方法到底哪个先运行，哪个后运行？ 下面我们通过程序来验证（这里呢，我们就定义两种类型的通知进行测试，一种是前置通知@Before，一种是后置通知@After）</p><p>定义多个切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect2</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect2 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect2 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect3</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect3 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect3 -&gt;  after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect4</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect4 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect4 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动SpringBoot服务，测试通知的执行顺序：</p><blockquote><p>备注：</p><ol><li>把DeptServiceImpl实现类中模拟异常的代码删除或注释掉。 </li><li>注释掉其他切面类(把@Aspect注释即可)，仅保留MyAspect2、MyAspect3、MyAspect4 ，这样就可以清晰看到执行的结果，而不被其他切面类干扰。</li></ol></blockquote><ul><li>使用postman测试查询所有部门数据</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857403-13ec42d9-d7f8-4289-a93e-a3fcac19e549.png"></p><ul><li>查看idea中控制台日志输出</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857773-5073aecb-c5ff-4ca1-86dd-9ed71a9acd20.png"></p><p>通过以上程序运行可以看出在不同切面类中，默认按照切面类的类名字母排序：</p><ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul><p>如果我们想控制通知的执行顺序有两种方式：</p><ol><li>修改切面类的类名（这种方式非常繁琐、而且不便管理）</li><li>使用Spring提供的@Order注解</li></ol><p>使用@Order注解，控制通知的执行顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(2)</span>  <span class="comment">//切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect2</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect2 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知 </span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect2 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(3)</span>  <span class="comment">//切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect3</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect3 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect3 -&gt;  after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">//切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect4</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect4 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect4 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动SpringBoot服务，测试通知执行顺序：</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857891-635c373b-284d-4a51-b4fb-82f646c24ad1.png"></p><blockquote><p>通知的执行顺序大家主要知道两点即可：</p><ol><li>不同的切面类当中，默认情况下通知的执行顺序是与切面类的类名字母排序是有关系的</li><li>可以在切面类上面加上@Order注解，来控制不同的切面类通知的执行顺序</li></ol></blockquote><h3 id="2-3-切入点表达式"><a href="#2-3-切入点表达式" class="headerlink" title="2.3 切入点表达式"></a>2.3 切入点表达式</h3><p>从AOP的入门程序到现在，我们一直都在使用切入点表达式来描述切入点。下面我们就来详细的介绍一下切入点表达式的具体写法。</p><p>切入点表达式：</p><ul><li>描述切入点方法的一种表达式 </li><li>作用：主要用来决定项目中的哪些方法需要加入通知 </li><li>常见形式： <ol><li>execution(……)：根据方法的签名来匹配</li></ol></li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104857994-9b31731c-b630-4bda-8749-4be55974d873.png"></p><ol start="2"><li>@annotation(……) ：根据注解匹配</li></ol><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104858144-ebdeb86c-c20e-4242-aa12-407aa3415c07.png"></p><p>首先我们先学习第一种最为常见的execution切入点表达式。</p><h4 id="2-3-1-execution"><a href="#2-3-1-execution" class="headerlink" title="2.3.1 execution"></a>2.3.1 execution</h4><p>execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws 异常?)</span><br></pre></td></tr></table></figure><p>其中带<code>?</code>的表示可以省略的部分</p><ul><li>访问修饰符：可省略（比如: public、protected） </li><li>包名.类名： 可省略 </li><li>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))&quot;)</span></span><br></pre></td></tr></table></figure><p>可以使用通配符描述切入点</p><ul><li><code>*</code> ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分 </li><li><code>..</code> ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</li></ul><p>切入点表达式的语法规则：</p><ol><li>方法的访问修饰符可以省略</li><li>返回值可以使用<code>*</code>号代替（任意返回值类型）</li><li>包名可以使用<code>*</code>号代替，代表任意包（一层包使用一个<code>*</code>）</li><li>使用<code>..</code>配置包名，标识此包以及此包下的所有子包</li><li>类名可以使用<code>*</code>号代替，标识任意类</li><li>方法名可以使用<code>*</code>号代替，表示任意方法</li><li>可以使用 <code>*</code>  配置参数，一个任意类型的参数</li><li>可以使用<code>..</code> 配置参数，任意个任意类型的参数</li></ol><p><strong>切入点表达式示例</strong></p><ul><li><p>省略方法的修饰符号 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替返回值类型 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替包名（一层包使用一个<code>*</code>） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.*.*.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>..</code>省略包名 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替类名 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替方法名 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.*(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>*</code> 代替参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.impl.DeptServiceImpl.delete(*))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>..</code>省略参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.*(..))</span><br></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ul><li>根据业务需要，可以使用 且（&amp;&amp;）、或（||）、非（!） 来组合比较复杂的切入点表达式。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.DeptService.list(..)) || execution(* com.itheima.service.DeptService.delete(..))</span><br></pre></td></tr></table></figure></li></ul><p>切入点表达式的书写建议：</p><ul><li>所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是update开头 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">findAllDept</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">findDeptById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">       <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDeptById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">       <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDeptByMoreCondition</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">       <span class="comment">//省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配DeptServiceImpl类中以find开头的方法</span></span><br><span class="line">execution(* com.itheima.service.impl.DeptServiceImpl.find*(..))</span><br></pre></td></tr></table></figure><ul><li><p>描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.DeptService.*(..))</span><br></pre></td></tr></table></figure></li><li><p>在满足业务需要的前提下，尽量缩小切入点的匹配范围。如：包名匹配尽量不使用 ..，使用 * 匹配单个包 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.*.*.DeptServiceImpl.find*(..))</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-2-annotation"><a href="#2-3-2-annotation" class="headerlink" title="2.3.2 @annotation "></a>2.3.2 <a href="/annotation">@annotation </a></h4><p>已经学习了execution切入点表达式的语法。那么如果我们要匹配多个无规则的方法，比如：list()和 delete()这两个方法。这个时候我们基于execution这种切入点表达式来描述就不是很方便了。而在之前我们是将两个切入点表达式组合在了一起完成的需求，这个是比较繁琐的。</p><p>我们可以借助于另一种切入点表达式annotation来描述这一类的切入点，从而来简化切入点表达式的书写。</p><p>实现步骤：</p><ol><li>编写自定义注解 </li><li>在业务类要做为连接点的方法上添加自定义注解</li></ol><p><strong>自定义注解</strong>：MyLog</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务类</strong>：DeptServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MyLog</span> <span class="comment">//自定义注解（表示：当前方法属于目标方法）</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Dept&gt; deptList = deptMapper.list();</span><br><span class="line">        <span class="comment">//模拟异常</span></span><br><span class="line">        <span class="comment">//int num = 10/0;</span></span><br><span class="line">        <span class="keyword">return</span> deptList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MyLog</span>  <span class="comment">//自定义注解（表示：当前方法属于目标方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 删除部门</span></span><br><span class="line">        deptMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        dept.setCreateTime(LocalDateTime.now());</span><br><span class="line">        dept.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        deptMapper.save(dept);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deptMapper.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        dept.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        deptMapper.update(dept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切面类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect6</span> &#123;</span><br><span class="line">    <span class="comment">//针对list方法、delete方法进行前置通知和后置通知</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.itheima.anno.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect6 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;@annotation(com.itheima.anno.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect6 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，测试查询所有部门数据，查看控制台日志：</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104858263-d9b42481-0e38-4466-9b40-07a515518239.png"></p><p>到此我们两种常见的切入点表达式我已经介绍完了。</p><ul><li>execution切入点表达式 <ul><li>根据我们所指定的方法的描述信息来匹配切入点方法，这种方式也是最为常用的一种方式</li><li>如果我们要匹配的切入点方法的方法名不规则，或者有一些比较特殊的需求，通过execution切入点表达式描述比较繁琐</li></ul></li><li>annotation 切入点表达式 <ul><li>基于注解的方式来匹配切入点方法。这种方式虽然多一步操作，我们需要自定义一个注解，但是相对来比较灵活。我们需要匹配哪个方法，就在方法上加上对应的注解就可以了</li></ul></li></ul><h3 id="2-4-连接点"><a href="#2-4-连接点" class="headerlink" title="2.4 连接点"></a>2.4 连接点</h3><p>讲解完了切入点表达式之后，接下来我们再来讲解最后一个部分连接点。我们前面在讲解AOP核心概念的时候，我们提到过什么是连接点，连接点可以简单理解为可以被AOP控制的方法。</p><p>我们目标对象当中所有的方法是不是都是可以被AOP控制的方法。而在SpringAOP当中，连接点又特指方法的执行。</p><p>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><ul><li>对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint类型 </li><li>对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.itheima.anno.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(joinPoint.getSignature().getName() + <span class="string">&quot; MyAspect7 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(joinPoint.getSignature().getName() + <span class="string">&quot; MyAspect7 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取目标类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pjp.getTarget().getClass().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标类名：&#123;&#125;&quot;</span>,name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pjp.getSignature().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法名：&#123;&#125;&quot;</span>,methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法执行时需要的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法参数：&#123;&#125;&quot;</span>, Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动SpringBoot服务，执行查询部门数据的功能：</p><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104858364-cae09b28-157a-448f-9796-03ed5039f156.png"></p><h2 id="3-AOP案例"><a href="#3-AOP案例" class="headerlink" title="3. AOP案例"></a>3. AOP案例</h2><p>SpringAOP的相关知识我们就已经全部学习完毕了。最后我们要通过一个案例来对AOP进行一个综合的应用。</p><h3 id="3-1-需求"><a href="#3-1-需求" class="headerlink" title="3.1 需求"></a>3.1 需求</h3><p>需求：将案例中增、删、改相关接口的操作日志记录到数据库表中</p><ul><li>就是当访问部门管理和员工管理当中的增、删、改相关功能接口时，需要详细的操作日志，并保存在数据表中，便于后期数据追踪。</li></ul><p>操作日志信息包含：</p><ul><li>操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</li></ul><blockquote><p>所记录的日志信息包括当前接口的操作人是谁操作的，什么时间点操作的，以及访问的是哪个类当中的哪个方法，在访问这个方法的时候传入进来的参数是什么，访问这个方法最终拿到的返回值是什么，以及整个接口方法的运行时长是多长时间。</p></blockquote><h3 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2 分析"></a>3.2 分析</h3><p>问题1：项目当中增删改相关的方法是不是有很多？</p><ul><li>很多</li></ul><p>问题2：我们需要针对每一个功能接口方法进行修改，在每一个功能接口当中都来记录这些操作日志吗？</p><ul><li>这种做法比较繁琐</li></ul><p>以上两个问题的解决方案：可以使用AOP解决(每一个增删改功能接口中要实现的记录操作日志的逻辑代码是相同)。</p><blockquote><p>可以把这部分记录操作日志的通用的、重复性的逻辑代码抽取出来定义在一个通知方法当中，我们通过AOP面向切面编程的方式，在不改动原始功能的基础上来对原始的功能进行增强。目前我们所增强的功能就是来记录操作日志，所以也可以使用AOP的技术来实现。使用AOP的技术来实现也是最为简单，最为方便的。</p></blockquote><p>问题3：既然要基于AOP面向切面编程的方式来完成的功能，那么我们要使用 AOP五种通知类型当中的哪种通知类型？</p><ul><li>答案：环绕通知</li></ul><blockquote><p>所记录的操作日志当中包括：操作人、操作时间，访问的是哪个类、哪个方法、方法运行时参数、方法的返回值、方法的运行时长。</p><p>方法返回值，是在原始方法执行后才能获取到的。</p><p>方法的运行时长，需要原始方法运行之前记录开始时间，原始方法运行之后记录结束时间。通过计算获得方法的执行耗时。</p><p>基于以上的分析我们确定要使用Around环绕通知。</p></blockquote><p>问题4：最后一个问题，切入点表达式我们该怎么写？</p><ul><li>答案：使用annotation来描述表达式</li></ul><blockquote><p>要匹配业务接口当中所有的增删改的方法，而增删改方法在命名上没有共同的前缀或后缀。此时如果使用execution切入点表达式也可以，但是会比较繁琐。 当遇到增删改的方法名没有规律时，就可以使用 annotation切入点表达式</p></blockquote><h3 id="3-3-步骤"><a href="#3-3-步骤" class="headerlink" title="3.3 步骤"></a>3.3 步骤</h3><p>简单分析了一下大概的实现思路后，接下来我们就要来完成案例了。案例的实现步骤其实就两步：</p><ul><li>准备工作 <ol><li>引入AOP的起步依赖</li><li>导入资料中准备好的数据库表结构，并引入对应的实体类</li></ol></li><li>编码实现 <ol><li>自定义注解<a href="/Log">@Log </a> </li><li>定义切面类，完成记录操作日志的逻辑</li></ol></li></ul><h3 id="3-4-实现"><a href="#3-4-实现" class="headerlink" title="3.4 实现"></a>3.4 实现</h3><h4 id="3-4-1-准备工作"><a href="#3-4-1-准备工作" class="headerlink" title="3.4.1 准备工作"></a>3.4.1 准备工作</h4><ol><li>AOP起步依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AOP起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>导入资料中准备好的数据库表结构，并引入对应的实体类</li></ol><p>数据表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 操作日志表</span><br><span class="line">create table operate_log(</span><br><span class="line">    id int unsigned primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    operate_user int unsigned comment &#x27;操作人&#x27;,</span><br><span class="line">    operate_time datetime comment &#x27;操作时间&#x27;,</span><br><span class="line">    class_name varchar(100) comment &#x27;操作的类名&#x27;,</span><br><span class="line">    method_name varchar(100) comment &#x27;操作的方法名&#x27;,</span><br><span class="line">    method_params varchar(1000) comment &#x27;方法参数&#x27;,</span><br><span class="line">    return_value varchar(2000) comment &#x27;返回值&#x27;,</span><br><span class="line">    cost_time bigint comment &#x27;方法执行耗时, 单位:ms&#x27;</span><br><span class="line">) comment &#x27;操作日志表&#x27;;</span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作日志实体类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateLog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id; <span class="comment">//主键ID</span></span><br><span class="line">    <span class="keyword">private</span> Integer operateUser; <span class="comment">//操作人ID</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime operateTime; <span class="comment">//操作时间</span></span><br><span class="line">    <span class="keyword">private</span> String className; <span class="comment">//操作类名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName; <span class="comment">//操作方法名</span></span><br><span class="line">    <span class="keyword">private</span> String methodParams; <span class="comment">//操作方法参数</span></span><br><span class="line">    <span class="keyword">private</span> String returnValue; <span class="comment">//操作方法返回值</span></span><br><span class="line">    <span class="keyword">private</span> Long costTime; <span class="comment">//操作耗时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OperateLogMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入日志数据</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into operate_log (operate_user, operate_time, class_name, method_name, method_params, return_value, cost_time) &quot; +</span></span><br><span class="line"><span class="meta">            &quot;values (#&#123;operateUser&#125;, #&#123;operateTime&#125;, #&#123;className&#125;, #&#123;methodName&#125;, #&#123;methodParams&#125;, #&#123;returnValue&#125;, #&#123;costTime&#125;);&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(OperateLog log)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-编码实现"><a href="#3-4-2-编码实现" class="headerlink" title="3.4.2 编码实现"></a>3.4.2 编码实现</h4><ul><li>自定义注解<a href="/Log">@Log </a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Log注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改业务实现类，在增删改业务方法上添加@Log注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Log</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now()); <span class="comment">//更新修改时间为当前时间</span></span><br><span class="line"></span><br><span class="line">        empMapper.update(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Log</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//补全数据</span></span><br><span class="line">        emp.setCreateTime(LocalDateTime.now());</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        <span class="comment">//调用添加方法</span></span><br><span class="line">        empMapper.insert(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Log</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(List&lt;Integer&gt; ids)</span> &#123;</span><br><span class="line">        empMapper.delete(ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以同样的方式，修改EmpServiceImpl业务类</p><ul><li>定义切面类，完成记录操作日志的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OperateLogMapper operateLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.itheima.anno.Log)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//操作人ID - 当前登录员工ID</span></span><br><span class="line">        <span class="comment">//获取请求头中的jwt令牌, 解析令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.parseJWT(jwt);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">operateUser</span> <span class="operator">=</span> (Integer) claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">operateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作方法参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodParams</span> <span class="operator">=</span> Arrays.toString(args);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//调用原始目标方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">returnValue</span> <span class="operator">=</span> JSONObject.toJSONString(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作耗时</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">costTime</span> <span class="operator">=</span> end - begin;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录操作日志</span></span><br><span class="line">        <span class="type">OperateLog</span> <span class="variable">operateLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperateLog</span>(<span class="literal">null</span>,operateUser,operateTime,className,methodName,methodParams,returnValue,costTime);</span><br><span class="line">        operateLogMapper.insert(operateLog);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;AOP记录操作日志: &#123;&#125;&quot;</span> , operateLog);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码实现细节： 获取request对象，从请求头中获取到jwt令牌，解析令牌获取出当前用户的id。</p></blockquote><p>重启SpringBoot服务，测试操作日志记录功能：</p><ul><li>添加一个新的部门</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104858468-c9a6a6c9-f7b2-48ee-9172-4b2a1e415105.png"></p><ul><li>数据表</li></ul><p><img src="/./img/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/1706104858577-0808df11-8784-4677-a481-682a2b8e1069.png"></p>]]></content>
    
    
    <summary type="html">SpringBoot-AOP切面编程</summary>
    
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/tags/SpringBoot/"/>
    
    <category term="Java开发" scheme="http://ylcheng1789.github.io/tags/Java%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-事务管理</title>
    <link href="http://ylcheng1789.github.io/2024/05/11/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://ylcheng1789.github.io/2024/05/11/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2024-05-11T03:44:53.000Z</published>
    <updated>2024-08-29T09:11:29.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-事务管理"><a href="#1-事务管理" class="headerlink" title="1. 事务管理"></a>1. 事务管理</h2><h3 id="1-1-事务回顾"><a href="#1-1-事务回顾" class="headerlink" title="1.1 事务回顾"></a>1.1 事务回顾</h3><p>在数据库阶段我们已学习过事务了，我们讲到：</p><p><strong>事务</strong>是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么同时成功，要么同时失败。</p><p>怎么样来控制这组操作，让这组操作同时成功或同时失败呢？此时就要涉及到事务的具体操作了。</p><p>事务的操作主要有三步：</p><ol><li>开启事务（一组操作开始前，开启事务）：start transaction &#x2F; begin ;</li><li>提交事务（这组操作全部成功后，提交事务）：commit ;</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ;</li></ol><h3 id="1-2-Spring事务管理"><a href="#1-2-Spring事务管理" class="headerlink" title="1.2 Spring事务管理"></a>1.2 Spring事务管理</h3><h4 id="1-2-1-案例"><a href="#1-2-1-案例" class="headerlink" title="1.2.1 案例"></a>1.2.1 案例</h4><p>简单的回顾了事务的概念以及事务的基本操作之后，接下来我们看一个事务管理案例：解散部门 （解散部门就是删除部门）</p><p>需求：当部门解散了不仅需要把部门信息删除了，还需要把该部门下的员工数据也删除了。</p><p>步骤：</p><ul><li>根据ID删除部门数据</li><li>根据部门ID删除该部门下的员工</li></ul><p>代码实现：</p><ol><li>DeptServiceImpl</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据部门id，删除部门信息及部门下的所有员工</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="comment">//根据部门id删除部门信息</span></span><br><span class="line">        deptMapper.deleteById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除部门下的所有员工信息</span></span><br><span class="line">        empMapper.deleteByDeptId(id);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>DeptMapper</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除部门信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id   部门id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from dept where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>EmpMapper</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据部门id删除部门下所有员工</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from emp where dept_id=#&#123;deptId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteByDeptId</span><span class="params">(Integer deptId)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，使用postman测试部门删除：</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853218-7685a24f-4874-44ce-bf2c-012ebcc44789.png"></p><p>代码正常情况下，dept表和Em表中的数据已删除</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853354-bf8d25fd-f966-4970-8777-52d0898f3a04.png"></p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853539-379b334e-a005-4d4d-93e8-77a929581816.png"></p><p>修改DeptServiceImpl类中代码，添加可能出现异常的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据部门id，删除部门信息及部门下的所有员工</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="comment">//根据部门id删除部门信息</span></span><br><span class="line">        deptMapper.deleteById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟：异常发生</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除部门下的所有员工信息</span></span><br><span class="line">        empMapper.deleteByDeptId(id);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，使用postman测试部门删除：</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853655-0b253962-52c1-411c-b143-4e541ab220f8.png"></p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853767-f098c8e4-b8cb-444d-810c-1c948db46031.png"></p><p>查看数据库表：</p><ul><li>删除了2号部门</li></ul><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853873-8dd3ff91-5530-4f6a-8264-0a7952715380.png"></p><ul><li>2号部门下的员工数据没有删除</li></ul><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853539-379b334e-a005-4d4d-93e8-77a929581816.png"></p><p><strong>以上程序出现的问题：即使程序运行抛出了异常，部门依然删除了，但是部门下的员工却没有删除，造成了数据的不一致。</strong></p><h4 id="1-2-2-原因分析"><a href="#1-2-2-原因分析" class="headerlink" title="1.2.2 原因分析"></a>1.2.2 原因分析</h4><p>原因：</p><ul><li>先执行根据id删除部门的操作，这步执行完毕，数据库表 dept 中的数据就已经删除了。</li><li>执行 1&#x2F;0 操作，抛出异常</li><li>抛出异常之前，下面所有的代码都不会执行了，根据部门ID删除该部门下的员工，这个操作也不会执行 。</li></ul><p>此时就出现问题了，部门删除了，部门下的员工还在，业务操作前后数据不一致。</p><p>而要想保证操作前后，数据的一致性，就需要让解散部门中涉及到的两个业务操作，要么全部成功，要么全部失败 。 那我们如何，让这两个操作要么全部成功，要么全部失败呢 ？</p><p>那就可以通过事务来实现，因为一个事务中的多个业务操作，要么全部成功，要么全部失败。</p><p>此时，我们就需要在delete删除业务功能中添加事务。</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853987-52851c4f-244a-4c4d-8440-dec89963cc93.png"></p><p>在方法运行之前，开启事务，如果方法成功执行，就提交事务，如果方法执行的过程当中出现异常了，就回滚事务。</p><p>思考：开发中所有的业务操作，一旦我们要进行控制事务，是不是都是这样的套路？</p><p>答案：是的。</p><p>所以在spring框架当中就已经把事务控制的代码都已经封装好了，并不需要我们手动实现。我们使用了spring框架，我们只需要通过一个简单的注解@Transactional就搞定了。</p><h4 id="1-2-3-Transactional注解"><a href="#1-2-3-Transactional注解" class="headerlink" title="1.2.3 Transactional注解"></a>1.2.3 Transactional注解</h4><blockquote><p>@Transactional作用：就是在当前这个方法执行开始之前来开启事务，方法执行完毕之后提交事务。如果在这个方法执行的过程当中出现了异常，就会进行事务的回滚操作。</p><p>@Transactional注解：我们一般会在业务层当中来控制事务，因为在业务层当中，一个业务功能可能会包含多个数据访问的操作。在业务层来控制事务，我们就可以将多个数据访问操作控制在一个事务范围内。</p></blockquote><p>@Transactional注解书写位置：</p><ul><li>方法 <ul><li>当前方法交给spring进行事务管理</li></ul></li><li>类 <ul><li>当前类中所有的方法都交由spring进行事务管理</li></ul></li><li>接口 <ul><li>接口下所有的实现类当中所有的方法都交给spring 进行事务管理</li></ul></li></ul><p>接下来，我们就可以在业务方法delete上加上 <a href="/Transactional">@Transactional </a> 来控制事务 。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>  <span class="comment">//当前方法添加了事务管理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="comment">//根据部门id删除部门信息</span></span><br><span class="line">        deptMapper.deleteById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟：异常发生</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除部门下的所有员工信息</span></span><br><span class="line">        empMapper.deleteByDeptId(id);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务功能上添加@Transactional注解进行事务管理后，我们重启SpringBoot服务，使用postman测试：</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854098-da304cee-3ffc-4c61-8532-985a60193665.png"></p><p>添加Spring事务管理后，由于服务端程序引发了异常，所以事务进行回滚。</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854193-4eff5b65-badd-43c3-a046-6443c1ad9a95.png"></p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854308-8bf0fffa-5b83-4b37-b0e7-e7ff6ea7a127.png"></p><p>说明：可以在application.yml配置文件中开启事务管理日志，这样就可以在控制看到和事务相关的日志信息了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#spring事务管理日志</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.jdbc.support.JdbcTransactionManager:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="1-3-事务进阶"><a href="#1-3-事务进阶" class="headerlink" title="1.3 事务进阶"></a>1.3 事务进阶</h3><p>前面我们通过spring事务管理注解@Transactional已经控制了业务层方法的事务。接下来我们要来详细的介绍一下@Transactional事务管理注解的使用细节。我们这里主要介绍@Transactional注解当中的两个常见的属性：</p><ol><li>异常回滚的属性：rollbackFor</li><li>事务传播行为：propagation</li></ol><p>我们先来学习下rollbackFor属性。</p><h4 id="1-3-1-rollbackFor"><a href="#1-3-1-rollbackFor" class="headerlink" title="1.3.1 rollbackFor"></a>1.3.1 rollbackFor</h4><p>我们在之前编写的业务方法上添加了@Transactional注解，来实现事务管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="comment">//根据部门id删除部门信息</span></span><br><span class="line">        deptMapper.deleteById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟：异常发生</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除部门下的所有员工信息</span></span><br><span class="line">        empMapper.deleteByDeptId(id);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上业务功能delete()方法在运行时，会引发除0的算数运算异常(运行时异常)，出现异常之后，由于我们在方法上加了@Transactional注解进行事务管理，所以发生异常会执行rollback回滚操作，从而保证事务操作前后数据是一致的。</p><p>下面我们在做一个测试，我们修改业务功能代码，在模拟异常的位置上直接抛出Exception异常（编译时异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//根据部门id删除部门信息</span></span><br><span class="line">        deptMapper.deleteById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟：异常发生</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;出现异常了~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除部门下的所有员工信息</span></span><br><span class="line">        empMapper.deleteByDeptId(id);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：在service中向上抛出一个Exception编译时异常之后，由于是controller调用service，所以在controller中要有异常处理代码，此时我们选择在controller中继续把异常向上抛。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/depts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="comment">//日志记录</span></span><br><span class="line">     log.info(<span class="string">&quot;根据id删除部门&quot;</span>);</span><br><span class="line">     <span class="comment">//调用service层功能</span></span><br><span class="line">     deptService.delete(id);</span><br><span class="line">     <span class="comment">//响应</span></span><br><span class="line">     <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务后测试：</p><p>抛出异常之后事务会不会回滚</p><blockquote><p>现有表中数据：</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104853873-8dd3ff91-5530-4f6a-8264-0a7952715380.png"></p></blockquote><p>使用postman测试，删除5号部门</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854433-887919a3-152e-4411-9877-3c0e7ea9b30e.png"></p><p>发生了Exception异常，但事务依然提交了</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854574-cba749d5-c13d-495c-b194-360361874b7d.png"></p><blockquote><p>dept表中数据：</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854690-4d497dad-3d7b-4069-a518-f45d5f3ef18a.png"></p></blockquote><p>通过以上测试可以得出一个结论：默认情况下，只有出现RuntimeException(运行时异常)才会回滚事务。</p><p>假如我们想让所有的异常都回滚，需要来配置@Transactional注解当中的rollbackFor属性，通过rollbackFor这个属性可以指定出现何种异常类型回滚事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="comment">//根据部门id删除部门信息</span></span><br><span class="line">        deptMapper.deleteById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模拟：异常发生</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> id/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除部门下的所有员工信息</span></span><br><span class="line">        empMapper.deleteByDeptId(id);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们重新启动服务，测试删除部门的操作：</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854794-102e812a-04ec-43ea-af7c-07a0df35963b.png"></p><p>控制台日志：执行了删除3号部门的操作， 因为异常又进行了事务回滚</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854900-1bac0b55-b418-4f9d-afe0-e31e1ec2e17f.png"></p><p>数据表：3号部门没有删除</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104854308-8bf0fffa-5b83-4b37-b0e7-e7ff6ea7a127.png"></p><blockquote><p>结论：</p><ul><li>在Spring的事务管理中，默认只有运行时异常 RuntimeException才会回滚。</li><li>如果还需要回滚指定类型的异常，可以通过rollbackFor属性来指定。</li></ul></blockquote><h4 id="1-3-3-propagation"><a href="#1-3-3-propagation" class="headerlink" title="1.3.3 propagation"></a>1.3.3 propagation</h4><h5 id="1-3-3-1-介绍"><a href="#1-3-3-1-介绍" class="headerlink" title="1.3.3.1 介绍"></a>1.3.3.1 介绍</h5><p>我们接着继续学习@Transactional注解当中的第二个属性propagation，这个属性是用来配置事务的传播行为的。</p><p>什么是事务的传播行为呢？</p><ul><li>就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。</li></ul><p>例如：两个事务方法，一个A方法，一个B方法。在这两个方法上都添加了@Transactional注解，就代表这两个方法都具有事务，而在A方法当中又去调用了B方法。</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104855025-6cae1bda-0f86-4493-8f69-d80269b802be.png"></p><p>所谓事务的传播行为，指的就是在A方法运行的时候，首先会开启一个事务，在A方法当中又调用了B方法， B方法自身也具有事务，那么B方法在运行的时候，到底是加入到A方法的事务当中来，还是B方法在运行的时候新建一个事务？这个就涉及到了事务的传播行为。</p><p>我们要想控制事务的传播行为，在@Transactional注解的后面指定一个属性propagation，通过 propagation 属性来指定传播行为。接下来我们就来介绍一下常见的事务传播行为。</p><table><thead><tr><th><strong>属性值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>REQUIRED</td><td>【默认值】需要事务，有则加入，无则创建新事务</td></tr><tr><td>REQUIRES_NEW</td><td>需要新事务，无论有无，总是创建新事务</td></tr><tr><td>SUPPORTS</td><td>支持事务，有则加入，无则在无事务状态中运行</td></tr><tr><td>NOT_SUPPORTED</td><td>不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务</td></tr><tr><td>MANDATORY</td><td>必须有事务，否则抛异常</td></tr><tr><td>NEVER</td><td>必须没事务，否则抛异常</td></tr><tr><td>…</td><td></td></tr></tbody></table><blockquote><p>对于这些事务传播行为，我们只需要关注以下两个就可以了：</p><ol><li>REQUIRED（默认值）</li><li>REQUIRES_NEW</li></ol></blockquote><h5 id="1-3-3-2-案例"><a href="#1-3-3-2-案例" class="headerlink" title="1.3.3.2 案例"></a>1.3.3.2 案例</h5><p>接下来我们就通过一个案例来演示下事务传播行为propagation属性的使用。</p><p><strong>需求：</strong>解散部门时需要记录操作日志</p><pre><code>        由于解散部门是一个非常重要而且非常危险的操作，所以在业务当中要求每一次执行解散部门的操作都需要留下痕迹，就是要记录操作日志。而且还要求无论是执行成功了还是执行失败了，都需要留下痕迹。</code></pre><p><strong>步骤：</strong></p><ol><li>执行解散部门的业务：先删除部门，再删除部门下的员工（前面已实现）</li><li>记录解散部门的日志，到日志表（未实现）</li></ol><p><strong>准备工作：</strong></p><ol><li>创建数据库表 dept_log 日志表：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table dept_log(</span><br><span class="line">   id int auto_increment comment &#x27;主键ID&#x27; primary key,</span><br><span class="line">    create_time datetime null comment &#x27;操作时间&#x27;,</span><br><span class="line">    description varchar(300) null comment &#x27;操作描述&#x27;</span><br><span class="line">)comment &#x27;部门操作日志表&#x27;;</span><br></pre></td></tr></table></figure><ol start="2"><li>引入资料中提供的实体类：DeptLog</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptLog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>引入资料中提供的Mapper接口：DeptLogMapper</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptLogMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into dept_log(create_time,description) values(#&#123;createTime&#125;,#&#123;description&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(DeptLog log)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>引入资料中提供的业务接口：DeptLogService</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptLogService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(DeptLog deptLog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>引入资料中提供的业务实现类：DeptLogServiceImpl</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptLogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptLogMapper deptLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">//事务传播行为：有事务就加入、没有事务就新建事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(DeptLog deptLog)</span> &#123;</span><br><span class="line">        deptLogMapper.insert(deptLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现:</strong></p><p>业务实现类：DeptServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">//@Transactional //当前业务实现类中的所有的方法，都添加了spring事务管理机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptLogService deptLogService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据部门id，删除部门信息及部门下的所有员工</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Log</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据部门id删除部门信息</span></span><br><span class="line">            deptMapper.deleteById(id);</span><br><span class="line">            <span class="comment">//模拟：异常</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;出现异常了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除部门下的所有员工信息</span></span><br><span class="line">            empMapper.deleteByDeptId(id);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//不论是否有异常，最终都要执行的代码：记录日志</span></span><br><span class="line">            <span class="type">DeptLog</span> <span class="variable">deptLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptLog</span>();</span><br><span class="line">            deptLog.setCreateTime(LocalDateTime.now());</span><br><span class="line">            deptLog.setDescription(<span class="string">&quot;执行了解散部门的操作，此时解散的是&quot;</span>+id+<span class="string">&quot;号部门&quot;</span>);</span><br><span class="line">            <span class="comment">//调用其他业务类中的方法</span></span><br><span class="line">            deptLogService.insert(deptLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试:</strong></p><p>重新启动SpringBoot服务，测试删除3号部门后会发生什么？</p><ul><li>执行了删除3号部门操作</li><li>执行了插入部门日志操作</li><li>程序发生Exception异常</li><li>执行事务回滚（删除、插入操作因为在一个事务范围内，两个操作都会被回滚）</li></ul><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104855160-07a55265-83fd-4a0b-8157-43edd68a23d7.png"></p><p>然后在dept_log表中没有记录日志数据</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104855255-e9ec2b26-28bd-46c9-9bd5-b2e1a5b184c9.png"></p><p><strong>原因分析:</strong></p><p>接下来我们就需要来分析一下具体是什么原因导致的日志没有成功的记录。</p><ul><li>在执行delete操作时开启了一个事务 </li><li>当执行insert操作时，insert设置的事务传播行是默认值REQUIRED，表示有事务就加入，没有则新建事务 </li><li>此时：delete和insert操作使用了同一个事务，同一个事务中的多个操作，要么同时成功，要么同时失败，所以当异常发生时进行事务回滚，就会回滚delete和insert操作</li></ul><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104855357-30d78f43-675e-4fd1-8aec-558a914face4.png"></p><p><strong>解决方案：</strong></p><p>在DeptLogServiceImpl类中insert方法上，添加<a href="/Transactional(propagation">@Transactional(propagation </a> &#x3D; Propagation.REQUIRES_NEW) </p><blockquote><p>Propagation.REQUIRES_NEW  ：不论是否有事务，都创建新事务  ，运行在一个独立的事务中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptLogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptLogMapper deptLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><span class="comment">//事务传播行为：不论是否有事务，都新建事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(DeptLog deptLog)</span> &#123;</span><br><span class="line">        deptLogMapper.insert(deptLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，再次测试删除3号部门：</p><p><img src="/./img/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/1706104855464-b402faf7-9f87-4c1e-a579-95d744624d6a.png"></p><p>那此时，DeptServiceImpl中的delete方法运行时，会开启一个事务。 当调用  deptLogService.insert(deptLog)  时，也会创建一个新的事务，那此时，当insert方法运行完毕之后，事务就已经提交了。 即使外部的事务出现异常，内部已经提交的事务，也不会回滚了，因为是两个独立的事务。</p><p>到此事务传播行为已演示完成，事务的传播行为我们只需要掌握两个：REQUIRED、REQUIRES_NEW。</p><blockquote><ul><li>REQUIRED ：大部分情况下都是用该传播行为即可。 </li><li>REQUIRES_NEW ：当我们不希望事务之间相互影响时，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。</li></ul></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">SpringBoot-事务管理</summary>
    
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/tags/SpringBoot/"/>
    
    <category term="Java开发" scheme="http://ylcheng1789.github.io/tags/Java%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-全局异常处理器</title>
    <link href="http://ylcheng1789.github.io/2024/05/10/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://ylcheng1789.github.io/2024/05/10/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2024-05-10T13:18:17.000Z</published>
    <updated>2024-08-29T09:11:21.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1. 异常处理"></a>1. 异常处理</h2><h3 id="1-1-当前问题"><a href="#1-1-当前问题" class="headerlink" title="1.1 当前问题"></a>1.1 当前问题</h3><p>异常处理。首先我们先来看一下系统出现异常之后会发生什么现象，再来介绍异常处理的方案。</p><p>我们打开浏览器，访问系统中的新增部门操作，系统中已经有了 “就业部” 这个部门，我们再来增加一个就业部，看看会发生什么现象。</p><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105170529-9b6f57ae-f36a-4009-8a1d-811e848a835b.png"><br>点击确定之后，窗口关闭了，页面没有任何反应，就业部也没有添加上。 而此时，大家会发现，网络请求报错了。</p><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105170620-606cf096-60ec-4b11-a150-026b78e203ba.png"><br>状态码为500，表示服务器端异常，我们打开idea，来看一下，服务器端出了什么问题。</p><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105170711-82631c8c-aa77-4c10-92ff-74d093b5f481.png"></p><p>上述错误信息的含义是，dept部门表的name字段的值 就业部 重复了，因为在数据库表dept中已经有了就业部，我们之前设计这张表时，为name字段建议了唯一约束，所以该字段的值是不能重复的。</p><p>而当我们再添加就业部，这个部门时，就违反了唯一约束，此时就会报错。</p><p>我们来看一下出现异常之后，最终服务端给前端响应回来的数据长什么样。</p><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105170865-344d7948-f4b6-4760-a159-77bed6ec3d46.png"></p><p>响应回来的数据是一个JSON格式的数据。但这种JSON格式的数据还是我们开发规范当中所提到的统一响应结果Result吗？显然并不是。由于返回的数据不符合开发规范，所以前端并不能解析出响应的JSON数据。</p><p>接下来我们需要思考的是出现异常之后，当前案例项目的异常是怎么处理的？</p><ul><li>答案：没有做任何的异常处理</li></ul><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105170961-4bb3041d-cd6b-4ce0-ad95-a5e23fd48fb8.png"></p><p>当我们没有做任何的异常处理时，我们三层架构处理异常的方案：</p><ul><li>Mapper接口在操作数据库的时候出错了，此时异常会往上抛(谁调用Mapper就抛给谁)，会抛给service。</li><li>service 中也存在异常了，会抛给controller。</li><li>而在controller当中，我们也没有做任何的异常处理，所以最终异常会再往上抛。最终抛给框架之后，框架就会返回一个JSON格式的数据，里面封装的就是错误的信息，但是框架返回的JSON格式的数据并不符合我们的开发规范。</li></ul><h3 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h3><p>那么在三层构架项目中，出现了异常，该如何处理?</p><ul><li>方案一：在所有Controller的所有方法中进行try…catch处理 <ul><li>缺点：代码臃肿（不推荐）</li></ul></li><li>方案二：全局异常处理器 <ul><li>好处：简单、优雅（推荐）</li></ul></li></ul><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105171060-b6a3ef29-5ca3-470c-87de-adc1ed72404d.png"></p><h3 id="1-3-全局异常处理器"><a href="#1-3-全局异常处理器" class="headerlink" title="1.3 全局异常处理器"></a>1.3 全局异常处理器</h3><p>我们该怎么样定义全局异常处理器？</p><ul><li>定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。</li><li>在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span> <span class="comment">//指定能够处理的异常类型</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();<span class="comment">//打印堆栈中的异常信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//捕获到异常之后，响应一个标准的Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起,操作失败,请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="/RestControllerAdvice">@RestControllerAdvice </a> &#x3D; <a href="/ControllerAdvice">@ControllerAdvice </a> + <a href="/ResponseBody">@ResponseBody </a> </p><p>处理异常的方法返回值会转换为json后再响应给前端</p></blockquote><p>重新启动SpringBoot服务，打开浏览器，再来测试一下添加部门这个操作，我们依然添加已存在的 “就业部” 这个部门：</p><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105171183-eb407579-2a09-4ccb-8770-07e0a1673552.png"></p><p><img src="/./img/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/1706105171280-e7dd5e22-7297-4081-8f5a-b74ee87dffb1.png"></p><p>此时，我们可以看到，出现异常之后，异常已经被全局异常处理器捕获了。然后返回的错误信息，被前端程序正常解析，然后提示出了对应的错误提示信息。</p><p>以上就是全局异常处理器的使用，主要涉及到两个注解：</p><ul><li><a href="/RestControllerAdvice">@RestControllerAdvice </a>  &#x2F;&#x2F;表示当前类为全局异常处理器 </li><li><a href="/ExceptionHandler">@ExceptionHandler </a>  &#x2F;&#x2F;指定可以捕获哪种类型的异常进行处理</li></ul>]]></content>
    
    
    <summary type="html">SpringBoot-全局异常处理器</summary>
    
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/tags/SpringBoot/"/>
    
    <category term="Java开发" scheme="http://ylcheng1789.github.io/tags/Java%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-过滤器拦截器</title>
    <link href="http://ylcheng1789.github.io/2024/05/10/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://ylcheng1789.github.io/2024/05/10/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2024-05-10T12:08:17.000Z</published>
    <updated>2024-08-29T09:11:11.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h1><p>刚才通过浏览器的开发者工具，我们可以看到在后续的请求当中，都会在请求头中携带JWT令牌到服务端，而服务端需要统一拦截所有的请求，从而判断是否携带的有合法的JWT令牌。<br>那怎么样来统一拦截到所有的请求校验令牌的有效性呢？这里我们会学习两种解决方案：</p><ol><li>Filter过滤器</li><li>Interceptor拦截器</li></ol><p>我们首先来学习过滤器Filter。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>什么是Filter？</p><ul><li>Filter表示过滤器，是 JavaWeb三大组件(Servlet、Filter、Listener)之一。</li><li>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能 <ul><li>使用了过滤器之后，要想访问web服务器上的资源，必须先经过滤器，过滤器处理完毕之后，才可以访问对应的资源。</li></ul></li><li>过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。</li></ul><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168198-59fdf6f4-f1f6-4a65-ab84-406a5eb15990.png"></p><p>下面我们通过Filter快速入门程序掌握过滤器的基本使用操作：</p><ul><li>第1步，定义过滤器 ：1.定义一个类，实现 Filter 接口，并重写其所有方法。</li><li>第2步，配置过滤器：Filter类上加 <a href="/WebFilter">@WebFilter </a> 注解，配置拦截资源的路径。引导类上加 <a href="/ServletComponentScan">@ServletComponentScan </a> 开启Servlet组件支持。</li></ul><p><strong>定义过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类，实现一个标准的Filter过滤器的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//初始化方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 初始化方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//拦截到请求之后调用, 调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo 拦截到了请求...放行前逻辑&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//销毁方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy 销毁方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>init方法：过滤器的初始化方法。在web服务器启动的时候会自动的创建Filter过滤器对象，在创建过滤器对象的时候会自动调用init初始化方法，这个方法只会被调用一次。 </li><li>doFilter方法：这个方法是在每一次拦截到请求之后都会被调用，所以这个方法是会被调用多次的，每拦截到一次请求就会调用一次doFilter()方法。 </li><li>destroy方法： 是销毁的方法。当我们关闭服务器的时候，它会自动的调用销毁方法destroy，而这个销毁方法也只会被调用一次。</li></ul></blockquote><p>在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：@WebFilter，并指定属性urlPatterns，通过这个属性指定过滤器要拦截哪些请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="comment">//配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//初始化方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 初始化方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//拦截到请求之后调用, 调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo 拦截到了请求...放行前逻辑&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//销毁方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy 销毁方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TliasWebManagementApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TliasWebManagementApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务，打开浏览器，执行部门管理的请求，可以看到控制台输出了过滤器中的内容：</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168282-ce7afe5e-695b-416f-bb7b-23f715d1315e.png"></p><blockquote><p>注意事项：</p><pre><code>在过滤器Filter中，如果不执行放行操作，将无法访问后面的资源。 放行操作：chain.doFilter(request, response);</code></pre></blockquote><p>现在我们已完成了Filter过滤器的基本使用，下面我们将学习Filter过滤器在使用过程中的一些细节。</p><h2 id="Filter详解"><a href="#Filter详解" class="headerlink" title="Filter详解"></a>Filter详解</h2><p>Filter过滤器的快速入门程序我们已经完成了，接下来我们就要详细的介绍一下过滤器Filter在使用中的一些细节。主要介绍以下3个方面的细节：</p><ol><li>过滤器的执行流程</li><li>过滤器的拦截路径配置</li><li>过滤器链</li></ol><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>首先我们先来看下过滤器的执行流程：</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168373-e62904f3-06fe-4afb-bf2e-b77d7cb640a1.png"></p><p>过滤器当中我们拦截到了请求之后，如果希望继续访问后面的web资源，就要执行放行操作，放行就是调用 FilterChain对象当中的doFilter()方法，在调用doFilter()这个方法之前所编写的代码属于放行之前的逻辑。</p><p>在放行后访问完 web 资源之后还会回到过滤器当中，回到过滤器之后如有需求还可以执行放行之后的逻辑，放行之后的逻辑我们写在doFilter()这行代码之后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//初始化方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 初始化方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行前逻辑.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行请求</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行后逻辑.....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//销毁方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy 销毁方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168463-1770a831-ae68-4014-b890-4acf3736bba5.png"></p><h3 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h3><p>执行流程我们搞清楚之后，接下来再来介绍一下过滤器的拦截路径，Filter可以根据需求，配置不同的拦截资源路径：</p><table><thead><tr><th>拦截路径</th><th>urlPatterns值</th><th>含义</th></tr></thead><tbody><tr><td>拦截具体路径</td><td>&#x2F;login</td><td>只有访问 &#x2F;login 路径时，才会被拦截</td></tr><tr><td>目录拦截</td><td>&#x2F;emps&#x2F;*</td><td>访问&#x2F;emps下的所有资源，都会被拦截</td></tr><tr><td>拦截所有</td><td>&#x2F;*</td><td>访问所有资源，都会被拦截</td></tr></tbody></table><p>下面我们来测试”拦截具体路径”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/login&quot;)</span>  <span class="comment">//拦截/login具体路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行前逻辑.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行请求</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行后逻辑.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试1：访问部门管理请求，发现过滤器没有拦截请求</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168556-ba4e1cae-2da6-4da2-b957-5004af4d56d7.png"></p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168647-04d28c3c-5b87-47f1-acc2-f825a234493a.png"></p><p>测试2：访问登录请求&#x2F;login，发现过滤器拦截请求</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168752-4d4b12e9-b534-4df6-b3f9-013856255b9b.png"></p><p>下面我们来测试”目录拦截”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/depts/*&quot;)</span> <span class="comment">//拦截所有以/depts开头，后面是什么无所谓</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行前逻辑.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行请求</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行后逻辑.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试1：访问部门管理请求，发现过滤器拦截了请求</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168880-e16032e8-05e9-4d16-aeac-f384c1102382.png"></p><p>测试2：访问登录请求&#x2F;login，发现过滤器没有拦截请求</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105168975-32a73986-8829-425e-8f70-5f5c5282b937.png"></p><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>最后我们在来介绍下过滤器链，什么是过滤器链呢？所谓过滤器链指的是在一个web应用程序当中，可以配置多个过滤器，多个过滤器就形成了一个过滤器链。</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169081-f945b75d-76ea-42a0-9684-deaedd8e2f64.png"></p><p>比如：在我们web服务器当中，定义了两个过滤器，这两个过滤器就形成了一个过滤器链。</p><p>而这个链上的过滤器在执行的时候会一个一个的执行，会先执行第一个Filter，放行之后再来执行第二个Filter，如果执行到了最后一个过滤器放行之后，才会访问对应的web资源。</p><p>访问完web资源之后，按照我们刚才所介绍的过滤器的执行流程，还会回到过滤器当中来执行过滤器放行后的逻辑，而在执行放行后的逻辑的时候，顺序是反着的。</p><p>先要执行过滤器2放行之后的逻辑，再来执行过滤器1放行之后的逻辑，最后在给浏览器响应数据。</p><p>以上就是当我们在web应用当中配置了多个过滤器，形成了这样一个过滤器链以及过滤器链的执行顺序。下面我们通过idea来验证下过滤器链。</p><p>验证步骤：</p><ol><li>在filter包下再来新建一个Filter过滤器类：AbcFilter</li><li>在AbcFilter过滤器中编写放行前和放行后逻辑</li><li>配置AbcFilter过滤器拦截请求路径为：&#x2F;*</li><li>重启SpringBoot服务，查看DemoFilter、AbcFilter的执行日志</li></ol><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169174-f2d35412-424d-471f-844c-04d71f7d0b7d.png"></p><p><strong>AbcFilter过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbcFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Abc 拦截到了请求... 放行前逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Abc 拦截到了请求... 放行后逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DemoFilter过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行前逻辑.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行请求</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行后逻辑.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开浏览器访问登录接口：</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169269-b3e44c35-3a3d-474d-bc91-e839ccc33fba.png"></p><p>通过控制台日志的输出，大家发现AbcFilter先执行DemoFilter后执行，这是为什么呢？</p><p>其实是和过滤器的类名有关系。以注解方式配置的Filter过滤器，它的执行优先级是按时过滤器类名的自动排序确定的，类名排名越靠前，优先级越高。</p><p>假如我们想让DemoFilter先执行，怎么办呢？答案就是修改类名。</p><p>测试：修改AbcFilter类名为XbcFilter，运行程序查看控制台日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XbcFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Xbc 拦截到了请求...放行前逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xbc 拦截到了请求...放行后逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169369-b41f579b-6845-4014-9ea7-f2ca0594f60e.png"></p><p>到此，关于过滤器的使用细节，我们已经全部介绍完毕了。</p><h2 id="登录校验-Filter"><a href="#登录校验-Filter" class="headerlink" title="登录校验-Filter"></a>登录校验-Filter</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>过滤器Filter的快速入门以及使用细节我们已经介绍完了，接下来最后一步，我们需要使用过滤器Filter来完成案例当中的登录校验功能。</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169467-ef00ff1e-4e3f-45fa-920d-494879350628.png"></p><p>我们先来回顾下前面分析过的登录校验的基本流程：</p><ul><li>要进入到后台管理系统，我们必须先完成登录操作，此时就需要访问登录接口login。 </li><li>登录成功之后，我们会在服务端生成一个JWT令牌，并且把JWT令牌返回给前端，前端会将JWT令牌存储下来。 </li><li>在后续的每一次请求当中，都会将JWT令牌携带到服务端，请求到达服务端之后，要想去访问对应的业务功能，此时我们必须先要校验令牌的有效性。 </li><li>对于校验令牌的这一块操作，我们使用登录校验的过滤器，在过滤器当中来校验令牌的有效性。如果令牌是无效的，就响应一个错误的信息，也不会再去放行访问对应的资源了。如果令牌存在，并且它是有效的，此时就会放行去访问对应的web资源，执行相应的业务操作。</li></ul><p>大概清楚了在Filter过滤器的实现步骤了，那在正式开发登录校验过滤器之前，我们思考两个问题：</p><ol><li>所有的请求，拦截到了之后，都需要校验令牌吗？</li></ol><ul><li>答案：<strong>登录请求例外</strong></li></ul><ol start="2"><li>拦截到请求后，什么情况下才可以放行，执行业务操作？</li></ol><ul><li>答案：<strong>有令牌，且令牌校验通过(合法)；否则都返回未登录错误结果</strong></li></ul><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><p>我们要完成登录校验，主要是利用Filter过滤器实现，而Filter过滤器的流程步骤：</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169559-e3eb8525-fa48-4387-9e79-65923810d870.png"></p><p>基于上面的业务流程，我们分析出具体的操作步骤：</p><ol><li>获取请求url</li><li>判断请求url中是否包含login，如果包含，说明是登录操作，放行</li><li>获取请求头中的令牌（token）</li><li>判断令牌是否存在，如果不存在，返回错误结果（未登录）</li><li>解析token，如果解析失败，返回错误结果（未登录）</li><li>放行</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>分析清楚了以上的问题后，我们就参照接口文档来开发登录功能了，登录接口描述如下：</p><ul><li><p>基本信息 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求路径：/login</span><br><span class="line"></span><br><span class="line">请求方式：POST</span><br><span class="line"></span><br><span class="line">接口描述：该接口用于员工登录Tlias智能学习辅助系统，登录完毕后，系统下发JWT令牌。</span><br></pre></td></tr></table></figure></li><li><p>请求参数<br>参数格式：application&#x2F;json<br>参数说明： </p><table><thead><tr><th>名称</th><th>类型</th><th>是否必须</th><th>备注</th></tr></thead><tbody><tr><td>username</td><td>string</td><td>必须</td><td>用户名</td></tr><tr><td>password</td><td>string</td><td>必须</td><td>密码</td></tr></tbody></table></li><li><p>请求数据样例： </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jinyong&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>响应数据<br>参数格式：application&#x2F;json<br>参数说明： </p><table><thead><tr><th>名称</th><th>类型</th><th>是否必须</th><th>默认值</th><th>备注</th><th>其他信息</th></tr></thead><tbody><tr><td>code</td><td>number</td><td>必须</td><td></td><td>响应码, 1 成功 ; 0  失败</td><td></td></tr><tr><td>msg</td><td>string</td><td>非必须</td><td></td><td>提示信息</td><td></td></tr><tr><td>data</td><td>string</td><td>必须</td><td></td><td>返回的数据 , jwt令牌</td><td></td></tr></tbody></table></li><li><p>响应数据样例： </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>备注说明<br>用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头header中携带到服务端，请求头的名称为 token ，值为 登录时下发的JWT令牌。<br>如果检测到用户未登录，则会返回如下固定错误信息： </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NOT_LOGIN&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>登录校验过滤器：LoginCheckFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="comment">//拦截所有请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//前置：强制转换为http协议的请求对象、响应对象 （转换原因：要使用子类中特有方法）</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line">        log.info(<span class="string">&quot;请求路径：&#123;&#125;&quot;</span>, url); <span class="comment">//请求路径：http://localhost:8080/login</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，如果包含，说明是登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;/login&quot;</span>))&#123;</span><br><span class="line">            chain.doFilter(request, response);<span class="comment">//放行请求</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//结束当前方法的执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;从请求头中获取的令牌：&#123;&#125;&quot;</span>,token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断令牌是否存在，如果不存在，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(token))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Token不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.解析token，如果解析失败，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;令牌解析失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述过滤器的功能实现中，我们使用到了一个第三方json处理的工具包fastjson。我们要想使用，需要引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>登录校验的过滤器我们编写完成了，接下来我们就可以重新启动服务来做一个测试：</p><blockquote><p>测试前先把之前所编写的测试使用的过滤器，暂时注释掉。直接将@WebFilter注解给注释掉即可。</p></blockquote><ul><li>测试1：未登录是否可以访问部门管理页面<br>首先关闭浏览器，重新打开浏览器，在地址栏中输入：<a href="http://localhost:9528/#/system/dept">http://localhost:9528/#/system/dept</a><br>由于用户没有登录，登录校验过滤器返回错误信息，前端页面根据返回的错误信息结果，自动跳转到登录页面了<br><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105164488-8364b0a8-3d4e-4051-a3cc-718eb567d8e7.png"> </li><li>测试2：先进行登录操作，再访问部门管理页面<br>登录校验成功之后，可以正常访问相关业务操作页面<br><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169644-e0a70012-305e-4a1e-9750-1922f78274fb.png"></li></ul><h1 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h1><p>学习完了过滤器Filter之后，接下来我们继续学习拦截器Interseptor。</p><p>拦截器我们主要分为三个方面进行讲解：</p><ol><li>介绍下什么是拦截器，并通过快速入门程序上手拦截器</li><li>拦截器的使用细节</li><li>通过拦截器Interceptor完成登录校验功能</li></ol><p>我们先学习第一块内容：拦截器快速入门</p><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><p>什么是拦截器？</p><ul><li>是一种动态拦截方法调用的机制，类似于过滤器。</li><li>拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。</li></ul><p>拦截器的作用：</p><ul><li>拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。</li></ul><p>在拦截器当中，我们通常也是做一些通用性的操作，比如：我们可以通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。</p><p>下面我们通过快速入门程序，来学习下拦截器的基本使用。拦截器的使用步骤和过滤器类似，也分为两步：</p><ol><li>定义拦截器 </li><li>注册配置拦截器</li></ol><p><strong>自定义拦截器：</strong>实现HandlerInterceptor接口，并重写其所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//目标资源方法执行前执行。 返回true：放行    返回false：不放行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true表示放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion .... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><pre><code>preHandle方法：目标资源方法执行前执行。 返回true：放行    返回false：不放行                 postHandle方法：目标资源方法执行后执行                 afterCompletion方法：视图渲染完毕后执行，最后执行</code></pre></blockquote><p><strong>注册配置拦截器</strong>：实现WebMvcConfigurer接口，并重写addInterceptors方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动SpringBoot服务，打开postman测试：</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169745-04fb16f1-ee9c-454b-b6c4-987943eddced.png"></p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169835-3895ab5d-2b01-4006-9a6f-fd08c6a7eb5b.png"></p><p>接下来我们再来做一个测试：将拦截器中返回值改为false</p><p>使用postman，再次点击send发送请求后，没有响应数据，说明请求被拦截了没有放行</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169924-19c3fb83-0b5b-4cfa-9dc9-25b2143ae04a.png"></p><h2 id="Interceptor详解"><a href="#Interceptor详解" class="headerlink" title="Interceptor详解"></a>Interceptor详解</h2><p>拦截器的入门程序完成之后，接下来我们来介绍拦截器的使用细节。拦截器的使用细节我们主要介绍两个部分：</p><ol><li>拦截器的拦截路径配置</li><li>拦截器的执行流程</li></ol><h3 id="拦截路径-1"><a href="#拦截路径-1" class="headerlink" title="拦截路径"></a>拦截路径</h3><p>首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径，通过<code>addPathPatterns(&quot;要拦截路径&quot;)</code>方法，就可以指定要拦截哪些资源。</p><p>在入门程序中我们配置的是<code>/**</code>，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资源，还可以指定不拦截哪些资源，只需要调用<code>excludePathPatterns(&quot;不拦截路径&quot;)</code>方法，指定哪些资源不需要拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);<span class="comment">//设置不拦截的请求路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拦截器中除了可以设置<code>/**</code>拦截所有资源外，还有一些常见拦截路径设置：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><p>下面主要来演示下<code>/**</code>与<code>/*</code>的区别：</p><ul><li>修改拦截器配置，把拦截路径设置为<code>/*</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/*&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);<span class="comment">//设置不拦截的请求路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用postman测试：<a href="http://localhost:8080/emps/1">http://localhost:8080/emps/1</a></p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105170008-7685a78e-4d91-4077-96ec-08b724f3f1a3.png"></p><p>控制台没有输出拦截器中的日志信息，说明<code>/*</code>没有匹配到拦截路径<code>/emp/1</code> 。</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105170130-9eabc982-2263-438e-b872-e4a5604e03cc.png"></p><h3 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h3><p>介绍完拦截路径的配置之后，接下来我们再来介绍拦截器的执行流程。通过执行流程，大家就能够清晰的知道过滤器与拦截器的执行时机。</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105170226-9887fd31-7464-4c61-97dd-b495586f1f97.png"></p><ul><li>当我们打开浏览器来访问部署在web服务器当中的web应用时，此时我们所定义的过滤器会拦截到这次请求。拦截到这次请求之后，它会先执行放行前的逻辑，然后再执行放行操作。而由于我们当前是基于springboot开发的，所以放行之后是进入到了spring的环境当中，也就是要来访问我们所定义的controller当中的接口方法。 </li><li>Tomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。 </li><li>当我们定义了拦截器后，会在执行Controller的方法之前，请求被拦截器拦截住。执行<code>preHandle()</code>方法，这个方法执行完成后需要返回一个布尔类型的值，如果返回true，就表示放行本次操作，才会继续访问controller中的方法；如果返回false，则不会放行（controller中的方法也不会执行）。 </li><li>在controller当中的方法执行完毕之后，再回过来执行<code>postHandle()</code>这个方法以及<code>afterCompletion()</code> 方法，然后再返回给DispatcherServlet，最终再来执行过滤器当中放行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。</li></ul><p>接下来我们就来演示下过滤器和拦截器同时存在的执行流程：</p><ul><li>开启LoginCheckInterceptor拦截器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true表示放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion .... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)<span class="comment">//拦截所有请求</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);<span class="comment">//不拦截登录请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开启DemoFilter过滤器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行前逻辑.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行请求</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;DemoFilter   放行后逻辑.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务后，清空日志，打开Postman，测试查询部门：</p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105170326-dee7d777-9934-40fd-9e74-0063f571589d.png"></p><p><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105170432-2f5f6e4d-761c-4481-b031-4b149bef74cc.png"></p><p>以上就是拦截器的执行流程。通过执行流程分析，大家应该已经清楚了过滤器和拦截器之间的区别，其实它们之间的区别主要是两点：</p><ul><li>接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。</li><li>拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。</li></ul><h2 id="登录校验-Interceptor"><a href="#登录校验-Interceptor" class="headerlink" title="登录校验- Interceptor"></a>登录校验- Interceptor</h2><p>讲解完了拦截器的基本操作之后，接下来我们需要完成最后一步操作：通过拦截器来完成案例当中的登录校验功能。</p><p>登录校验的业务逻辑以及操作步骤我们前面已经分析过了，和登录校验Filter过滤器当中的逻辑是完全一致的。现在我们只需要把这个技术方案由原来的过滤器换成拦截器interceptor就可以了。</p><p><strong>登录校验拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//当前拦截器对象由Spring创建和管理</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//前置方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，如果包含，说明是登录操作，放行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;从请求头中获取的令牌：&#123;&#125;&quot;</span>,token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断令牌是否存在，如果不存在，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(token))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Token不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建响应结果对象</span></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            <span class="comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不放行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.解析token，如果解析失败，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;令牌解析失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建响应结果对象</span></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            <span class="comment">//设置响应头</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注册配置拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录校验的拦截器编写完成后，接下来我们就可以重新启动服务来做一个测试： （<strong>关闭登录校验Filter过滤器</strong>）</p><ul><li>测试1：未登录是否可以访问部门管理页面<br>首先关闭浏览器，重新打开浏览器，在地址栏中输入：<a href="http://localhost:9528/#/system/dept">http://localhost:9528/#/system/dept</a><br>由于用户没有登录，校验机制返回错误信息，前端页面根据返回的错误信息结果，自动跳转到登录页面了<br><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105164488-8364b0a8-3d4e-4051-a3cc-718eb567d8e7.png"> </li><li>测试2：先进行登录操作，再访问部门管理页面<br>登录校验成功之后，可以正常访问相关业务操作页面<br><img src="/./img/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/1706105169644-e0a70012-305e-4a1e-9750-1922f78274fb.png"></li></ul><p>到此我们也就验证了所开发的登录校验的拦截器也是没问题的。登录校验的过滤器和拦截器，我们只需要使用其中的一种就可以了。</p>]]></content>
    
    
    <summary type="html">SpringBoot-过滤器拦截器</summary>
    
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/tags/SpringBoot/"/>
    
    <category term="Java开发" scheme="http://ylcheng1789.github.io/tags/Java%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-登录校验技术</title>
    <link href="http://ylcheng1789.github.io/2024/04/10/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/"/>
    <id>http://ylcheng1789.github.io/2024/04/10/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/</id>
    <published>2024-04-10T13:01:24.000Z</published>
    <updated>2024-08-29T09:11:02.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我们已经完成了基础登录功能的开发与测试，在我们登录成功后就可以进入到后台管理系统中进行数据的操作。</p><p>但是当我们在浏览器中新的页面上输入地址：<code>http://localhost:9528/#/system/dept</code>，发现没有登录仍然可以进入到后端管理系统页面。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165185-73c7cded-7ab1-4353-b4d8-7b74cd4a1921.png"></p><p>而真正的登录功能应该是：登陆后才能访问后端系统页面，不登陆则跳转登陆页面进行登陆。</p><p>为什么会出现这个问题？其实原因很简单，就是因为针对于我们当前所开发的部门管理、员工管理以及文件上传等相关接口来说，我们在服务器端并没有做任何的判断，没有去判断用户是否登录了。所以无论用户是否登录，都可以访问部门管理以及员工管理的相关数据。所以我们目前所开发的登录功能，它只是徒有其表。而我们要想解决这个问题，我们就需要完成一步非常重要的操作：登录校验。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165284-3f580f29-f194-4b85-8efa-9b55bbdd5488.png"></p><p>什么是登录校验？</p><ul><li>所谓登录校验，指的是我们在服务器端接收到浏览器发送过来的请求之后，首先我们要对请求进行校验。先要校验一下用户登录了没有，如果用户已经登录了，就直接执行对应的业务操作就可以了；如果用户没有登录，此时就不允许他执行相关的业务操作，直接给前端响应一个错误的结果，最终跳转到登录页面，要求他登录成功之后，再来访问对应的数据。</li></ul><p>了解完什么是登录校验之后，接下来我们分析一下登录校验大概的实现思路。</p><p>首先我们在宏观上先有一个认知：</p><p>前面在讲解HTTP协议的时候，我们提到HTTP协议是无状态协议。什么又是无状态的协议？</p><p>所谓无状态，指的是每一次请求都是独立的，下一次请求并不会携带上一次请求的数据。而浏览器与服务器之间进行交互，基于HTTP协议也就意味着现在我们通过浏览器来访问了登陆这个接口，实现了登陆的操作，接下来我们在执行其他业务操作时，服务器也并不知道这个员工到底登陆了没有。因为HTTP协议是无状态的，两次请求之间是独立的，所以是无法判断这个员工到底登陆了没有。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165374-877975fe-b51e-442c-a362-6b867174f298.png"></p><p>那应该怎么来实现登录校验的操作呢？具体的实现思路可以分为两部分：</p><ol><li>在员工登录成功后，需要将用户登录成功的信息存起来，记录用户已经登录成功的标记。</li><li>在浏览器发起请求时，需要在服务端进行统一拦截，拦截后进行登录校验。</li></ol><blockquote><p>想要判断员工是否已经登录，我们需要在员工登录成功之后，存储一个登录成功的标记，接下来在每一个接口方法执行之前，先做一个条件判断，判断一下这个员工到底登录了没有。如果是登录了，就可以执行正常的业务操作，如果没有登录，会直接给前端返回一个错误的信息，前端拿到这个错误信息之后会自动的跳转到登录页面。</p><p>我们程序中所开发的查询功能、删除功能、添加功能、修改功能，都需要使用以上套路进行登录校验。此时就会出现：相同代码逻辑，每个功能都需要编写，就会造成代码非常繁琐。</p><p>为了简化这块操作，我们可以使用一种技术：统一拦截技术。</p><p>通过统一拦截的技术，我们可以来拦截浏览器发送过来的所有的请求，拦截到这个请求之后，就可以通过请求来获取之前所存入的登录标记，在获取到登录标记且标记为登录成功，就说明员工已经登录了。如果已经登录，我们就直接放行(意思就是可以访问正常的业务接口了)。</p></blockquote><p>我们要完成以上操作，会涉及到web开发中的两个技术：</p><ol><li>会话技术</li><li>统一拦截技术</li></ol><p>而统一拦截技术现实方案也有两种：</p><ol><li>Servlet规范中的Filter过滤器</li><li>Spring提供的interceptor拦截器</li></ol><p>下面我们先学习会话技术，然后再学习统一拦截技术。</p><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p>介绍了登录校验的大概思路之后，我们先来学习下会话技术。</p><h3 id="会话技术介绍"><a href="#会话技术介绍" class="headerlink" title="会话技术介绍"></a>会话技术介绍</h3><p>什么是会话？</p><ul><li>在我们日常生活当中，会话指的就是谈话、交谈。 </li><li>在web开发当中，会话指的就是浏览器与服务器之间的一次连接，我们就称为一次会话。 <blockquote><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p><ul><li>第1次：访问的是登录的接口，完成登录操作</li><li>第2次：访问的是部门管理接口，查询所有部门数据</li><li>第3次：访问的是员工管理接口，查询员工数据</li></ul></blockquote></li></ul><blockquote><p>只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。</p></blockquote><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165485-777d91f3-e823-4ebb-9b5d-b68555c76b59.png"></p><p>需要注意的是：会话是和浏览器关联的，当有三个浏览器客户端和服务器建立了连接时，就会有三个会话。同一个浏览器在未关闭之前请求了多次服务器，这多次请求是属于同一个会话。比如：1、2、3这三个请求都是属于同一个会话。当我们关闭浏览器之后，这次会话就结束了。而如果我们是直接把web服务器关了，那么所有的会话就都结束了。</p><p>知道了会话的概念了，接下来我们再来了解下会话跟踪。</p><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p><blockquote><p>服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我们就称为会话跟踪。</p></blockquote><p>我们使用会话跟踪技术就是要完成在同一个会话中，多个请求之间进行共享数据。</p><blockquote><p>为什么要共享数据呢？</p><p>由于HTTP是无状态协议，在后面请求中怎么拿到前一次请求生成的数据呢？此时就需要在一次会话的多次请求之间进行数据共享</p></blockquote><p>会话跟踪技术有两种：</p><ol><li>Cookie（客户端会话跟踪技术） <ul><li>数据存储在客户端浏览器当中</li></ul></li><li>Session（服务端会话跟踪技术） <ul><li>数据存储在储在服务端</li></ul></li><li>令牌技术</li></ol><h3 id="会话跟踪方案"><a href="#会话跟踪方案" class="headerlink" title="会话跟踪方案"></a>会话跟踪方案</h3><p>上面我们介绍了什么是会话，什么是会话跟踪，并且也提到了会话跟踪 3 种常见的技术方案。接下来，我们就来对比一下这 3 种会话跟踪的技术方案，来看一下具体的实现思路，以及它们之间的优缺点。</p><h4 id="方案一-Cookie"><a href="#方案一-Cookie" class="headerlink" title="方案一 - Cookie"></a>方案一 - Cookie</h4><p><strong>cookie 是客户端会话跟踪技术</strong>，它是存储在客户端浏览器的，我们使用 cookie 来跟踪会话，我们就可以在浏览器第一次发起请求来请求服务器的时候，我们在服务器端来设置一个cookie。</p><p>比如第一次请求了登录接口，登录接口执行完成之后，我们就可以设置一个cookie，在 cookie 当中我们就可以来存储用户相关的一些数据信息。比如我可以在 cookie 当中来存储当前登录用户的用户名，用户的ID。</p><p>服务器端在给客户端在响应数据的时候，会<strong>自动</strong>的将 cookie 响应给浏览器，浏览器接收到响应回来的 cookie 之后，会<strong>自动</strong>的将 cookie 的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的 cookie <strong>自动</strong>地携带到服务端。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165579-a95e0d2c-3212-4dd2-b724-ebc856e1f122.png"></p><p>接下来在服务端我们就可以获取到 cookie 的值。我们可以去判断一下这个 cookie 的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在 cookie 的值，就说明客户端之前已经登录完成了。这样我们就可以基于 cookie 在同一次会话的不同请求之间来共享数据。</p><p>我刚才在介绍流程的时候，用了 3 个自动：</p><ul><li>服务器会 <strong>自动</strong> 的将 cookie 响应给浏览器。 </li><li>浏览器接收到响应回来的数据之后，会 <strong>自动</strong> 的将 cookie 存储在浏览器本地。 </li><li>在后续的请求当中，浏览器会 <strong>自动</strong> 的将 cookie 携带到服务器端。</li></ul><p><strong>为什么这一切都是自动化进行的？</strong></p><p>是因为 cookie 它是 HTP 协议当中所支持的技术，而各大浏览器厂商都支持了这一标准。在 HTTP 协议官方给我们提供了一个响应头和请求头：</p><ul><li>响应头 Set-Cookie ：设置Cookie数据的 </li><li>请求头 Cookie：携带Cookie数据的</li></ul><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165678-73345fc4-c455-4763-b059-7e2b1229d533.png"></p><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie1</span><span class="params">(HttpServletResponse response)</span>&#123;</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;login_username&quot;</span>,<span class="string">&quot;itheima&quot;</span>)); <span class="comment">//设置Cookie/响应Cookie</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie2</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;login_username&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;login_username: &quot;</span>+cookie.getValue()); <span class="comment">//输出name为login_username的cookie</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 访问c1接口，设置Cookie，<a href="http://localhost:8080/c1">http://localhost:8080/c1</a></p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165792-19d666b1-48c7-4a1b-84fe-312a2a6a6edf.png"></p><p>我们可以看到，设置的cookie，通过<strong>响应头Set-Cookie</strong>响应给浏览器，并且浏览器会将Cookie，存储在浏览器端。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165910-88a598d0-f7a9-49f0-9a9f-4c912c74ac0c.png"></p><p>B. 访问c2接口 <a href="http://localhost:8080/c2%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%9A%84%E5%B0%86Cookie%E6%90%BA%E5%B8%A6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E6%98%AF%E9%80%9A%E8%BF%87**%E8%AF%B7%E6%B1%82%E5%A4%B4Cookie**%EF%BC%8C%E6%90%BA%E5%B8%A6%E7%9A%84%E3%80%82">http://localhost:8080/c2，此时浏览器会自动的将Cookie携带到服务端，是通过**请求头Cookie**，携带的。</a></p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166049-edd46b83-099b-4ca5-9675-b32d95a263aa.png"></p><p><strong>优缺点</strong></p><ul><li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带，都是浏览器自动进行的，是无需我们手动操作的）</li><li>缺点： <ul><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>不安全，用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>跨域介绍：</p><pre><code> ![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706105166167-30f0ad7b-1a75-4af2-8614-ff0671aa7177.png#averageHue=%23f8f2ed&amp;id=j5ptC&amp;originHeight=406&amp;originWidth=1000&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)</code></pre><ul><li>现在的项目，大部分都是前后端分离的，前后端最终也会分开部署，前端部署在服务器 192.168.150.200 上，端口 80，后端部署在 192.168.150.100上，端口 8080</li><li>我们打开浏览器直接访问前端工程，访问url：<a href="http://_192.168.150.200_login/">http://192.168.150.200/login.html</a></li><li>然后在该页面发起请求到服务端，而服务端所在地址不再是localhost，而是服务器的IP地址192.168.150.100，假设访问接口地址为：<a href="http://192.168.150.100:8080/login">http://192.168.150.100:8080/login</a></li><li>那此时就存在跨域操作了，因为我们是在 <a href="http://_192.168.150.200_login/">http://192.168.150.200/login.html</a> 这个页面上访问了<a href="http://192.168.150.100:8080/login">http://192.168.150.100:8080/login</a> 接口</li><li>此时如果服务器设置了一个Cookie，这个Cookie是不能使用的，因为Cookie无法跨域</li></ul></blockquote><blockquote><p>区分跨域的维度：</p><ul><li>协议</li><li>IP&#x2F;协议</li><li>端口</li></ul></blockquote><blockquote><p>只要上述的三个维度有任何一个维度不同，那就是跨域操作</p><p>举例：</p><pre><code>[http://192.168.150.200/login.html](http:_192.168.150.200_login) ----------&gt; [https://192.168.150.200/login](https://192.168.150.200/login)   [协议不同，跨域]                 [http://192.168.150.200/login.html](http:_192.168.150.200_login) ----------&gt; [http://192.168.150.100/login](http://192.168.150.100/login)     [IP不同，跨域]                 [http://192.168.150.200/login.html](http:_192.168.150.200_login) ----------&gt; [http://192.168.150.200:8080/login](http://192.168.150.200:8080/login)   [端口不同，跨域]</code></pre><p>    <a href="http://_192.168.150.200_login/">http://192.168.150.200/login.html</a> ———-&gt; <a href="http://192.168.150.200/login">http://192.168.150.200/login</a>     [不跨域]</p></blockquote><h4 id="方案二-Session"><a href="#方案二-Session" class="headerlink" title="方案二 - Session"></a>方案二 - Session</h4><p>前面介绍的时候，我们提到Session，<strong>它是服务器端会话跟踪技术</strong>，所以它是存储在服务器端的。而 Session 的底层其实就是基于我们刚才所介绍的 Cookie 来实现的。</p><ul><li>获取Session<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166256-bed33c3f-8a41-47ba-8b8a-2cf0bc3734f5.png"><br>如果我们现在要基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，我们就可以直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），我们称之为 Session 的ID。 </li><li>响应Cookie (JSESSIONID)<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166338-3c124015-5dca-4579-a8cd-0f8f33b62f44.png"><br>接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个  Set-Cookie  响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。 </li><li>查找Session<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166427-4a3ab2ff-d2aa-47f6-bdf0-94d4b579a56e.png"><br>接下来，在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。接下来服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。<br>这样我们是不是就可以通过 Session 会话对象在同一次会话的多次请求之间来共享数据了？好，这就是基于 Session 进行会话跟踪的流程。</li></ul><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/s1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session1</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-s1: &#123;&#125;&quot;</span>, session.hashCode());</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;loginUser&quot;</span>, <span class="string">&quot;tom&quot;</span>); <span class="comment">//往session中存储数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/s2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session2</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-s2: &#123;&#125;&quot;</span>, session.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>); <span class="comment">//从session中获取数据</span></span><br><span class="line">        log.info(<span class="string">&quot;loginUser: &#123;&#125;&quot;</span>, loginUser);</span><br><span class="line">        <span class="keyword">return</span> Result.success(loginUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 访问 s1 接口，<a href="http://localhost:8080/s1">http://localhost:8080/s1</a></p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166515-054a5251-56fc-438f-ab1f-d02669a0f416.png"></p><p>请求完成之后，在响应头中，就会看到有一个Set-Cookie的响应头，里面响应回来了一个Cookie，就是JSESSIONID，这个就是服务端会话对象 Session 的ID。</p><p>B. 访问 s2 接口，<a href="http://localhost:8080/s2">http://localhost:8080/s2</a></p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166658-ba7a3e11-8bf5-4a41-abfa-3b718dd11f7a.png"></p><p>接下来，在后续的每次请求时，都会将Cookie的值，携带到服务端，那服务端呢，接收到Cookie之后，会自动的根据JSESSIONID的值，找到对应的会话对象Session。</p><p>那经过这两步测试，大家也会看到，在控制台中输出如下日志：</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166785-20b03734-2249-4614-86de-4e7a454063da.png"></p><p>两次请求，获取到的Session会话对象的hashcode是一样的，就说明是同一个会话对象。而且，第一次请求时，往Session会话对象中存储的值，第二次请求时，也获取到了。 那这样，我们就可以通过Session会话对象，在同一个会话的多次请求之间来进行数据共享了。</p><p><strong>优缺点</strong></p><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点： <ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案，也就失效了。</p></blockquote><blockquote><p>服务器集群环境为何无法使用Session？</p><pre><code>![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706105166897-fd457716-58a6-4e4d-a17e-91b8cc402403.png#averageHue=%23f8eee6&amp;id=lPzUp&amp;originHeight=132&amp;originWidth=540&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)</code></pre><ul><li>首先第一点，我们现在所开发的项目，一般都不会只部署在一台服务器上，因为一台服务器会存在一个很大的问题，就是单点故障。所谓单点故障，指的就是一旦这台服务器挂了，整个应用都没法访问了。</li></ul></blockquote><blockquote><p>    <img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167033-97bb2c75-575e-42d9-9336-7028fb075da8.png"></p><ul><li>所以在现在的企业项目开发当中，最终部署的时候都是以集群的形式来进行部署，也就是同一个项目它会部署多份。比如这个项目我们现在就部署了 3 份。 </li><li>而用户在访问的时候，到底访问这三台其中的哪一台？其实用户在访问的时候，他会访问一台前置的服务器，我们叫负载均衡服务器，我们在后面项目当中会详细讲解。目前大家先有一个印象负载均衡服务器，它的作用就是将前端发起的请求均匀的分发给后面的这三台服务器。<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167122-1608aec0-5860-462a-8c06-28d302527326.png"> </li><li>此时假如我们通过 session 来进行会话跟踪，可能就会存在这样一个问题。用户打开浏览器要进行登录操作，此时会发起登录请求。登录请求到达负载均衡服务器，将这个请求转给了第一台 Tomcat 服务器。<br>Tomcat 服务器接收到请求之后，要获取到会话对象session。获取到会话对象 session 之后，要给浏览器响应数据，最终在给浏览器响应数据的时候，就会携带这么一个 cookie 的名字，就是 JSESSIONID ，下一次再请求的时候，是不是又会将 Cookie 携带到服务端？<br>好。此时假如又执行了一次查询操作，要查询部门的数据。这次请求到达负载均衡服务器之后，负载均衡服务器将这次请求转给了第二台 Tomcat 服务器，此时他就要到第二台 Tomcat 服务器当中。根据JSESSIONID 也就是对应的 session 的 ID 值，要找对应的 session 会话对象。<br>我想请问在第二台服务器当中有没有这个ID的会话对象 Session， 是没有的。此时是不是就出现问题了？我同一个浏览器发起了 2 次请求，结果获取到的不是同一个会话对象，这就是Session这种会话跟踪方案它的缺点，在服务器集群环境下无法直接使用Session。</li></ul></blockquote><p>大家会看到上面这两种传统的会话技术，在现在的企业开发当中是不是会存在很多的问题。 为了解决这些问题，在现在的企业开发当中，基本上都会采用第三种方案，通过令牌技术来进行会话跟踪。接下来我们就来介绍一下令牌技术，来看一下令牌技术又是如何跟踪会话的。</p><h4 id="方案三-令牌技术"><a href="#方案三-令牌技术" class="headerlink" title="方案三 - 令牌技术"></a>方案三 - 令牌技术</h4><p>这里我们所提到的令牌，其实它就是一个用户身份的标识，看似很高大上，很神秘，其实本质就是一个字符串。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167224-656fbfaa-21eb-4ffe-83cb-38501c91c38c.png"></p><p>如果通过令牌技术来跟踪会话，我们就可以在浏览器发起请求。在请求登录接口的时候，如果登录成功，我就可以生成一个令牌，令牌就是用户的合法身份凭证。接下来我在响应数据的时候，我就可以直接将令牌响应给前端。</p><p>接下来我们在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。</p><p>接下来，在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。</p><p>此时，如果是在同一次会话的多次请求之间，我们想共享数据，我们就可以将共享的数据存储在令牌当中就可以了。</p><p><strong>优缺点</strong></p><ul><li>优点： <ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器的存储压力（无需在服务器端存储）</li></ul></li><li>缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）</li></ul><p><strong>针对于这三种方案，现在企业开发当中使用的最多的就是第三种令牌技术进行会话跟踪。而前面的这两种传统的方案，现在企业项目开发当中已经很少使用了。所以在我们的课程当中，我们也将会采用令牌技术来解决案例项目当中的会话跟踪问题。</strong></p><h2 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h2><p>前面我们介绍了基于令牌技术来实现会话追踪。这里所提到的令牌就是用户身份的标识，其本质就是一个字符串。令牌的形式有很多，我们使用的是功能强大的 JWT令牌。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>JWT全称：JSON Web Token  （官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p><ul><li>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。 <blockquote><p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。</p><p>自包含：指的是jwt令牌，看似是一个随机的字符串，但是我们是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。</p><p>简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。</p></blockquote></li></ul><p>JWT的组成： （JWT令牌由三个部分组成，三个部分之间使用英文的点来分割）</p><ul><li>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{“alg”:”HS256”,”type”:”JWT”} </li><li>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{“id”:”1”,”username”:”Tom”} </li><li>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。 <blockquote><p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，所以整个jwt 令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败，所以它是非常安全可靠的。</p></blockquote></li></ul><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167404-2d10f9e1-d7a8-4042-8e45-0d2b382a837e.png"></p><blockquote><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p><p>其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码</p><p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p><p>需要注意的是Base64是编码方式，而不是加密方式。</p></blockquote><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167494-86b6b78c-3114-4cf1-a435-25eef3e6ab79.png"></p><p>JWT令牌最典型的应用场景就是登录认证：</p><ol><li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。</li><li>前端拿到jwt令牌之后，会将jwt令牌存储起来。在后续的每一次请求中都会将jwt令牌携带到服务端。</li><li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。</li></ol><p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：</p><ol><li>在登录成功之后，要生成令牌。</li><li>每一次请求当中，要接收令牌并对令牌进行校验。</li></ol><p>稍后我们再来学习如何来生成jwt令牌，以及如何来校验jwt令牌。</p><h3 id="生成和校验"><a href="#生成和校验" class="headerlink" title="生成和校验"></a>生成和校验</h3><p>简单介绍了JWT令牌以及JWT令牌的组成之后，接下来我们就来学习基于Java代码如何生成和校验JWT令牌。</p><p>首先我们先来实现JWT令牌的生成。要想使用JWT令牌，需要先引入JWT的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在引入完JWT来赖后，就可以调用工具包中提供的API来完成JWT令牌的生成和校验</p><p>工具类：Jwts</p></blockquote><p>生成JWT代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    claims.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .setClaims(claims) <span class="comment">//自定义内容(载荷)          </span></span><br><span class="line">        .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;itheima&quot;</span>) <span class="comment">//签名算法        </span></span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>)) <span class="comment">//有效期   </span></span><br><span class="line">        .compact();</span><br><span class="line">    </span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk</span><br></pre></td></tr></table></figure><p>输出的结果就是生成的JWT令牌,，通过英文的点分割对三个部分进行分割，我们可以将生成的令牌复制一下，然后打开JWT的官网，将生成的令牌直接放在Encoded位置，此时就会自动的将令牌解析出来。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167590-7316eaf8-87e5-44ac-ac2f-b8bb7154238a.png"></p><blockquote><p>第一部分解析出来，看到JSON格式的原始数据，所使用的签名算法为HS256。</p><p>第二个部分是我们自定义的数据，之前我们自定义的数据就是id，还有一个exp代表的是我们所设置的过期时间。</p><p>由于前两个部分是base64编码，所以是可以直接解码出来。但最后一个部分并不是base64编码，是经过签名算法计算出来的，所以最后一个部分是不会解析的。</p></blockquote><p>实现了JWT令牌的生成，下面我们接着使用Java代码来校验JWT令牌(解析生成的令牌)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(<span class="string">&quot;itheima&quot;</span>)<span class="comment">//指定签名密钥（必须保证和生成令牌时使用相同的签名密钥）  </span></span><br><span class="line">    .parseClaimsJws(<span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk&quot;</span>)</span><br><span class="line">        .getBody();</span><br><span class="line"></span><br><span class="line">    System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=1, exp=1672729730&#125;</span><br></pre></td></tr></table></figure><blockquote><p>令牌解析后，我们可以看到id和过期时间，如果在解析的过程当中没有报错，就说明解析成功了。</p></blockquote><p>下面我们做一个测试：把令牌header中的数字9变为8，运行测试方法后发现报错：</p><blockquote><p>原header： eyJhbGciOiJIUzI1NiJ9</p><p>修改为： eyJhbGciOiJIUzI1NiJ8</p></blockquote><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167689-b4b49da4-73d4-4398-8835-2cecf365d003.png"></p><p>结论：篡改令牌中的任何一个字符，在对令牌进行解析时都会报错，所以JWT令牌是非常安全可靠的。</p><p>我们继续测试：修改生成令牌的时指定的过期时间，修改为1分钟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(“id”,<span class="number">1</span>);</span><br><span class="line">    claims.put(“username”,“Tom”);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .setClaims(claims) <span class="comment">//自定义内容(载荷)          </span></span><br><span class="line">        .signWith(SignatureAlgorithm.HS256, “itheima”) <span class="comment">//签名算法        </span></span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">60</span>*<span class="number">1000</span>)) <span class="comment">//有效期60秒   </span></span><br><span class="line">        .compact();</span><br><span class="line">    </span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">    <span class="comment">//输出结果：eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(<span class="string">&quot;itheima&quot;</span>)<span class="comment">//指定签名密钥</span></span><br><span class="line">.parseClaimsJws(<span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro&quot;</span>)</span><br><span class="line">        .getBody();</span><br><span class="line"></span><br><span class="line">    System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待1分钟之后运行测试方法发现也报错了，说明：JWT令牌过期后，令牌就失效了，解析的为非法令牌。</p><p>通过以上测试，我们在使用JWT令牌时需要注意：</p><ul><li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。 </li><li>如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。</li></ul><h3 id="登录下发令牌"><a href="#登录下发令牌" class="headerlink" title="登录下发令牌"></a>登录下发令牌</h3><p>JWT令牌的生成和校验的基本操作我们已经学习完了，接下来我们就需要在案例当中通过JWT令牌技术来跟踪会话。具体的思路我们前面已经分析过了，主要就是两步操作：</p><ol><li>生成令牌 <ul><li>在登录成功之后来生成一个JWT令牌，并且把这个令牌直接返回给前端</li></ul></li><li>校验令牌 <ul><li>拦截前端请求，从请求中获取到令牌，对令牌进行解析校验</li></ul></li></ol><p>那我们首先来完成：登录成功之后生成JWT令牌，并且把令牌返回给前端。</p><p>JWT令牌怎么返回给前端呢？此时我们就需要再来看一下接口文档当中关于登录接口的描述（主要看响应数据）：</p><ul><li><p>响应数据<br>参数格式：application&#x2F;json<br>参数说明： </p><table><thead><tr><th>名称</th><th>类型</th><th>是否必须</th><th>默认值</th><th>备注</th><th>其他信息</th></tr></thead><tbody><tr><td>code</td><td>number</td><td>必须</td><td></td><td>响应码, 1 成功 ; 0  失败</td><td></td></tr><tr><td>msg</td><td>string</td><td>非必须</td><td></td><td>提示信息</td><td></td></tr><tr><td>data</td><td>string</td><td>必须</td><td></td><td>返回的数据 , jwt令牌</td><td></td></tr></tbody></table></li><li><p>响应数据样例： </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>备注说明<br>用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头header中携带到服务端，请求头的名称为 token ，值为 登录时下发的JWT令牌。<br>如果检测到用户未登录，则会返回如下固定错误信息： </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NOT_LOGIN&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>解读完接口文档中的描述了，目前我们先来完成令牌的生成和令牌的下发，我们只需要生成一个令牌返回给前端就可以了。</p><p><strong>实现步骤：</strong></p><ol><li>引入JWT工具类 <ul><li>在项目工程下创建com.itheima.utils包，并把提供JWT工具类复制到该包下</li></ul></li><li>登录完成后，调用工具类生成JWT令牌并返回</li></ol><p><strong>JWT工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">signKey</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;<span class="comment">//签名密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">43200000L</span>; <span class="comment">//有效时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateJwt</span><span class="params">(Map&lt;String, Object&gt; claims)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .addClaims(claims)<span class="comment">//自定义信息（有效载荷）</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, signKey)<span class="comment">//签名算法（头部）</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expire))<span class="comment">//过期时间</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(signKey)<span class="comment">//指定签名密钥</span></span><br><span class="line">                .parseClaimsJws(jwt)<span class="comment">//指定令牌Token</span></span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>登录成功，生成JWT令牌并返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="comment">//依赖业务层对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpService empService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//调用业务层：登录功能</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">loginEmp</span> <span class="operator">=</span> empService.login(emp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断：登录用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(loginEmp !=<span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="comment">//自定义信息</span></span><br><span class="line">            Map&lt;String , Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            claims.put(<span class="string">&quot;id&quot;</span>, loginEmp.getId());</span><br><span class="line">            claims.put(<span class="string">&quot;username&quot;</span>,loginEmp.getUsername());</span><br><span class="line">            claims.put(<span class="string">&quot;name&quot;</span>,loginEmp.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用JWT工具类，生成身份令牌</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateJwt(claims);</span><br><span class="line">            <span class="keyword">return</span> Result.success(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，打开postman测试登录接口：</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167780-61fb5af5-684a-4fdf-9810-c090c89c0acc.png"></p><p>打开浏览器完成前后端联调操作：利用开发者工具，抓取一下网络请求</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167878-c9395452-c79d-4c78-8f0f-555fbb5140b1.png"></p><blockquote><p>登录请求完成后，可以看到JWT令牌已经响应给了前端，此时前端就会将JWT令牌存储在浏览器本地。</p></blockquote><p>服务器响应的JWT令牌存储在本地浏览器哪里了呢？</p><ul><li>在当前案例中，JWT令牌存储在浏览器的本地存储空间local storage中了。 local storage是浏览器的本地存储，在移动端也是支持的。</li></ul><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167995-50c6386c-38d3-4ae3-8068-7349d25e785f.png"></p><p>我们在发起一个查询部门数据的请求，此时我们可以看到在请求头中包含一个token(JWT令牌)，后续的每一次请求当中，都会将这个令牌携带到服务端。</p><p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105168097-d26ea7d6-fec5-42ac-becf-cf8867bd0bb3.png"></p>]]></content>
    
    
    <summary type="html">SpringBoot-登录校验技术</summary>
    
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://ylcheng1789.github.io/tags/SpringBoot/"/>
    
    <category term="Java开发" scheme="http://ylcheng1789.github.io/tags/Java%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
