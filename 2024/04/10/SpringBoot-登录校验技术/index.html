<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SpringBoot-登录校验技术 | Loong</title><meta name="author" content="程月龙"><meta name="copyright" content="程月龙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringBoot-登录校验技术">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot-登录校验技术">
<meta property="og:url" content="http://ylcheng1789.github.io/2024/04/10/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="Loong">
<meta property="og:description" content="SpringBoot-登录校验技术">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg">
<meta property="article:published_time" content="2024-04-10T13:01:24.000Z">
<meta property="article:modified_time" content="2024-08-29T09:11:02.993Z">
<meta property="article:author" content="程月龙">
<meta property="article:tag" content="SpringBoot">
<meta property="article:tag" content="Java开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://ylcheng1789.github.io/2024/04/10/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ae9ce48d24501920dfa510977fa6cdad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringBoot-登录校验技术',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-29 17:11:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Loong" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cyl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408290048644.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Loong"><img class="site-icon" src="/img/logo.png"><span class="site-name">Loong</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot-登录校验技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-10T13:01:24.000Z" title="发表于 2024-04-10 21:01:24">2024-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-29T09:11:02.993Z" title="更新于 2024-08-29 17:11:02">2024-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringBoot-登录校验技术"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408290048644.png');"></div><article class="post-content" id="article-container"><h1 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我们已经完成了基础登录功能的开发与测试，在我们登录成功后就可以进入到后台管理系统中进行数据的操作。</p>
<p>但是当我们在浏览器中新的页面上输入地址：<code>http://localhost:9528/#/system/dept</code>，发现没有登录仍然可以进入到后端管理系统页面。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165185-73c7cded-7ab1-4353-b4d8-7b74cd4a1921.png"></p>
<p>而真正的登录功能应该是：登陆后才能访问后端系统页面，不登陆则跳转登陆页面进行登陆。</p>
<p>为什么会出现这个问题？其实原因很简单，就是因为针对于我们当前所开发的部门管理、员工管理以及文件上传等相关接口来说，我们在服务器端并没有做任何的判断，没有去判断用户是否登录了。所以无论用户是否登录，都可以访问部门管理以及员工管理的相关数据。所以我们目前所开发的登录功能，它只是徒有其表。而我们要想解决这个问题，我们就需要完成一步非常重要的操作：登录校验。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165284-3f580f29-f194-4b85-8efa-9b55bbdd5488.png"></p>
<p>什么是登录校验？</p>
<ul>
<li>所谓登录校验，指的是我们在服务器端接收到浏览器发送过来的请求之后，首先我们要对请求进行校验。先要校验一下用户登录了没有，如果用户已经登录了，就直接执行对应的业务操作就可以了；如果用户没有登录，此时就不允许他执行相关的业务操作，直接给前端响应一个错误的结果，最终跳转到登录页面，要求他登录成功之后，再来访问对应的数据。</li>
</ul>
<p>了解完什么是登录校验之后，接下来我们分析一下登录校验大概的实现思路。</p>
<p>首先我们在宏观上先有一个认知：</p>
<p>前面在讲解HTTP协议的时候，我们提到HTTP协议是无状态协议。什么又是无状态的协议？</p>
<p>所谓无状态，指的是每一次请求都是独立的，下一次请求并不会携带上一次请求的数据。而浏览器与服务器之间进行交互，基于HTTP协议也就意味着现在我们通过浏览器来访问了登陆这个接口，实现了登陆的操作，接下来我们在执行其他业务操作时，服务器也并不知道这个员工到底登陆了没有。因为HTTP协议是无状态的，两次请求之间是独立的，所以是无法判断这个员工到底登陆了没有。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165374-877975fe-b51e-442c-a362-6b867174f298.png"></p>
<p>那应该怎么来实现登录校验的操作呢？具体的实现思路可以分为两部分：</p>
<ol>
<li>在员工登录成功后，需要将用户登录成功的信息存起来，记录用户已经登录成功的标记。</li>
<li>在浏览器发起请求时，需要在服务端进行统一拦截，拦截后进行登录校验。</li>
</ol>
<blockquote>
<p>想要判断员工是否已经登录，我们需要在员工登录成功之后，存储一个登录成功的标记，接下来在每一个接口方法执行之前，先做一个条件判断，判断一下这个员工到底登录了没有。如果是登录了，就可以执行正常的业务操作，如果没有登录，会直接给前端返回一个错误的信息，前端拿到这个错误信息之后会自动的跳转到登录页面。</p>
<p>我们程序中所开发的查询功能、删除功能、添加功能、修改功能，都需要使用以上套路进行登录校验。此时就会出现：相同代码逻辑，每个功能都需要编写，就会造成代码非常繁琐。</p>
<p>为了简化这块操作，我们可以使用一种技术：统一拦截技术。</p>
<p>通过统一拦截的技术，我们可以来拦截浏览器发送过来的所有的请求，拦截到这个请求之后，就可以通过请求来获取之前所存入的登录标记，在获取到登录标记且标记为登录成功，就说明员工已经登录了。如果已经登录，我们就直接放行(意思就是可以访问正常的业务接口了)。</p>
</blockquote>
<p>我们要完成以上操作，会涉及到web开发中的两个技术：</p>
<ol>
<li>会话技术</li>
<li>统一拦截技术</li>
</ol>
<p>而统一拦截技术现实方案也有两种：</p>
<ol>
<li>Servlet规范中的Filter过滤器</li>
<li>Spring提供的interceptor拦截器</li>
</ol>
<p>下面我们先学习会话技术，然后再学习统一拦截技术。</p>
<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p>介绍了登录校验的大概思路之后，我们先来学习下会话技术。</p>
<h3 id="会话技术介绍"><a href="#会话技术介绍" class="headerlink" title="会话技术介绍"></a>会话技术介绍</h3><p>什么是会话？</p>
<ul>
<li>在我们日常生活当中，会话指的就是谈话、交谈。 </li>
<li>在web开发当中，会话指的就是浏览器与服务器之间的一次连接，我们就称为一次会话。 <blockquote>
<p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p>
<p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p>
<ul>
<li>第1次：访问的是登录的接口，完成登录操作</li>
<li>第2次：访问的是部门管理接口，查询所有部门数据</li>
<li>第3次：访问的是员工管理接口，查询员工数据</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。</p>
</blockquote>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165485-777d91f3-e823-4ebb-9b5d-b68555c76b59.png"></p>
<p>需要注意的是：会话是和浏览器关联的，当有三个浏览器客户端和服务器建立了连接时，就会有三个会话。同一个浏览器在未关闭之前请求了多次服务器，这多次请求是属于同一个会话。比如：1、2、3这三个请求都是属于同一个会话。当我们关闭浏览器之后，这次会话就结束了。而如果我们是直接把web服务器关了，那么所有的会话就都结束了。</p>
<p>知道了会话的概念了，接下来我们再来了解下会话跟踪。</p>
<p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p>
<blockquote>
<p>服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我们就称为会话跟踪。</p>
</blockquote>
<p>我们使用会话跟踪技术就是要完成在同一个会话中，多个请求之间进行共享数据。</p>
<blockquote>
<p>为什么要共享数据呢？</p>
<p>由于HTTP是无状态协议，在后面请求中怎么拿到前一次请求生成的数据呢？此时就需要在一次会话的多次请求之间进行数据共享</p>
</blockquote>
<p>会话跟踪技术有两种：</p>
<ol>
<li>Cookie（客户端会话跟踪技术） <ul>
<li>数据存储在客户端浏览器当中</li>
</ul>
</li>
<li>Session（服务端会话跟踪技术） <ul>
<li>数据存储在储在服务端</li>
</ul>
</li>
<li>令牌技术</li>
</ol>
<h3 id="会话跟踪方案"><a href="#会话跟踪方案" class="headerlink" title="会话跟踪方案"></a>会话跟踪方案</h3><p>上面我们介绍了什么是会话，什么是会话跟踪，并且也提到了会话跟踪 3 种常见的技术方案。接下来，我们就来对比一下这 3 种会话跟踪的技术方案，来看一下具体的实现思路，以及它们之间的优缺点。</p>
<h4 id="方案一-Cookie"><a href="#方案一-Cookie" class="headerlink" title="方案一 - Cookie"></a>方案一 - Cookie</h4><p><strong>cookie 是客户端会话跟踪技术</strong>，它是存储在客户端浏览器的，我们使用 cookie 来跟踪会话，我们就可以在浏览器第一次发起请求来请求服务器的时候，我们在服务器端来设置一个cookie。</p>
<p>比如第一次请求了登录接口，登录接口执行完成之后，我们就可以设置一个cookie，在 cookie 当中我们就可以来存储用户相关的一些数据信息。比如我可以在 cookie 当中来存储当前登录用户的用户名，用户的ID。</p>
<p>服务器端在给客户端在响应数据的时候，会<strong>自动</strong>的将 cookie 响应给浏览器，浏览器接收到响应回来的 cookie 之后，会<strong>自动</strong>的将 cookie 的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的 cookie <strong>自动</strong>地携带到服务端。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165579-a95e0d2c-3212-4dd2-b724-ebc856e1f122.png"></p>
<p>接下来在服务端我们就可以获取到 cookie 的值。我们可以去判断一下这个 cookie 的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在 cookie 的值，就说明客户端之前已经登录完成了。这样我们就可以基于 cookie 在同一次会话的不同请求之间来共享数据。</p>
<p>我刚才在介绍流程的时候，用了 3 个自动：</p>
<ul>
<li>服务器会 <strong>自动</strong> 的将 cookie 响应给浏览器。 </li>
<li>浏览器接收到响应回来的数据之后，会 <strong>自动</strong> 的将 cookie 存储在浏览器本地。 </li>
<li>在后续的请求当中，浏览器会 <strong>自动</strong> 的将 cookie 携带到服务器端。</li>
</ul>
<p><strong>为什么这一切都是自动化进行的？</strong></p>
<p>是因为 cookie 它是 HTP 协议当中所支持的技术，而各大浏览器厂商都支持了这一标准。在 HTTP 协议官方给我们提供了一个响应头和请求头：</p>
<ul>
<li>响应头 Set-Cookie ：设置Cookie数据的 </li>
<li>请求头 Cookie：携带Cookie数据的</li>
</ul>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165678-73345fc4-c455-4763-b059-7e2b1229d533.png"></p>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping("/c1")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie1</span><span class="params">(HttpServletResponse response)</span>{</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">"login_username"</span>,<span class="string">"itheima"</span>)); <span class="comment">//设置Cookie/响应Cookie</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping("/c2")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie2</span><span class="params">(HttpServletRequest request)</span>{</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) {</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(<span class="string">"login_username"</span>)){</span><br><span class="line">                System.out.println(<span class="string">"login_username: "</span>+cookie.getValue()); <span class="comment">//输出name为login_username的cookie</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>A. 访问c1接口，设置Cookie，<a href="http://localhost:8080/c1">http://localhost:8080/c1</a></p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165792-19d666b1-48c7-4a1b-84fe-312a2a6a6edf.png"></p>
<p>我们可以看到，设置的cookie，通过<strong>响应头Set-Cookie</strong>响应给浏览器，并且浏览器会将Cookie，存储在浏览器端。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105165910-88a598d0-f7a9-49f0-9a9f-4c912c74ac0c.png"></p>
<p>B. 访问c2接口 <a href="http://localhost:8080/c2%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%9A%84%E5%B0%86Cookie%E6%90%BA%E5%B8%A6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E6%98%AF%E9%80%9A%E8%BF%87**%E8%AF%B7%E6%B1%82%E5%A4%B4Cookie**%EF%BC%8C%E6%90%BA%E5%B8%A6%E7%9A%84%E3%80%82">http://localhost:8080/c2，此时浏览器会自动的将Cookie携带到服务端，是通过**请求头Cookie**，携带的。</a></p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166049-edd46b83-099b-4ca5-9675-b32d95a263aa.png"></p>
<p><strong>优缺点</strong></p>
<ul>
<li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带，都是浏览器自动进行的，是无需我们手动操作的）</li>
<li>缺点： <ul>
<li>移动端APP(Android、IOS)中无法使用Cookie</li>
<li>不安全，用户可以自己禁用Cookie</li>
<li>Cookie不能跨域</li>
</ul>
</li>
</ul>
<blockquote>
<p>跨域介绍：</p>
<pre><code> ![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706105166167-30f0ad7b-1a75-4af2-8614-ff0671aa7177.png#averageHue=%23f8f2ed&amp;id=j5ptC&amp;originHeight=406&amp;originWidth=1000&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<ul>
<li>现在的项目，大部分都是前后端分离的，前后端最终也会分开部署，前端部署在服务器 192.168.150.200 上，端口 80，后端部署在 192.168.150.100上，端口 8080</li>
<li>我们打开浏览器直接访问前端工程，访问url：<a href="http://_192.168.150.200_login/">http://192.168.150.200/login.html</a></li>
<li>然后在该页面发起请求到服务端，而服务端所在地址不再是localhost，而是服务器的IP地址192.168.150.100，假设访问接口地址为：<a href="http://192.168.150.100:8080/login">http://192.168.150.100:8080/login</a></li>
<li>那此时就存在跨域操作了，因为我们是在 <a href="http://_192.168.150.200_login/">http://192.168.150.200/login.html</a> 这个页面上访问了<a href="http://192.168.150.100:8080/login">http://192.168.150.100:8080/login</a> 接口</li>
<li>此时如果服务器设置了一个Cookie，这个Cookie是不能使用的，因为Cookie无法跨域</li>
</ul>
</blockquote>
<blockquote>
<p>区分跨域的维度：</p>
<ul>
<li>协议</li>
<li>IP/协议</li>
<li>端口</li>
</ul>
</blockquote>
<blockquote>
<p>只要上述的三个维度有任何一个维度不同，那就是跨域操作</p>
<p>举例：</p>
<pre><code>[http://192.168.150.200/login.html](http:_192.168.150.200_login) ----------&gt; [https://192.168.150.200/login](https://192.168.150.200/login) &nbsp; 		[协议不同，跨域]
                 
[http://192.168.150.200/login.html](http:_192.168.150.200_login) ----------&gt; [http://192.168.150.100/login](http://192.168.150.100/login) &nbsp; &nbsp; 		[IP不同，跨域]
                 
[http://192.168.150.200/login.html](http:_192.168.150.200_login) ----------&gt; [http://192.168.150.200:8080/login](http://192.168.150.200:8080/login) &nbsp; [端口不同，跨域]
</code></pre>
<p> &nbsp; &nbsp;<a href="http://_192.168.150.200_login/">http://192.168.150.200/login.html</a> ———-&gt; <a href="http://192.168.150.200/login">http://192.168.150.200/login</a> &nbsp; &nbsp;		 [不跨域]</p>
</blockquote>
<h4 id="方案二-Session"><a href="#方案二-Session" class="headerlink" title="方案二 - Session"></a>方案二 - Session</h4><p>前面介绍的时候，我们提到Session，<strong>它是服务器端会话跟踪技术</strong>，所以它是存储在服务器端的。而 Session 的底层其实就是基于我们刚才所介绍的 Cookie 来实现的。</p>
<ul>
<li>获取Session<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166256-bed33c3f-8a41-47ba-8b8a-2cf0bc3734f5.png"><br>如果我们现在要基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，我们就可以直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），我们称之为 Session 的ID。 </li>
<li>响应Cookie (JSESSIONID)<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166338-3c124015-5dca-4579-a8cd-0f8f33b62f44.png"><br>接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个 &nbsp;Set-Cookie &nbsp;响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。 </li>
<li>查找Session<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166427-4a3ab2ff-d2aa-47f6-bdf0-94d4b579a56e.png"><br>接下来，在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。接下来服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。<br>这样我们是不是就可以通过 Session 会话对象在同一次会话的多次请求之间来共享数据了？好，这就是基于 Session 进行会话跟踪的流程。</li>
</ul>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/s1")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session1</span><span class="params">(HttpSession session)</span>{</span><br><span class="line">        log.info(<span class="string">"HttpSession-s1: {}"</span>, session.hashCode());</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">"loginUser"</span>, <span class="string">"tom"</span>); <span class="comment">//往session中存储数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/s2")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session2</span><span class="params">(HttpServletRequest request)</span>{</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        log.info(<span class="string">"HttpSession-s2: {}"</span>, session.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">"loginUser"</span>); <span class="comment">//从session中获取数据</span></span><br><span class="line">        log.info(<span class="string">"loginUser: {}"</span>, loginUser);</span><br><span class="line">        <span class="keyword">return</span> Result.success(loginUser);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>A. 访问 s1 接口，<a href="http://localhost:8080/s1">http://localhost:8080/s1</a></p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166515-054a5251-56fc-438f-ab1f-d02669a0f416.png"></p>
<p>请求完成之后，在响应头中，就会看到有一个Set-Cookie的响应头，里面响应回来了一个Cookie，就是JSESSIONID，这个就是服务端会话对象 Session 的ID。</p>
<p>B. 访问 s2 接口，<a href="http://localhost:8080/s2">http://localhost:8080/s2</a></p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166658-ba7a3e11-8bf5-4a41-abfa-3b718dd11f7a.png"></p>
<p>接下来，在后续的每次请求时，都会将Cookie的值，携带到服务端，那服务端呢，接收到Cookie之后，会自动的根据JSESSIONID的值，找到对应的会话对象Session。</p>
<p>那经过这两步测试，大家也会看到，在控制台中输出如下日志：</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105166785-20b03734-2249-4614-86de-4e7a454063da.png"></p>
<p>两次请求，获取到的Session会话对象的hashcode是一样的，就说明是同一个会话对象。而且，第一次请求时，往Session会话对象中存储的值，第二次请求时，也获取到了。 那这样，我们就可以通过Session会话对象，在同一个会话的多次请求之间来进行数据共享了。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>优点：Session是存储在服务端的，安全</li>
<li>缺点： <ul>
<li>服务器集群环境下无法直接使用Session</li>
<li>移动端APP(Android、IOS)中无法使用Cookie</li>
<li>用户可以自己禁用Cookie</li>
<li>Cookie不能跨域</li>
</ul>
</li>
</ul>
<blockquote>
<p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案，也就失效了。</p>
</blockquote>
<blockquote>
<p>服务器集群环境为何无法使用Session？</p>
<pre><code>![](https://cdn.nlark.com/yuque/0/2024/png/22976360/1706105166897-fd457716-58a6-4e4d-a17e-91b8cc402403.png#averageHue=%23f8eee6&amp;id=lPzUp&amp;originHeight=132&amp;originWidth=540&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<ul>
<li>首先第一点，我们现在所开发的项目，一般都不会只部署在一台服务器上，因为一台服务器会存在一个很大的问题，就是单点故障。所谓单点故障，指的就是一旦这台服务器挂了，整个应用都没法访问了。</li>
</ul>
</blockquote>
<blockquote>
<p> &nbsp; &nbsp;<img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167033-97bb2c75-575e-42d9-9336-7028fb075da8.png"></p>
<ul>
<li>所以在现在的企业项目开发当中，最终部署的时候都是以集群的形式来进行部署，也就是同一个项目它会部署多份。比如这个项目我们现在就部署了 3 份。 </li>
<li>而用户在访问的时候，到底访问这三台其中的哪一台？其实用户在访问的时候，他会访问一台前置的服务器，我们叫负载均衡服务器，我们在后面项目当中会详细讲解。目前大家先有一个印象负载均衡服务器，它的作用就是将前端发起的请求均匀的分发给后面的这三台服务器。<br><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167122-1608aec0-5860-462a-8c06-28d302527326.png"> </li>
<li>此时假如我们通过 session 来进行会话跟踪，可能就会存在这样一个问题。用户打开浏览器要进行登录操作，此时会发起登录请求。登录请求到达负载均衡服务器，将这个请求转给了第一台 Tomcat 服务器。<br>Tomcat 服务器接收到请求之后，要获取到会话对象session。获取到会话对象 session 之后，要给浏览器响应数据，最终在给浏览器响应数据的时候，就会携带这么一个 cookie 的名字，就是 JSESSIONID ，下一次再请求的时候，是不是又会将 Cookie 携带到服务端？<br>好。此时假如又执行了一次查询操作，要查询部门的数据。这次请求到达负载均衡服务器之后，负载均衡服务器将这次请求转给了第二台 Tomcat 服务器，此时他就要到第二台 Tomcat 服务器当中。根据JSESSIONID 也就是对应的 session 的 ID 值，要找对应的 session 会话对象。<br>我想请问在第二台服务器当中有没有这个ID的会话对象 Session， 是没有的。此时是不是就出现问题了？我同一个浏览器发起了 2 次请求，结果获取到的不是同一个会话对象，这就是Session这种会话跟踪方案它的缺点，在服务器集群环境下无法直接使用Session。</li>
</ul>
</blockquote>
<p>大家会看到上面这两种传统的会话技术，在现在的企业开发当中是不是会存在很多的问题。 为了解决这些问题，在现在的企业开发当中，基本上都会采用第三种方案，通过令牌技术来进行会话跟踪。接下来我们就来介绍一下令牌技术，来看一下令牌技术又是如何跟踪会话的。</p>
<h4 id="方案三-令牌技术"><a href="#方案三-令牌技术" class="headerlink" title="方案三 - 令牌技术"></a>方案三 - 令牌技术</h4><p>这里我们所提到的令牌，其实它就是一个用户身份的标识，看似很高大上，很神秘，其实本质就是一个字符串。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167224-656fbfaa-21eb-4ffe-83cb-38501c91c38c.png"></p>
<p>如果通过令牌技术来跟踪会话，我们就可以在浏览器发起请求。在请求登录接口的时候，如果登录成功，我就可以生成一个令牌，令牌就是用户的合法身份凭证。接下来我在响应数据的时候，我就可以直接将令牌响应给前端。</p>
<p>接下来我们在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。</p>
<p>接下来，在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。</p>
<p>此时，如果是在同一次会话的多次请求之间，我们想共享数据，我们就可以将共享的数据存储在令牌当中就可以了。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>优点： <ul>
<li>支持PC端、移动端</li>
<li>解决集群环境下的认证问题</li>
<li>减轻服务器的存储压力（无需在服务器端存储）</li>
</ul>
</li>
<li>缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）</li>
</ul>
<p><strong>针对于这三种方案，现在企业开发当中使用的最多的就是第三种令牌技术进行会话跟踪。而前面的这两种传统的方案，现在企业项目开发当中已经很少使用了。所以在我们的课程当中，我们也将会采用令牌技术来解决案例项目当中的会话跟踪问题。</strong></p>
<h2 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h2><p>前面我们介绍了基于令牌技术来实现会话追踪。这里所提到的令牌就是用户身份的标识，其本质就是一个字符串。令牌的形式有很多，我们使用的是功能强大的 JWT令牌。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>JWT全称：JSON Web Token &nbsp;（官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p>
<ul>
<li>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。 <blockquote>
<p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。</p>
<p>自包含：指的是jwt令牌，看似是一个随机的字符串，但是我们是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。</p>
<p>简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。</p>
</blockquote>
</li>
</ul>
<p>JWT的组成： （JWT令牌由三个部分组成，三个部分之间使用英文的点来分割）</p>
<ul>
<li>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{“alg”:”HS256”,”type”:”JWT”} </li>
<li>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{“id”:”1”,”username”:”Tom”} </li>
<li>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。 <blockquote>
<p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，所以整个jwt 令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败，所以它是非常安全可靠的。</p>
</blockquote>
</li>
</ul>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167404-2d10f9e1-d7a8-4042-8e45-0d2b382a837e.png"></p>
<blockquote>
<p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p>
<p>其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码</p>
<p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p>
<p>需要注意的是Base64是编码方式，而不是加密方式。</p>
</blockquote>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167494-86b6b78c-3114-4cf1-a435-25eef3e6ab79.png"></p>
<p>JWT令牌最典型的应用场景就是登录认证：</p>
<ol>
<li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。</li>
<li>前端拿到jwt令牌之后，会将jwt令牌存储起来。在后续的每一次请求中都会将jwt令牌携带到服务端。</li>
<li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。</li>
</ol>
<p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：</p>
<ol>
<li>在登录成功之后，要生成令牌。</li>
<li>每一次请求当中，要接收令牌并对令牌进行校验。</li>
</ol>
<p>稍后我们再来学习如何来生成jwt令牌，以及如何来校验jwt令牌。</p>
<h3 id="生成和校验"><a href="#生成和校验" class="headerlink" title="生成和校验"></a>生成和校验</h3><p>简单介绍了JWT令牌以及JWT令牌的组成之后，接下来我们就来学习基于Java代码如何生成和校验JWT令牌。</p>
<p>首先我们先来实现JWT令牌的生成。要想使用JWT令牌，需要先引入JWT的依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在引入完JWT来赖后，就可以调用工具包中提供的API来完成JWT令牌的生成和校验</p>
<p>工具类：Jwts</p>
</blockquote>
<p>生成JWT代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>{</span><br><span class="line">    Map&lt;String,Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">    claims.put(<span class="string">"username"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .setClaims(claims) <span class="comment">//自定义内容(载荷)          </span></span><br><span class="line">        .signWith(SignatureAlgorithm.HS256, <span class="string">"itheima"</span>) <span class="comment">//签名算法        </span></span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>)) <span class="comment">//有效期   </span></span><br><span class="line">        .compact();</span><br><span class="line">    </span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行测试方法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk</span><br></pre></td></tr></tbody></table></figure>

<p>输出的结果就是生成的JWT令牌,，通过英文的点分割对三个部分进行分割，我们可以将生成的令牌复制一下，然后打开JWT的官网，将生成的令牌直接放在Encoded位置，此时就会自动的将令牌解析出来。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167590-7316eaf8-87e5-44ac-ac2f-b8bb7154238a.png"></p>
<blockquote>
<p>第一部分解析出来，看到JSON格式的原始数据，所使用的签名算法为HS256。</p>
<p>第二个部分是我们自定义的数据，之前我们自定义的数据就是id，还有一个exp代表的是我们所设置的过期时间。</p>
<p>由于前两个部分是base64编码，所以是可以直接解码出来。但最后一个部分并不是base64编码，是经过签名算法计算出来的，所以最后一个部分是不会解析的。</p>
</blockquote>
<p>实现了JWT令牌的生成，下面我们接着使用Java代码来校验JWT令牌(解析生成的令牌)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(<span class="string">"itheima"</span>)<span class="comment">//指定签名密钥（必须保证和生成令牌时使用相同的签名密钥）  </span></span><br><span class="line">	    .parseClaimsJws(<span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk"</span>)</span><br><span class="line">        .getBody();</span><br><span class="line"></span><br><span class="line">    System.out.println(claims);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行测试方法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{id=1, exp=1672729730}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>令牌解析后，我们可以看到id和过期时间，如果在解析的过程当中没有报错，就说明解析成功了。</p>
</blockquote>
<p>下面我们做一个测试：把令牌header中的数字9变为8，运行测试方法后发现报错：</p>
<blockquote>
<p>原header： eyJhbGciOiJIUzI1NiJ9</p>
<p>修改为： eyJhbGciOiJIUzI1NiJ8</p>
</blockquote>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167689-b4b49da4-73d4-4398-8835-2cecf365d003.png"></p>
<p>结论：篡改令牌中的任何一个字符，在对令牌进行解析时都会报错，所以JWT令牌是非常安全可靠的。</p>
<p>我们继续测试：修改生成令牌的时指定的过期时间，修改为1分钟</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>{</span><br><span class="line">    Map&lt;String,Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(“id”,<span class="number">1</span>);</span><br><span class="line">    claims.put(“username”,“Tom”);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .setClaims(claims) <span class="comment">//自定义内容(载荷)          </span></span><br><span class="line">        .signWith(SignatureAlgorithm.HS256, “itheima”) <span class="comment">//签名算法        </span></span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">60</span>*<span class="number">1000</span>)) <span class="comment">//有效期60秒   </span></span><br><span class="line">        .compact();</span><br><span class="line">    </span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">    <span class="comment">//输出结果：eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(<span class="string">"itheima"</span>)<span class="comment">//指定签名密钥</span></span><br><span class="line">.parseClaimsJws(<span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro"</span>)</span><br><span class="line">        .getBody();</span><br><span class="line"></span><br><span class="line">    System.out.println(claims);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>等待1分钟之后运行测试方法发现也报错了，说明：JWT令牌过期后，令牌就失效了，解析的为非法令牌。</p>
<p>通过以上测试，我们在使用JWT令牌时需要注意：</p>
<ul>
<li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。 </li>
<li>如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。</li>
</ul>
<h3 id="登录下发令牌"><a href="#登录下发令牌" class="headerlink" title="登录下发令牌"></a>登录下发令牌</h3><p>JWT令牌的生成和校验的基本操作我们已经学习完了，接下来我们就需要在案例当中通过JWT令牌技术来跟踪会话。具体的思路我们前面已经分析过了，主要就是两步操作：</p>
<ol>
<li>生成令牌 <ul>
<li>在登录成功之后来生成一个JWT令牌，并且把这个令牌直接返回给前端</li>
</ul>
</li>
<li>校验令牌 <ul>
<li>拦截前端请求，从请求中获取到令牌，对令牌进行解析校验</li>
</ul>
</li>
</ol>
<p>那我们首先来完成：登录成功之后生成JWT令牌，并且把令牌返回给前端。</p>
<p>JWT令牌怎么返回给前端呢？此时我们就需要再来看一下接口文档当中关于登录接口的描述（主要看响应数据）：</p>
<ul>
<li><p>响应数据<br>参数格式：application/json<br>参数说明： </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>备注</th>
<th>其他信息</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>number</td>
<td>必须</td>
<td></td>
<td>响应码, 1 成功 ; 0 &nbsp;失败</td>
<td></td>
</tr>
<tr>
<td>msg</td>
<td>string</td>
<td>非必须</td>
<td></td>
<td>提示信息</td>
<td></td>
</tr>
<tr>
<td>data</td>
<td>string</td>
<td>必须</td>
<td></td>
<td>返回的数据 , jwt令牌</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>响应数据样例： </p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"code"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"msg"</span><span class="punctuation">:</span> <span class="string">"success"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"data"</span><span class="punctuation">:</span> <span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

</li>
<li><p>备注说明<br>用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头header中携带到服务端，请求头的名称为 token ，值为 登录时下发的JWT令牌。<br>如果检测到用户未登录，则会返回如下固定错误信息： </p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">	<span class="attr">"code"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">"msg"</span><span class="punctuation">:</span> <span class="string">"NOT_LOGIN"</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">"data"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>解读完接口文档中的描述了，目前我们先来完成令牌的生成和令牌的下发，我们只需要生成一个令牌返回给前端就可以了。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>引入JWT工具类 <ul>
<li>在项目工程下创建com.itheima.utils包，并把提供JWT工具类复制到该包下</li>
</ul>
</li>
<li>登录完成后，调用工具类生成JWT令牌并返回</li>
</ol>
<p><strong>JWT工具类</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">signKey</span> <span class="operator">=</span> <span class="string">"itheima"</span>;<span class="comment">//签名密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">43200000L</span>; <span class="comment">//有效时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateJwt</span><span class="params">(Map&lt;String, Object&gt; claims)</span>{</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .addClaims(claims)<span class="comment">//自定义信息（有效载荷）</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, signKey)<span class="comment">//签名算法（头部）</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expire))<span class="comment">//过期时间</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span>{</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(signKey)<span class="comment">//指定签名密钥</span></span><br><span class="line">                .parseClaimsJws(jwt)<span class="comment">//指定令牌Token</span></span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>登录成功，生成JWT令牌并返回</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> {</span><br><span class="line">    <span class="comment">//依赖业务层对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpService empService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping("/login")</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> Emp emp)</span> {</span><br><span class="line">        <span class="comment">//调用业务层：登录功能</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">loginEmp</span> <span class="operator">=</span> empService.login(emp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断：登录用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(loginEmp !=<span class="literal">null</span> ){</span><br><span class="line">            <span class="comment">//自定义信息</span></span><br><span class="line">            Map&lt;String , Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            claims.put(<span class="string">"id"</span>, loginEmp.getId());</span><br><span class="line">            claims.put(<span class="string">"username"</span>,loginEmp.getUsername());</span><br><span class="line">            claims.put(<span class="string">"name"</span>,loginEmp.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用JWT工具类，生成身份令牌</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateJwt(claims);</span><br><span class="line">            <span class="keyword">return</span> Result.success(token);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>重启服务，打开postman测试登录接口：</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167780-61fb5af5-684a-4fdf-9810-c090c89c0acc.png"></p>
<p>打开浏览器完成前后端联调操作：利用开发者工具，抓取一下网络请求</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167878-c9395452-c79d-4c78-8f0f-555fbb5140b1.png"></p>
<blockquote>
<p>登录请求完成后，可以看到JWT令牌已经响应给了前端，此时前端就会将JWT令牌存储在浏览器本地。</p>
</blockquote>
<p>服务器响应的JWT令牌存储在本地浏览器哪里了呢？</p>
<ul>
<li>在当前案例中，JWT令牌存储在浏览器的本地存储空间local storage中了。 local storage是浏览器的本地存储，在移动端也是支持的。</li>
</ul>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105167995-50c6386c-38d3-4ae3-8068-7349d25e785f.png"></p>
<p>我们在发起一个查询部门数据的请求，此时我们可以看到在请求头中包含一个token(JWT令牌)，后续的每一次请求当中，都会将这个令牌携带到服务端。</p>
<p><img src="/./img/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/1706105168097-d26ea7d6-fec5-42ac-becf-cf8867bd0bb3.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://ylcheng1789.github.io">程月龙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://ylcheng1789.github.io/2024/04/10/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/">http://ylcheng1789.github.io/2024/04/10/SpringBoot-%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ylcheng1789.github.io" target="_blank">Loong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><a class="post-meta__tags" href="/tags/Java%E5%BC%80%E5%8F%91/">Java开发</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg" data-sites="weibo,wechat,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏一下~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_trade.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_trade.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay_trade.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay_trade.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/05/10/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/" title="SpringBoot-过滤器拦截器"><img class="cover" src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot-过滤器拦截器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/10/SpringBoot-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/" title="SpringBoot-全局异常处理器"><img class="cover" src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-10</div><div class="title">SpringBoot-全局异常处理器</div></div></a></div><div><a href="/2024/05/11/SpringBoot-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" title="SpringBoot-事务管理"><img class="cover" src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-11</div><div class="title">SpringBoot-事务管理</div></div></a></div><div><a href="/2024/05/12/SpringBoot-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/" title="SpringBoot-AOP切面编程"><img class="cover" src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-12</div><div class="title">SpringBoot-AOP切面编程</div></div></a></div><div><a href="/2024/05/10/SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8/" title="SpringBoot-过滤器拦截器"><img class="cover" src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291710462.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-10</div><div class="title">SpringBoot-过滤器拦截器</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cyl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">程月龙</div><div class="author-info__description">技术博客、独立开发者、Java开发、Python开发、人工智能</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://github.com/ylcheng1789"><i class="fas fa-video"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ylcheng1789" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/ylcheng1789@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/19834521789" target="_blank" title="Phone"><i class="fas fa-square-phone-flip" style="color: #00c4b6;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Loong开发，致力于为猿友们提供有价值的内容</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.</span> <span class="toc-text">登录校验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.</span> <span class="toc-text">会话技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">会话技术介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">会话跟踪方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80-Cookie"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">方案一 - Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C-Session"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">方案二 - Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89-%E4%BB%A4%E7%89%8C%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">方案三 - 令牌技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JWT%E4%BB%A4%E7%89%8C"><span class="toc-number">1.3.</span> <span class="toc-text">JWT令牌</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%92%8C%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">生成和校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E4%B8%8B%E5%8F%91%E4%BB%A4%E7%89%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">登录下发令牌</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/" title="我的博客优化历程—自动初始化Gitalk"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408301832793.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的博客优化历程—自动初始化Gitalk"></a><div class="content"><a class="title" href="/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/" title="我的博客优化历程—自动初始化Gitalk">我的博客优化历程—自动初始化Gitalk</a><time datetime="2024-08-11T13:01:24.000Z" title="发表于 2024-08-11 21:01:24">2024-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/" title="一起写个数据库—10.服务端客户端的实现及其通信规则"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—10.服务端客户端的实现及其通信规则"></a><div class="content"><a class="title" href="/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/" title="一起写个数据库—10.服务端客户端的实现及其通信规则">一起写个数据库—10.服务端客户端的实现及其通信规则</a><time datetime="2024-06-11T13:01:24.000Z" title="发表于 2024-06-11 21:01:24">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/" title="一起写个数据库—9.字段与表管理"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—9.字段与表管理"></a><div class="content"><a class="title" href="/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/" title="一起写个数据库—9.字段与表管理">一起写个数据库—9.字段与表管理</a><time datetime="2024-06-10T13:01:24.000Z" title="发表于 2024-06-10 21:01:24">2024-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/09/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%948.%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E5%99%A8/" title="一起写个数据库—8.索引管理器"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—8.索引管理器"></a><div class="content"><a class="title" href="/2024/06/09/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%948.%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E5%99%A8/" title="一起写个数据库—8.索引管理器">一起写个数据库—8.索引管理器</a><time datetime="2024-06-09T13:01:24.000Z" title="发表于 2024-06-09 21:01:24">2024-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/08/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%947.%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8EVM%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="一起写个数据库—7.死锁检测与VM的实现"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—7.死锁检测与VM的实现"></a><div class="content"><a class="title" href="/2024/06/08/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%947.%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8EVM%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="一起写个数据库—7.死锁检测与VM的实现">一起写个数据库—7.死锁检测与VM的实现</a><time datetime="2024-06-08T13:01:24.000Z" title="发表于 2024-06-08 21:01:24">2024-06-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2017 - 2024 By 程月龙</div><div class="footer_custom_text">Copyright© Loong开发-独立开发者的日常总结<br></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liYCRlnpOTAGppwh',
      clientSecret: '5905e4c39a53de631adc5959cec17edba0d64cfe',
      repo: 'ylcheng1789.github.io',
      owner: 'ylcheng1789',
      admin: ['ylcheng1789'],
      id: '69f183cb04a131a9344e2c9c0a8935b4',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>