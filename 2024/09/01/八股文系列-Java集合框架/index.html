<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>八股文系列-Java集合框架 | Loong</title><meta name="author" content="程月龙"><meta name="copyright" content="程月龙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="八股文系列-Java集合框架">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文系列-Java集合框架">
<meta property="og:url" content="http://ylcheng1789.github.io/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Loong">
<meta property="og:description" content="八股文系列-Java集合框架">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg">
<meta property="article:published_time" content="2024-09-01T05:22:24.000Z">
<meta property="article:modified_time" content="2024-09-01T05:45:42.942Z">
<meta property="article:author" content="程月龙">
<meta property="article:tag" content="Java集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://ylcheng1789.github.io/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ae9ce48d24501920dfa510977fa6cdad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '八股文系列-Java集合框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-01 13:45:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Loong" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cyl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408290048644.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Loong"><img class="site-icon" src="/img/logo.png"><span class="site-name">Loong</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">八股文系列-Java集合框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-01T05:22:24.000Z" title="发表于 2024-09-01 13:22:24">2024-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-01T05:45:42.942Z" title="更新于 2024-09-01 13:45:42">2024-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="八股文系列-Java集合框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408290048644.png');"></div><article class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="1-说说有哪些常见的集合框架？"><a href="#1-说说有哪些常见的集合框架？" class="headerlink" title="1.说说有哪些常见的集合框架？"></a>1.说说有哪些常见的集合框架？</h3><p>Java 集合框架可以分为两条大的支线：<br>①、Collection，主要由 List、Set、Queue 组成：</p>
<ul>
<li>List 代表有序、可重复的集合，典型代表就是封装了动态数组的 <a href="https://javabetter.cn/collection/arraylist.html">ArrayList</a> 和封装了链表的 <a href="https://javabetter.cn/collection/linkedlist.html">LinkedList</a>；</li>
<li>Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；</li>
<li>Queue 代表队列，典型代表就是双端队列 <a href="https://javabetter.cn/collection/arraydeque.html">ArrayDeque</a>，以及优先级队列 <a href="https://javabetter.cn/collection/PriorityQueue.html">PriorityQueue</a>。</li>
</ul>
<p>②、Map，代表键值对的集合，典型代表就是 <a href="https://javabetter.cn/collection/hashmap.html">HashMap</a>。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/gailan-01.png"><br>概览图说明：<br>①、Collection 接口：最基本的集合框架表示方式，提供了添加、删除、清空等基本操作，它主要有三个子接口：</p>
<ul>
<li><code>List</code>：一个有序的集合，可以包含重复的元素。实现类包括 ArrayList、LinkedList 等。</li>
<li><code>Set</code>：一个不包含重复元素的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。</li>
<li><code>Queue</code>：一个用于保持元素队列的集合。实现类包括 PriorityQueue、ArrayDeque 等。</li>
</ul>
<p>②、<code>Map</code> 接口：表示键值对的集合，一个键映射到一个值。键不能重复，每个键只能对应一个值。Map 接口的实现类包括 HashMap、LinkedHashMap、TreeMap 等。<br>集合框架位于 java.util 包下，该包含提供了两个常用的工具类：</p>
<ul>
<li><a href="https://javabetter.cn/common-tool/collections.html">Collections</a>：提供了一些对集合进行排序、二分查找、同步的静态方法。</li>
<li><a href="https://javabetter.cn/common-tool/arrays.html">Arrays</a>：提供了一些对数组进行排序、打印、和 List 进行转换的静态方法。</li>
</ul>
<h4 id="简单介绍一下队列-Queue"><a href="#简单介绍一下队列-Queue" class="headerlink" title="简单介绍一下队列 Queue"></a>简单介绍一下队列 Queue</h4><p>Java 中的队列主要通过 java.util.Queue 接口和 java.util.concurrent.BlockingQueue 两个接口来实现。<br>PriorityQueue 是一个基于优先级堆的无界队列，它的元素按照自然顺序排序或者 Comparator 进行排序。<br>ArrayDeque 是一个基于数组的双端队列，可以在两端插入和删除元素。<br>LinkedList，它既可以当作 List 使用，也可以当作 Queue 使用。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/list-war-2-02.png"></p>
<h4 id="用过哪些集合类，它们的优劣？"><a href="#用过哪些集合类，它们的优劣？" class="headerlink" title="用过哪些集合类，它们的优劣？"></a>用过哪些集合类，它们的优劣？</h4><p>在 Java 中，常用的集合类有 ArrayList、LinkedList、HashMap、LinkedHashMap 等。</p>
<ol>
<li>ArrayList：ArrayList 可以看作是一个动态数组，它可以在运行时动态扩容。优点是访问速度快，可以通过索引直接查到元素。缺点是插入和删除元素可能需要移动元素，效率就会降低。</li>
<li>LinkedList：LinkedList 是一个双向链表，它适合频繁的插入和删除操作。优点是插入和删除元素的时候只需要改变节点的前后指针，缺点是访问元素时需要遍历链表。</li>
<li>HashMap：HashMap 是一个基于哈希表的键值对集合。优点是插入、删除和查找元素的速度都很快。缺点是它不保留键值对的插入顺序。</li>
<li>LinkedHashMap：LinkedHashMap 在 HashMap 的基础上增加了一个双向链表来保持键值对的插入顺序。</li>
</ol>
<h4 id="队列和栈的区别了解吗？"><a href="#队列和栈的区别了解吗？" class="headerlink" title="队列和栈的区别了解吗？"></a>队列和栈的区别了解吗？</h4><p>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构。在队列中，第一个加入队列的元素会是第一个被移除的。队列常用于处理按顺序来的任务。<br>栈是一种后进先出（LIFO, Last-In-First-Out）的数据结构。在这种结构中，最后一个加入栈的元素会是第一个被移除的。这种特性使得栈非常适合于那些需要访问最新添加的数据元素的场合。</p>
<h4 id="哪些是线程安全的？"><a href="#哪些是线程安全的？" class="headerlink" title="哪些是线程安全的？"></a>哪些是线程安全的？</h4><p>像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 这些都是线程安全的。</p>
<h4 id="Java-集合用过哪些？Collection-继承了哪些接口？"><a href="#Java-集合用过哪些？Collection-继承了哪些接口？" class="headerlink" title="Java 集合用过哪些？Collection 继承了哪些接口？"></a>Java 集合用过哪些？Collection 继承了哪些接口？</h4><p>最经常用的就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；以及键值对 HashMap。<br>Collection 继承了 Iterable 接口，这意味着所有实现 Collection 接口的类都必须实现 <code>iterator()</code> 方法，之后就可以使用增强型 for 循环遍历集合中的元素了。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="2-ArrayList-和-LinkedList-有什么区别？"><a href="#2-ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="2.ArrayList 和 LinkedList 有什么区别？"></a>2.ArrayList 和 LinkedList 有什么区别？</h3><p>推荐阅读：<a href="https://javabetter.cn/collection/list-war-2.html">二哥的 Java 进阶之路：ArrayList 和 LinkedList</a><br>ArrayList 和 LinkedList 的区别主要体现在数据结构、用途、是否支持随机访问、内存占用等方面。</p>
<h4 id="数据结构有什么不同？"><a href="#数据结构有什么不同？" class="headerlink" title="数据结构有什么不同？"></a>数据结构有什么不同？</h4><ul>
<li>ArrayList 基于数组实现</li>
<li>LinkedList 基于链表实现</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-2.png"></p>
<h4 id="用途有什么不同？"><a href="#用途有什么不同？" class="headerlink" title="用途有什么不同？"></a>用途有什么不同？</h4><p>多数情况下，ArrayList 更利于查找，LinkedList 更利于增删<br>①、由于 ArrayList 是基于数组实现的，所以 <code>get(int index)</code> 可以直接通过数组下标获取，时间复杂度是 O(1)；LinkedList 是基于链表实现的，<code>get(int index)</code> 需要遍历链表，时间复杂度是 O(n)。<br>当然，<code>get(E element)</code> 这种查找，两种集合都需要遍历通过 equals 比较获取元素，所以时间复杂度都是 O(n)。<br>②、ArrayList 如果增删的是数组的尾部，直接插入或者删除就可以了，时间复杂度是 O(1)；如果 add 的时候涉及到扩容，时间复杂度会提升到 O(n)。<br>但如果插入的是中间的位置，就需要把插入位置后的元素向前或者向后移动，甚至还有可能触发扩容，效率就会低很多，O(n)。<br>LinkedList 因为是链表结构，插入和删除只需要改变前置节点、后置节点和插入节点的引用就行了，不需要移动元素。<br>如果是在链表的头部插入或者删除，时间复杂度是 O(1)；如果是在链表的中间插入或者删除，时间复杂度是 O(n)，因为需要遍历链表找到插入位置；如果是在链表的尾部插入或者删除，时间复杂度是 O(1)。</p>
<p>注意，这里有个陷阱，<strong>LinkedList 更利于增删不是体现在时间复杂度上</strong>，因为二者增删的时间复杂度都是 O(n)，都需要遍历列表；而是体现在增删的效率上，因为 LinkedList 的增删只需要改变引用，而 ArrayList 的增删可能需要移动元素。</p>
<h4 id="是否支持随机访问？"><a href="#是否支持随机访问？" class="headerlink" title="是否支持随机访问？"></a>是否支持随机访问？</h4><p>①、ArrayList 是基于数组的，也实现了 RandomAccess 接口，所以它支持随机访问，可以通过下标直接获取元素。<br>②、LinkedList 是基于链表的，所以它没法根据下标直接获取元素，不支持随机访问，所以它也没有实现 RandomAccess 接口。</p>
<h4 id="内存占用有何不同？"><a href="#内存占用有何不同？" class="headerlink" title="内存占用有何不同？"></a>内存占用有何不同？</h4><p>ArrayList 是基于数组的，是一块连续的内存空间，所以它的内存占用是比较紧凑的；但如果涉及到扩容，就会重新分配内存，空间是原来的 1.5 倍，存在一定的空间浪费。<br>LinkedList 是基于链表的，每个节点都有一个指向下一个节点和上一个节点的引用，于是每个节点占用的内存空间稍微大一点。</p>
<h4 id="使用场景有什么不同？"><a href="#使用场景有什么不同？" class="headerlink" title="使用场景有什么不同？"></a>使用场景有什么不同？</h4><p>ArrayList 适用于：</p>
<ul>
<li>随机访问频繁：需要频繁通过索引访问元素的场景。</li>
<li>读取操作远多于写入操作：如存储不经常改变的列表。</li>
<li>末尾添加元素：需要频繁在列表末尾添加元素的场景。</li>
</ul>
<p>LinkedList 适用于：</p>
<ul>
<li>频繁插入和删除：在列表中间频繁插入和删除元素的场景。</li>
<li>不需要快速随机访问：顺序访问多于随机访问的场景。</li>
<li>队列和栈：由于其双向链表的特性，LinkedList 可以高效地实现队列（FIFO）和栈（LIFO）。</li>
</ul>
<h3 id="3-ArrayList-的扩容机制了解吗？"><a href="#3-ArrayList-的扩容机制了解吗？" class="headerlink" title="3.ArrayList 的扩容机制了解吗？"></a>3.ArrayList 的扩容机制了解吗？</h3><p>ArrayList 确切地说，应该叫做动态数组，因为它的底层是通过数组来实现的，当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-5.png"><br>扩容后的新数组长度是原来的 1.5 倍，然后再把原数组的值拷贝到新数组中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> {</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的联想面经同学 7 面试原题：Java 集合类介绍，挑一个讲原理。</li>
</ol>
</blockquote>
<h3 id="4-ArrayList-怎么序列化的知道吗？-为什么用-transient-修饰数组？"><a href="#4-ArrayList-怎么序列化的知道吗？-为什么用-transient-修饰数组？" class="headerlink" title="4.ArrayList 怎么序列化的知道吗？ 为什么用 transient 修饰数组？"></a>4.ArrayList 怎么序列化的知道吗？ 为什么用 transient 修饰数组？</h3><p>ArrayList 的序列化不太一样，它使用<code>transient</code>修饰存储元素的<code>elementData</code>的数组，<code>transient</code>关键字的作用是让被修饰的成员属性不被序列化。<br><strong>为什么最 ArrayList 不直接序列化元素数组呢？</strong><br>出于效率的考虑，数组可能长度 100，但实际只用了 50，剩下的 50 不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。<br><strong>那 ArrayList 怎么序列化呢？</strong><br>ArrayList 通过两个方法<strong>readObject、writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>来进行序列化和反序列化。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-6.png"></p>
<h3 id="5-快速失败-fail-fast-和安全失败-fail-safe-了解吗？"><a href="#5-快速失败-fail-fast-和安全失败-fail-safe-了解吗？" class="headerlink" title="5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？"></a>5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？</h3><p><strong>快速失败（fail—fast）</strong>：快速失败是 Java 集合的一种错误检测机制</p>
<ul>
<li>在用迭代器遍历一个集合对象时，如果线程 A 遍历过程中，线程 B 对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。</li>
<li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <code> modCount</code> 变量。集合在被遍历期间如果内容发生变化，就会改变<code>modCount</code>的值。每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。</li>
<li>场景：java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如 ArrayList 类。</li>
</ul>
<p><strong>安全失败（fail—safe）</strong></p>
<ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>
<li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</li>
<li>缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>
<li>场景：java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如 CopyOnWriteArrayList 类。</li>
</ul>
<h3 id="6-有哪几种实现-ArrayList-线程安全的方法？"><a href="#6-有哪几种实现-ArrayList-线程安全的方法？" class="headerlink" title="6.有哪几种实现 ArrayList 线程安全的方法？"></a>6.有哪几种实现 ArrayList 线程安全的方法？</h3><p>可以使用 <code>Collections.synchronizedList()</code> 方法，它将返回一个线程安全的 List。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SynchronizedList</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br></pre></td></tr></tbody></table></figure>
<p>内部是通过 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>加锁来实现的。<br>也可以直接使用 <a href="https://javabetter.cn/thread/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a>，它是线程安全的，遵循写时复制的原则，每当对列表进行修改（例如添加、删除或更改元素）时，都会创建列表的一个新副本，这个新副本会替换旧的列表，而对旧列表的所有读取操作仍然可以继续。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CopyOnWriteArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>通俗的讲，CopyOnWrite 就是当我们往一个容器添加元素的时候，不直接往容器中添加，而是先复制出一个新的容器，然后在新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。多个线程在读的时候，不需要加锁，因为当前容器不会添加任何元素。这样就实现了线程安全。</p>
<h4 id="ArrayList-和-Vector-的区别？"><a href="#ArrayList-和-Vector-的区别？" class="headerlink" title="ArrayList 和 Vector 的区别？"></a>ArrayList 和 Vector 的区别？</h4><p>Vector 属于 JDK 1.0 时期的遗留类，已不推荐使用，仍然保留着是因为 Java 希望向后兼容。<br>ArrayList 是在 JDK 1.2 时引入的，用于替代 Vector 作为主要的非同步动态数组实现。因为 Vector 所有的方法都使用 synchronized 关键字进行了同步，单线程环境下效率较低。</p>
<h3 id="7-CopyOnWriteArrayList-了解多少？"><a href="#7-CopyOnWriteArrayList-了解多少？" class="headerlink" title="7.CopyOnWriteArrayList 了解多少？"></a>7.CopyOnWriteArrayList 了解多少？</h3><p>CopyOnWriteArrayList 就是线程安全版本的 ArrayList。<br>它的名字叫<code>CopyOnWrite</code>——写时复制，已经明示了它的原理。<br>CopyOnWriteArrayList 采用了一种读写分离的并发策略。CopyOnWriteArrayList 容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-7.png"></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 中，毫无疑问，最重要的就是 HashMap，面试基本被盘出包浆了，各种问法，一定要好好准备。</p>
<h3 id="8-能说一下-HashMap-的底层数据结构吗？"><a href="#8-能说一下-HashMap-的底层数据结构吗？" class="headerlink" title="8.能说一下 HashMap 的底层数据结构吗？"></a>8.能说一下 HashMap 的底层数据结构吗？</h3><p>JDK 8 中 HashMap 的数据结构是<code>数组</code>+<code>链表</code>+<code>红黑树</code>。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-8.png"><br>HashMap 的核心是一个动态数组（<code>Node[] table</code>），用于存储键值对。这个数组的每个元素称为一个“桶”（Bucket），每个桶的索引是通过对键的哈希值进行哈希函数处理得到的。<br>当多个键经哈希处理后得到相同的索引时，会发生哈希冲突。HashMap 通过链表来解决哈希冲突——即将具有相同索引的键值对通过链表连接起来。<br>不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时（且数组的长度大于 64），链表就会转换为红黑树。红黑树的查询效率是 O(logn)，比链表的 O(n) 要快。数组的查询效率是 O(1)。<br>当向 HashMap 中添加一个键值对时，会使用哈希函数计算键的哈希码，确定其在数组中的位置，哈希函数的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当向 HashMap 中添加元素时，如果该位置已有元素（发生哈希冲突），则新元素将被添加到链表的末尾或红黑树中。如果键已经存在，其对应的值将被新值覆盖。<br>当从 HashMap 中获取元素时，也会使用哈希函数计算键的位置，然后根据位置在数组、链表或者红黑树中查找元素。<br>HashMap 的初始容量是 16，随着元素的不断添加，HashMap 的容量（也就是数组大小）可能不足，于是就需要进行扩容，阈值是<code>capacity * loadFactor</code>，capacity 为容量，loadFactor 为负载因子，默认为 0.75。<br>扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。<br>总的来说，HashMap 是一种通过哈希表实现的键值对集合，它通过将键哈希化成数组索引，并在冲突时使用链表或红黑树来存储元素，从而实现快速的查找、插入和删除操作。</p>
<h3 id="9-你对红黑树了解多少？为什么不用二叉树-平衡树呢？"><a href="#9-你对红黑树了解多少？为什么不用二叉树-平衡树呢？" class="headerlink" title="9.你对红黑树了解多少？为什么不用二叉树/平衡树呢？"></a>9.你对红黑树了解多少？为什么不用二叉树/平衡树呢？</h3><p>红黑树是一种自平衡的二叉查找树：</p>
<ol>
<li>每个节点要么是红色，要么是黑色；</li>
<li>根节点永远是黑色；</li>
<li>所有的叶子节点都是是黑色的（下图中的 NULL 节点）；</li>
<li>红色节点的子节点一定是黑色的；</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-9.png"></p>
<h4 id="为什么不用二叉树？"><a href="#为什么不用二叉树？" class="headerlink" title="为什么不用二叉树？"></a>为什么不用二叉树？</h4><p>二叉树是最基本的树结构，每个节点最多有两个子节点，但是二叉树容易出现极端情况，比如插入的数据是有序的，那么二叉树就会退化成链表，查询效率就会变成 O(n)。</p>
<h4 id="为什么不用平衡二叉树？"><a href="#为什么不用平衡二叉树？" class="headerlink" title="为什么不用平衡二叉树？"></a>为什么不用平衡二叉树？</h4><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差 1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。<br>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p>
<h3 id="10-红黑树怎么保持平衡的？"><a href="#10-红黑树怎么保持平衡的？" class="headerlink" title="10.红黑树怎么保持平衡的？"></a>10.红黑树怎么保持平衡的？</h3><p>红黑树有两种方式保持平衡：<code>旋转</code>和<code>染色</code>。</p>
<h3 id="11-HashMap-的-put-流程知道吗？"><a href="#11-HashMap-的-put-流程知道吗？" class="headerlink" title="11.HashMap 的 put 流程知道吗？"></a>11.HashMap 的 put 流程知道吗？</h3><p>直接看流程图。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-13.jpeg"><br>第一步，通过 hash 方法计算 key 的哈希值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第二步，数组进行第一次扩容。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></tbody></table></figure>
<p>第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) {</span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = e;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意，在链表中插入节点的时候，如果链表长度大于等于 8，则需要把链表转换为红黑树。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></tbody></table></figure>
<p>所有元素处理完后，还需要判断是否超过阈值<code>threshold</code>，超过则扩容。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></tbody></table></figure>
<h4 id="只重写-equals-没重写-hashcode，map-put-的时候会发生什么"><a href="#只重写-equals-没重写-hashcode，map-put-的时候会发生什么" class="headerlink" title="只重写 equals 没重写 hashcode，map put 的时候会发生什么?"></a>只重写 equals 没重写 hashcode，map put 的时候会发生什么?</h4><p>如果只重写 equals 方法，没有重写 hashcode 方法，那么会导致 equals 相等的两个对象，hashcode 不相等，这样的话，这两个对象会被放到不同的桶中，这样就会导致 get 的时候，找不到对应的值。</p>
<h3 id="12-HashMap-怎么查找元素的呢？"><a href="#12-HashMap-怎么查找元素的呢？" class="headerlink" title="12.HashMap 怎么查找元素的呢？"></a>12.HashMap 怎么查找元素的呢？</h3><p>先看流程图：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-14.png"><br>HashMap 的查找就简单很多：</p>
<ol>
<li>使用扰动函数，获取新的哈希值</li>
<li>计算数组下标，获取节点</li>
<li>当前节点和 key 匹配，直接返回</li>
<li>否则，当前节点是否为树节点，查找红黑树</li>
<li>否则，遍历链表查找</li>
</ol>
<h3 id="13-HashMap-的-hash-函数是怎么设计的"><a href="#13-HashMap-的-hash-函数是怎么设计的" class="headerlink" title="13.HashMap 的 hash 函数是怎么设计的?"></a>13.HashMap 的 hash 函数是怎么设计的?</h3><p>HashMap 的哈希函数是先拿到 key 的 hashcode，是一个 32 位的 int 类型的数值，然后让 hashcode 的高 16 位和低 16 位进行异或操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key的hashCode和key的hashCode右移16位做异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这么设计是为了降低哈希碰撞的概率。</p>
<h3 id="14-为什么-hash-函数能降哈希碰撞？"><a href="#14-为什么-hash-函数能降哈希碰撞？" class="headerlink" title="14.为什么 hash 函数能降哈希碰撞？"></a>14.为什么 hash 函数能降哈希碰撞？</h3><p>在 hash 函数中，先调用了 key 的<code>hashCode()</code> 方法，这将会返回一个 int 类型的哈希值，比如说字符串的 hashCode。<br>int 的范围是 <strong>-2147483648~2147483647</strong>，加起来大概 40 亿上下的浮动。<br>只要 key 的 hashCode 方法设计的比较合理，一般是很难出现碰撞的。但问题是，不可能直接搞一个 40 亿长度的数组啊，那也太铺张浪费了。<br>我们一般会设置一个较小的数组长度，比如说 HashMap 的数组初始大小才 16，当发现容量不满足的时候再扩容，避免浪费。<br>那当数组长度比较小的时候，我们就需要设计一种比较巧妙的 hash 算法，来避免发生哈希冲突，尽可能地让元素均匀地分布在数组当中。<br>要达到这个目的，HashMap 在两方面下足了功夫，第一个就是数组的长度必须是 2 的整数次幂，这样可以保证 <code>hash &amp; (n-1)</code> 的结果能均匀地分布在数组中。<br>其作用就相当于 hash % n，n 为数组的长度，比如说数组长度是 16，hash 值为 20，那么 20 % 16 = 4，也就是说 20 这个元素应该放在数组的第 4 个位置；hash 值为 23，那么 23 % 16 = 7，也就是说 23 这个元素应该放在数组的第 7 个位置。<br><code>&amp;</code> 操作的结果就是哈希值的高位全部归零，只保留 n 个低位，用来做数组下标访问。<br>比如说 hash &amp; ($2^{4} - 1$) 的结果实际上是取 hash 的低 4 位，这四位能表示的取值范围刚好是 0000 到 1111，也就是 0 到 15，正好是数组长度为 16 的下标范围。<br>以初始长度 16 为例，16-1=15。2 进制表示是<code>0000 0000 0000 0000 0000 0000 0000 1111</code>。和某个哈希值做 <code>&amp;</code> 运算，结果就是截取了最低的四位。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-15.png"><br>那问题又来了，那么大一个哈希值，也只取最后 4 位，不就等于哈希值的高位都丢弃了吗？<br>比如说 1111 1111 1111 1111 1111 1111 1111 1111，取最后 4 位，也就是 1111。<br>比如说 1110 1111 1111 1111 1111 1111 1111 1111，取最后 4 位，也是 1111。<br>不就发生哈希冲突了吗？<br>这时候 hash 函数 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 就派上用场了呀。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-16.jpeg"><br>将哈希值无符号右移 16 位，意味着原哈希值的高 16 位被移到了低 16 位的位置。这样，原始哈希值的高 16 位和低 16 位就可以参与到最终用于索引计算的低位中。<br>选择 16 位是因为它是 32 位整数的一半，这样处理既考虑了高位的信息，又没有完全忽视低位原本的信息，尝试达到一个平衡状态。<br>举个例子（数组长度为 16）。</p>
<ul>
<li>第一个数：h1 = 0001 0010 0011 0100 0101 0110 0111 1000</li>
<li>第二个数：h2 = 0001 0010 0011 0101 0101 0110 0111 1000</li>
</ul>
<p>如果没有 hash 函数，直接取低 4 位，那么 h1 和 h2 的低 4 位都是 1000，也就是两个数都会放在数组的第 8 个位置。<br>来看一下 hash 函数的处理过程。<br>①、对于第一个数<code>h1</code>的计算：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始: 0001 0010 0011 0100 0101 0110 0111 1000</span><br><span class="line">右移: 0000 0000 0000 0000 0001 0010 0011 0100</span><br><span class="line">异或: ---------------------------------------</span><br><span class="line">结果: 0001 0010 0011 0100 0100 0100 0100 1100</span><br></pre></td></tr></tbody></table></figure>
<p>②、对于第二个数<code>h2</code>的计算：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始: 0001 0010 0011 0101 0101 0110 0111 1000</span><br><span class="line">右移: 0000 0000 0000 0000 0001 0010 0011 0101</span><br><span class="line">异或: ---------------------------------------</span><br><span class="line">结果: 0001 0010 0011 0101 0100 0100 0100 1101</span><br></pre></td></tr></tbody></table></figure>
<p>通过上述计算，我们可以看到<code>h1</code>和<code>h2</code>经过<code>h ^ (h &gt;&gt;&gt; 16)</code>操作后得到了不同的结果。<br>现在，考虑数组长度为 16 时（需要最低 4 位来确定索引）：</p>
<ul>
<li>对于<code>h1</code>的最低 4 位是<code>1100</code>（十进制中为 12）</li>
<li>对于<code>h2</code>的最低 4 位是<code>1101</code>（十进制中为 13）</li>
</ul>
<p>这样，<code>h1</code>和<code>h2</code>就会被分别放在数组的第 12 个位置和第 13 个位置上，避免了哈希冲突。</p>
<h3 id="15-为什么-HashMap-的容量是-2-的倍数呢？"><a href="#15-为什么-HashMap-的容量是-2-的倍数呢？" class="headerlink" title="15.为什么 HashMap 的容量是 2 的倍数呢？"></a>15.为什么 HashMap 的容量是 2 的倍数呢？</h3><p>HashMap 的容量是 2 的倍数，或者说是 2 的整数次幂，是为了快速定位元素的下标：<br>HashMap 在定位元素位置时，先通过 <code>hash(key) = (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 计算出哈希值，再通过 <code>hash &amp; (n-1)</code> 来定位元素位置的，n 为数组的大小，也就是 HashMap 的容量。<br>因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0。</p>
<blockquote>
<p>a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0。例如 5&amp;3=1，5 的二进制是 0101，3 的二进制是 0011，5&amp;3=0001=1。</p>
</blockquote>
<p>2 的整次幂（或者叫 2 的整数倍）刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 <code>hash &amp;(length-1)</code> 的最后一位可能为 0，也可能为 1（取决于 hash 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀分布。<br>换句话说，&amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值。<br>假设某哈希值的二进制为 <code>10100101 11000100 00100101</code>，用它来做 &amp; 运算，我们来看一下结果。<br>我们知道，HashMap 的初始长度为 16，16-1=15，二进制是 <code>00000000 00000000 00001111</code>（高位用 0 来补齐）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     10100101 11000100 00100101</span><br><span class="line">&amp;	 00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">     00000000 00000000 00000101</span><br></pre></td></tr></tbody></table></figure>
<p>因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定也是 0，只剩下 4 个低位 <code>0101</code>，也就是十进制的 5。<br>这样，哈希值为 <code>10100101 11000100 00100101</code> 的键就会放在数组的第 5 个位置上。</p>
<h4 id="hashCode-对数组长度取模定位数组下标，这块有没有优化策略？"><a href="#hashCode-对数组长度取模定位数组下标，这块有没有优化策略？" class="headerlink" title="hashCode 对数组长度取模定位数组下标，这块有没有优化策略？"></a>hashCode 对数组长度取模定位数组下标，这块有没有优化策略？</h4><p>从此，两个运算 <code>hash % length</code> 和 <code>hash &amp; (length - 1)</code> 有了完美的闭环。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。</p>
<h3 id="16-如果初始化-HashMap，传一个-17-容量，它会怎么处理？"><a href="#16-如果初始化-HashMap，传一个-17-容量，它会怎么处理？" class="headerlink" title="16.如果初始化 HashMap，传一个 17 容量，它会怎么处理？"></a>16.如果初始化 HashMap，传一个 17 容量，它会怎么处理？</h3><p>HashMap 会将这个值转换为大于或等于 17 的最小的 2 的幂。这是因为 HashMap 的设计是基于哈希表的，而哈希表的大小最好是 2 的幂，这样可以优化哈希值的计算，并减少哈希冲突。<br>所以，如果你传入 17 作为初始容量，HashMap 实际上会被初始化为大小为 32 的哈希表。<br>在 HashMap 的初始化构造方法中，有这样⼀段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> {</span><br><span class="line"> ...</span><br><span class="line"> <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"> <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>阀值 threshold 会通过⽅法<code> tableSizeFor()</code> 进⾏计算。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="初始化-HashMap-的时候需要传入容量值吗？"><a href="#初始化-HashMap-的时候需要传入容量值吗？" class="headerlink" title="初始化 HashMap 的时候需要传入容量值吗？"></a>初始化 HashMap 的时候需要传入容量值吗？</h4><p>在创建 HashMap 时可以指定初始容量值。这个容量是指 Map 内部用于存储数据的数组大小。<br>如果预先知道 Map 将存储大量键值对，提前指定一个足够大的初始容量可以减少因扩容导致的重哈希（rehashing）操作，从而提高性能。<br>因为每次扩容时，HashMap 需要新分配一个更大的数组并重新将现有的元素插入到这个新数组中，这个过程相对耗时，尤其是当 Map 中已有大量数据时。<br>当然了，过大的初始容量会浪费内存，特别是当实际存储的元素远少于初始容量时。如果不指定初始容量，HashMap 将使用默认的初始容量 16。</p>
<h3 id="17-你还知道哪些哈希函数的构造方法呢？"><a href="#17-你还知道哪些哈希函数的构造方法呢？" class="headerlink" title="17.你还知道哪些哈希函数的构造方法呢？"></a>17.你还知道哪些哈希函数的构造方法呢？</h3><p>HashMap 里哈希构造函数的方法叫：</p>
<ul>
<li><strong>除留取余法</strong>：<code>H(key)=key%p(p&lt;=N)</code>，关键字除以一个不大于哈希表长度的正整数 p，所得余数为地址，当然 HashMap 里进行了优化改造，效率更高，散列也更均衡。</li>
</ul>
<p>除此之外，还有这几种常见的哈希函数构造方法：</p>
<ul>
<li><strong>直接定址法</strong>直接根据<code>key</code>来映射到对应的数组位置，例如 1232 放到下标 1232 的位置。</li>
<li><strong>数字分析法</strong>取<code>key</code>的某些数字（例如十位和百位）作为映射的位置</li>
<li><strong>平方取中法</strong>取<code>key</code>平方的中间几位作为映射的位置</li>
<li><strong>折叠法</strong>将<code>key</code>分割成位数相同的几段，然后把它们的叠加和作为映射的位置</li>
</ul>
<h3 id="18-解决哈希冲突有哪些方法呢？"><a href="#18-解决哈希冲突有哪些方法呢？" class="headerlink" title="18.解决哈希冲突有哪些方法呢？"></a>18.解决哈希冲突有哪些方法呢？</h3><p>解决哈希冲突的方法我知道的有 3 种：<br>①、再哈希法<br>准备两套哈希算法，当发生哈希冲突的时候，使用另外一种哈希算法，直到找到空槽为止。对哈希算法的设计要求比较高。<br>②、开放地址法<br>遇到哈希冲突的时候，就去寻找下一个空的槽。有 3 种方法：</p>
<ul>
<li>线性探测：从冲突的位置开始，依次往后找，直到找到空槽。</li>
<li>二次探测：从冲突的位置 x 开始，第一次增加 $1^2$ 个位置，第二次增加 $2^2$，直到找到空槽。</li>
<li>双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数。</li>
</ul>
<p>③、拉链法<br>也就是所谓的链地址法，当发生哈希冲突的时候，使用链表将冲突的元素串起来。HashMap 采用的正是拉链法。</p>
<h4 id="怎么判断-key-相等呢？"><a href="#怎么判断-key-相等呢？" class="headerlink" title="怎么判断 key 相等呢？"></a>怎么判断 key 相等呢？</h4><p><code>HashMap</code>判断两个<code>key</code>是否相等，依赖于<code>key</code>的<code>equals()</code>方法和<code>hashCode()</code>方法，以及 <code>==</code> 运算符。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></tbody></table></figure>
<p>①、<strong>hashCode()</strong> ：首先，使用<code>key</code>的<code>hashCode()</code>方法计算<code>key</code>的哈希码。由于不同的<code>key</code>可能有相同的哈希码，<code>hashCode()</code>只是第一步筛选。<br>②、<strong>equals()</strong> ：当两个<code>key</code>的哈希码相同时，<code>HashMap</code>还会调用<code>key</code>的<code>equals()</code>方法进行精确比较。只有当<code>equals()</code>方法返回<code>true</code>时，两个<code>key</code>才被认为是完全相同的。<br>③、：当然了，如果两个<code>key</code>的引用指向同一个对象，那么它们的<code>hashCode()</code>和<code>equals()</code>方法都会返回<code>true</code>，所以在 equals 判断之前会优先使用``运算符判断一次。</p>
<h3 id="19-为什么-HashMap-链表转红黑树的阈值为-8-呢？"><a href="#19-为什么-HashMap-链表转红黑树的阈值为-8-呢？" class="headerlink" title="19.为什么 HashMap 链表转红黑树的阈值为 8 呢？"></a>19.为什么 HashMap 链表转红黑树的阈值为 8 呢？</h3><p>树化发生在 table 数组的长度大于 64，且链表的长度大于 8 的时候。<br>为什么是 8 呢？源码的注释也给出了答案。<br>红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。<br>阈值为什么要选 8 呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为 8 的情况，发生概率仅为<code>0.00000006</code>。<br>至于红黑树转回链表的阈值为什么是 6，而不是 8？是因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。</p>
<h3 id="20-扩容在什么时候呢？为什么扩容因子是-0-75？"><a href="#20-扩容在什么时候呢？为什么扩容因子是-0-75？" class="headerlink" title="20.扩容在什么时候呢？为什么扩容因子是 0.75？"></a>20.扩容在什么时候呢？为什么扩容因子是 0.75？</h3><p>HashMap 会在存储的键值对数量超过阈值（即容量 * 加载因子）时进行扩容。<br>默认的加载因子是 0.75，这意味着当 HashMap 填满了大约 75%的容量时，就会进行扩容。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></tbody></table></figure>
<p>默认的初始容量是 16，那就是大于<code>16x0.75=12</code>时，就会触发第一次扩容操作。</p>
<h4 id="那么为什么选择了-0-75-作为-HashMap-的默认加载因子呢？"><a href="#那么为什么选择了-0-75-作为-HashMap-的默认加载因子呢？" class="headerlink" title="那么为什么选择了 0.75 作为 HashMap 的默认加载因子呢？"></a>那么为什么选择了 0.75 作为 HashMap 的默认加载因子呢？</h4><p>简单来说，这是对<code>空间</code>成本和<code>时间</code>成本平衡的考虑。<br>在 HashMap 中有这样一段注释：<br>我们都知道，HashMap 的散列构造方式是 Hash 取余，负载因子决定元素个数达到多少时候扩容。<br>假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了。<br>我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了。</p>
<h3 id="21-那扩容机制了解吗？"><a href="#21-那扩容机制了解吗？" class="headerlink" title="21.那扩容机制了解吗？"></a>21.那扩容机制了解吗？</h3><p>扩容时，HashMap 会创建一个新的数组，其容量是原数组容量的两倍。然后将键值对放到新计算出的索引位置上。一部分索引不变，另一部分索引为“原索引+旧容量”。</p>
<blockquote>
<p>为了便于理解，我会结合 JDK7 和 JDK8 两个版本来讲。</p>
</blockquote>
<p>在 JDK 7 中，定位元素位置的代码是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> {</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其实就相当于用键的哈希值和数组大小取模，也就是 <code>hashCode % table.length</code>。<br>那我们来假设：</p>
<ul>
<li>数组 table 的长度为 2</li>
<li>键的哈希值为 3、7、5</li>
</ul>
<p>取模运算后，键发生了哈希冲突，都到 <code>table[1]</code> 上了。那么扩容前就是这个样子。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-resize-01.png"><br>数组的容量为 2，key 为 3、7、5 的元素在 <code>table[1]</code> 上，需要通过拉链法来解决哈希冲突。<br>假设负载因子 loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。<br>扩容后的数组容量为 4。</p>
<ul>
<li>key 3 取模（3%4）后是 3，放在 <code>table[3]</code> 上。</li>
<li>key 7 取模（7%4）后是 3，放在 <code>table[3]</code> 上的链表头部。</li>
<li>key 5 取模（5%4）后是 1，放在 <code>table[1]</code> 上。</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-resize-02.png"><br>7 跑到 3 的前面了，因为 JDK 7 使用的是头插法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i];</span><br></pre></td></tr></tbody></table></figure>
<p>同时，扩容后的 5 跑到了下标为 1 的位置。<br>最好的情况就是，扩容后的 7 在 3 的后面，5 在 7 的后面，保持原来的顺序。<br>JDK 8 完全扭转了这个局面，因为 JDK 8 的哈希算法进行了优化，当数组长度为 2 的幂次方时，能够很巧妙地解决 JDK 7 中遇到的问题。<br>JDK 8 的扩容代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = <span class="keyword">new</span> <span class="title class_">Node</span>[newCapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldTab.length; j++) {</span><br><span class="line">    Node&lt;K,V&gt; e = oldTab[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> e.hash;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newIndex</span> <span class="operator">=</span> hash &amp; (newCapacity - <span class="number">1</span>); <span class="comment">// 计算在新数组中的位置</span></span><br><span class="line">        <span class="comment">// 将节点移动到新数组的对应位置</span></span><br><span class="line">        newTab[newIndex] = e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>新索引的计算方式是 <code>hash &amp; (newCapacity - 1)</code>，和 JDK 7 的 <code>h &amp; (length-1)</code>没什么大的差别，差别主要在 hash 方法上，JDK 8 是这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>过将键的<code>hashCode()</code>返回的 32 位哈希值与这个哈希值无符号右移 16 位的结果进行异或。<br>JDK 7 是这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) {</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们用 JDK 8 的哈希算法来计算一下哈希值，就会发现别有洞天。<br>假设扩容前的数组长度为 16（n-1 也就是二进制的 0000 1111，1X${2^0}$+1X${2^1}$+1X${2^2}$+1X${2^3}$=1+2+4+8=15），key1 为 5（二进制为 0000 0101），key2 为 21（二进制为 0001 0101）。</p>
<ul>
<li>key1 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5；</li>
<li>key2 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5。</li>
<li>此时哈希冲突了，用拉链法来解决哈希冲突。</li>
</ul>
<p>现在，HashMap 进行了扩容，容量为原来的 2 倍，也就是 32（n-1 也就是二进制的 0001 1111，1X${2^0}$+1X${2^1}$+1X${2^2}$+1X${2^3}$+1X${2^4}$=1+2+4+8+16=31）。</p>
<ul>
<li>key1 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5；</li>
<li>key2 和 n-1 做 &amp; 运算后为 0001 0101，也就是 21=5+16，也就是数组扩容前的位置+原数组的长度。</li>
</ul>
<p>神奇吧？<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-26.png"><br>换句话说，在 JDK 8 的新 hash 算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定的规律。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-27.png"><br>当然了，这个功劳既属于新的哈希算法，也离不开 n 为 2 的整数次幂这个前提，这是它俩通力合作后的结果 <code>hash &amp; (newCapacity - 1)</code>。</p>
<h4 id="那你说说扩容的时候每个节点都要进行位运算吗，如果我这个-HashMap-里面有几十万条数据，都要进行位运算吗？"><a href="#那你说说扩容的时候每个节点都要进行位运算吗，如果我这个-HashMap-里面有几十万条数据，都要进行位运算吗？" class="headerlink" title="那你说说扩容的时候每个节点都要进行位运算吗，如果我这个 HashMap 里面有几十万条数据，都要进行位运算吗？"></a>那你说说扩容的时候每个节点都要进行位运算吗，如果我这个 HashMap 里面有几十万条数据，都要进行位运算吗？</h4><p>在 JDK 8 的新 hash 算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定的规律。<br>具体来说，就是判断原哈希值的高位中新增的那一位是否为 1，如果是，该元素会被移动到原位置加上旧容量的位置；如果不是，则保持在原位置。<br>所以，尽管有几十万条数据，每个数据项的位置决定仅需要一次简单的位运算。位运算的计算速度非常快，因此，尽管扩容操作涉及遍历整个哈希表并对每个节点进行操作，但这部分操作的计算成本是相对较低的。</p>
<h3 id="22-JDK-8-对-HashMap-主要做了哪些优化呢？为什么？"><a href="#22-JDK-8-对-HashMap-主要做了哪些优化呢？为什么？" class="headerlink" title="22.JDK 8 对 HashMap 主要做了哪些优化呢？为什么？"></a>22.JDK 8 对 HashMap 主要做了哪些优化呢？为什么？</h3><p>相比较 JDK 7，JDK 8 的 HashMap 主要做了四点优化：<br>①、底层数据结构由数组 + 链表改成了数组 + 链表或红黑树的结构。<br>原因：如果多个键映射到了同一个哈希值，链表会变得很长，在最坏的情况下，当所有的键都映射到同一个桶中时，性能会退化到 O(n)，而红黑树的时间复杂度是 O(logn)。<br>②、链表的插入方式由头插法改为了尾插法。<br>原因：头插法虽然简单快捷，但扩容后容易改变原来链表的顺序。<br>③、扩容的时机由插入时判断改为插入后判断。<br>原因：可以避免在每次插入时都进行不必要的扩容检查，因为有可能插入后仍然不需要扩容。<br>④、优化了哈希算法。<br>JDK 7 进行了多次移位和异或操作来计算元素的哈希值。<br>JDK 8 优化了这个算法，只进行了一次异或操作，但仍然能有效地减少冲突。<br>并且能够保证扩容后，元素的新位置要么是原位置，要么是原位置加上旧容量大小。</p>
<h3 id="23-你能自己设计实现一个-HashMap-吗？"><a href="#23-你能自己设计实现一个-HashMap-吗？" class="headerlink" title="23.你能自己设计实现一个 HashMap 吗？"></a>23.你能自己设计实现一个 HashMap 吗？</h3><p>这道题<strong>快手</strong>常考。<br>不要慌，红黑树版咱们多半是写不出来，但是数组+链表版还是问题不大的，详细可见： <a href="https://mp.weixin.qq.com/s/Z9yoRZW5itrtgbS-cj0bUg">手写 HashMap，快手面试官直呼内行！</a>。<br>整体的设计：</p>
<ul>
<li>散列函数：hashCode()+除留余数法</li>
<li>冲突解决：链地址法</li>
<li>扩容：节点重新 hash 获取位置</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-29.png"><br>完整代码：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-30.png"></p>
<h3 id="24-HashMap-是线程安全的吗？多线程下会有什么问题？"><a href="#24-HashMap-是线程安全的吗？多线程下会有什么问题？" class="headerlink" title="24.HashMap 是线程安全的吗？多线程下会有什么问题？"></a>24.HashMap 是线程安全的吗？多线程下会有什么问题？</h3><p>推荐阅读：<a href="https://javabetter.cn/collection/hashmap.html#_04%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">HashMap 详解</a><br>HashMap 不是线程安全的，主要有以下几个问题：<br>①、多线程下扩容会死循环。JDK1.7 中的 HashMap 使用的是头插法插入元素，在多线程的环境下，扩容的时候就有可能导致出现环形链表，造成死循环。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-thread-nosafe-07.png"><br>不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序。<br>②、多线程的 put 可能会导致元素的丢失。因为计算出来的位置可能会被其他线程的 put 覆盖。本来哈希冲突是应该用链表的，但多线程时由于没有加锁，相同位置的元素可能就被干掉了。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hashmap-thread-nosafe-10.png"><br>③、put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而导致出现扩容，线程 2 此时执行 get，就有可能出现这个问题。<br>因为线程 1 执行完 table = newTab 之后，线程 2 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。</p>
<h3 id="25-有什么办法能解决-HashMap-线程不安全的问题呢？"><a href="#25-有什么办法能解决-HashMap-线程不安全的问题呢？" class="headerlink" title="25.有什么办法能解决 HashMap 线程不安全的问题呢？"></a>25.有什么办法能解决 HashMap 线程不安全的问题呢？</h3><p>在 Java 中，有 3 种线程安全的 Map 实现，最常用的是<a href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a>和<code>Collections.synchronizedMap(Map)</code>包装器。<br>Hashtable 也是线程安全的，但它的使用已经不再推荐使用，因为 ConcurrentHashMap 提供了更高的并发性和性能。<br>①、HashTable 是直接在方法上加 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>，比较粗暴。<br>②、<code>Collections.synchronizedMap</code> 返回的是 <a href="https://javabetter.cn/common-tool/collections.html">Collections</a> 工具类的内部类。<br>内部是通过 synchronized 对象锁来保证线程安全的。<br>③、<a href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a> 在 JDK 7 中使用分段锁，在 JKD 8 中使用了 <a href="https://javabetter.cn/thread/cas.html">CAS（Compare-And-Swap）</a>+ <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>，性能得到进一步提升。</p>
<h3 id="26-HashMap-内部节点是有序的吗？"><a href="#26-HashMap-内部节点是有序的吗？" class="headerlink" title="26.HashMap 内部节点是有序的吗？"></a>26.HashMap 内部节点是有序的吗？</h3><p>HashMap 是无序的，根据 hash 值随机插入。如果想使用有序的 Map，可以使用 LinkedHashMap 或者 TreeMap。</p>
<h3 id="27-讲讲-LinkedHashMap-怎么实现有序的？"><a href="#27-讲讲-LinkedHashMap-怎么实现有序的？" class="headerlink" title="27.讲讲 LinkedHashMap 怎么实现有序的？"></a>27.讲讲 LinkedHashMap 怎么实现有序的？</h3><p>LinkedHashMap 维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-33.png"><br>可以实现按插入的顺序或访问顺序排序。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-34.png"></p>
<h3 id="28-讲讲-TreeMap-怎么实现有序的？"><a href="#28-讲讲-TreeMap-怎么实现有序的？" class="headerlink" title="28.讲讲 TreeMap 怎么实现有序的？"></a>28.讲讲 TreeMap 怎么实现有序的？</h3><p>TreeMap 通过 key 的比较器来决定元素的顺序，如果没有指定比较器，那么 key 必须实现 <a href="https://javabetter.cn/collection/comparable-omparator.html">Comparable 接口</a>。<br>TreeMap 的底层是红黑树，红黑树是一种自平衡的二叉查找树，每个节点都大于其左子树中的任何节点，小于其右子节点树种的任何节点。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-35.png"><br>插入或者删除元素时通过旋转和着色来保持树的平衡。<br>查找的时候通过从根节点开始，利用二叉查找树的性质，逐步向左或者右子树递归查找，直到找到目标元素。</p>
<h3 id="29-TreeMap-和-HashMap-的区别"><a href="#29-TreeMap-和-HashMap-的区别" class="headerlink" title="29.TreeMap 和 HashMap 的区别"></a>29.TreeMap 和 HashMap 的区别</h3><p>①、HashMap 是基于数组+链表+红黑树实现的，put 元素的时候会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，然后将元素插入到数组中，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。<br>get 元素的时候同样会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，如果遇到链表或者红黑树，会通过 key 的 equals 方法来判断是否是要找的元素。<br>②、TreeMap 是基于红黑树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。<br>get 元素的时候会通过 key 的比较器来判断元素的位置，然后递归查找。<br>由于 HashMap 是基于哈希表实现的，所以在没有发生哈希冲突的情况下，HashMap 的查找效率是 O(1)。适用于查找操作比较频繁的场景。<br>而 TreeMap 是基于红黑树实现的，所以 TreeMap 的查找效率是 O(logn)。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="30-讲讲-HashSet-的底层实现？"><a href="#30-讲讲-HashSet-的底层实现？" class="headerlink" title="30.讲讲 HashSet 的底层实现？"></a>30.讲讲 HashSet 的底层实现？</h3><p>HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 ArrayList 和 LinkedList 可能更适合；如果我们需要存储键值对并根据键进行查找，那么 HashMap 可能更适合。<br>HashSet 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 HashSet 来实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 HashSet 对象</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">"沉默"</span>);</span><br><span class="line">set.add(<span class="string">"王二"</span>);</span><br><span class="line">set.add(<span class="string">"陈清扬"</span>);</span><br><span class="line">set.add(<span class="string">"沉默"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 HashSet 的元素个数</span></span><br><span class="line">System.out.println(<span class="string">"HashSet size: "</span> + set.size()); <span class="comment">// output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 HashSet</span></span><br><span class="line"><span class="keyword">for</span> (String s : set) {</span><br><span class="line">    System.out.println(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>HashSet 会自动去重，因为它是用 HashMap 实现的，HashMap 的键是唯一的（哈希值），相同键的值会覆盖掉原来的值，于是第二次 set.add(“沉默”) 的时候就覆盖了第一次的 set.add(“沉默”)。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-36.png"></p>
<h4 id="HashSet-和-ArrayList-的区别"><a href="#HashSet-和-ArrayList-的区别" class="headerlink" title="HashSet 和 ArrayList 的区别"></a>HashSet 和 ArrayList 的区别</h4><ul>
<li>ArrayList 是基于动态数组实现的，HashSet 是基于 HashMap 实现的。</li>
<li>ArrayList 允许重复元素和 null 值，可以有多个相同的元素；HashSet 保证每个元素唯一，不允许重复元素，基于元素的 hashCode 和 equals 方法来确定元素的唯一性。</li>
<li>ArrayList 保持元素的插入顺序，可以通过索引访问元素；HashSet 不保证元素的顺序，元素的存储顺序依赖于哈希算法，并且可能随着元素的添加或删除而改变。</li>
</ul>
<h4 id="HashSet-怎么判断元素重复，重复了是否-put"><a href="#HashSet-怎么判断元素重复，重复了是否-put" class="headerlink" title="HashSet 怎么判断元素重复，重复了是否 put"></a>HashSet 怎么判断元素重复，重复了是否 put</h4><p>HashSet 的 add 方法是通过调用 HashMap 的 put 方法实现的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以 HashSet 判断元素重复的逻辑底层依然是 HashMap 的底层逻辑：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection-13.jpeg"><br>HashMap 在插入元素时，通常需要三步：<br>第一步，通过 hash 方法计算 key 的哈希值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第二步，数组进行第一次扩容。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></tbody></table></figure>
<p>第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">            <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) {</span><br><span class="line">                p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = e;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，HashSet 通过元素的哈希值来判断元素是否重复，如果重复了，会覆盖原来的值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://ylcheng1789.github.io">程月龙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://ylcheng1789.github.io/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">http://ylcheng1789.github.io/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ylcheng1789.github.io" target="_blank">Loong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9B%86%E5%90%88/">Java集合</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg" data-sites="weibo,wechat,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏一下~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_trade.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_trade.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay_trade.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay_trade.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/" title="我的博客优化历程—自动初始化Gitalk"><img class="cover" src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408301832793.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我的博客优化历程—自动初始化Gitalk</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cyl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">程月龙</div><div class="author-info__description">技术博客、独立开发者、Java开发、Python开发、人工智能</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://github.com/ylcheng1789"><i class="fas fa-video"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ylcheng1789" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/ylcheng1789@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/19834521789" target="_blank" title="Phone"><i class="fas fa-square-phone-flip" style="color: #00c4b6;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Loong开发，致力于为猿友们提供有价值的内容</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-text">1.说说有哪些常见的集合框架？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%98%9F%E5%88%97-Queue"><span class="toc-text">简单介绍一下队列 Queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BC%98%E5%8A%A3%EF%BC%9F"><span class="toc-text">用过哪些集合类，它们的优劣？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">队列和栈的区别了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">哪些是线程安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%9FCollection-%E7%BB%A7%E6%89%BF%E4%BA%86%E5%93%AA%E4%BA%9B%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-text">Java 集合用过哪些？Collection 继承了哪些接口？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.ArrayList 和 LinkedList 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">数据结构有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">用途有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9F"><span class="toc-text">是否支持随机访问？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">内存占用有何不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">使用场景有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">3.ArrayList 的扩容机制了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ArrayList-%E6%80%8E%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-transient-%E4%BF%AE%E9%A5%B0%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-text">4.ArrayList 怎么序列化的知道吗？ 为什么用 transient 修饰数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5-fail-fast-%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5-fail-safe-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0-ArrayList-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">6.有哪几种实现 ArrayList 线程安全的方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">ArrayList 和 Vector 的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-CopyOnWriteArrayList-%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">7.CopyOnWriteArrayList 了解多少？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%97%EF%BC%9F"><span class="toc-text">8.能说一下 HashMap 的底层数据结构吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%91%A2%EF%BC%9F"><span class="toc-text">9.你对红黑树了解多少？为什么不用二叉树/平衡树呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="toc-text">为什么不用二叉树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="toc-text">为什么不用平衡二叉树？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E5%B9%B3%E8%A1%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">10.红黑树怎么保持平衡的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-HashMap-%E7%9A%84-put-%E6%B5%81%E7%A8%8B%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-text">11.HashMap 的 put 流程知道吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E9%87%8D%E5%86%99-equals-%E6%B2%A1%E9%87%8D%E5%86%99-hashcode%EF%BC%8Cmap-put-%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">只重写 equals 没重写 hashcode，map put 的时候会发生什么?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-HashMap-%E6%80%8E%E4%B9%88%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">12.HashMap 怎么查找元素的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HashMap-%E7%9A%84-hash-%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="toc-text">13.HashMap 的 hash 函数是怎么设计的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%B8%BA%E4%BB%80%E4%B9%88-hash-%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8D%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%EF%BC%9F"><span class="toc-text">14.为什么 hash 函数能降哈希碰撞？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E7%9A%84%E5%AE%B9%E9%87%8F%E6%98%AF-2-%E7%9A%84%E5%80%8D%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-text">15.为什么 HashMap 的容量是 2 的倍数呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode-%E5%AF%B9%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E5%8F%96%E6%A8%A1%E5%AE%9A%E4%BD%8D%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%EF%BC%8C%E8%BF%99%E5%9D%97%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">hashCode 对数组长度取模定位数组下标，这块有没有优化策略？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%A6%82%E6%9E%9C%E5%88%9D%E5%A7%8B%E5%8C%96-HashMap%EF%BC%8C%E4%BC%A0%E4%B8%80%E4%B8%AA-17-%E5%AE%B9%E9%87%8F%EF%BC%8C%E5%AE%83%E4%BC%9A%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">16.如果初始化 HashMap，传一个 17 容量，它会怎么处理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-HashMap-%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BC%A0%E5%85%A5%E5%AE%B9%E9%87%8F%E5%80%BC%E5%90%97%EF%BC%9F"><span class="toc-text">初始化 HashMap 的时候需要传入容量值吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BD%A0%E8%BF%98%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-text">17.你还知道哪些哈希函数的构造方法呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-text">18.解决哈希冲突有哪些方法呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD-key-%E7%9B%B8%E7%AD%89%E5%91%A2%EF%BC%9F"><span class="toc-text">怎么判断 key 相等呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%98%88%E5%80%BC%E4%B8%BA-8-%E5%91%A2%EF%BC%9F"><span class="toc-text">19.为什么 HashMap 链表转红黑树的阈值为 8 呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%89%A9%E5%AE%B9%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF-0-75%EF%BC%9F"><span class="toc-text">20.扩容在什么时候呢？为什么扩容因子是 0.75？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%86-0-75-%E4%BD%9C%E4%B8%BA-HashMap-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E5%91%A2%EF%BC%9F"><span class="toc-text">那么为什么选择了 0.75 作为 HashMap 的默认加载因子呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%82%A3%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">21.那扩容机制了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%BD%A0%E8%AF%B4%E8%AF%B4%E6%89%A9%E5%AE%B9%E7%9A%84%E6%97%B6%E5%80%99%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E9%83%BD%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E8%BF%99%E4%B8%AA-HashMap-%E9%87%8C%E9%9D%A2%E6%9C%89%E5%87%A0%E5%8D%81%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%83%BD%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%97%EF%BC%9F"><span class="toc-text">那你说说扩容的时候每个节点都要进行位运算吗，如果我这个 HashMap 里面有几十万条数据，都要进行位运算吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-JDK-8-%E5%AF%B9-HashMap-%E4%B8%BB%E8%A6%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">22.JDK 8 对 HashMap 主要做了哪些优化呢？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BD%A0%E8%83%BD%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-HashMap-%E5%90%97%EF%BC%9F"><span class="toc-text">23.你能自己设计实现一个 HashMap 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">24.HashMap 是线程安全的吗？多线程下会有什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E8%83%BD%E8%A7%A3%E5%86%B3-HashMap-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-text">25.有什么办法能解决 HashMap 线程不安全的问题呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-HashMap-%E5%86%85%E9%83%A8%E8%8A%82%E7%82%B9%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">26.HashMap 内部节点是有序的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%AE%B2%E8%AE%B2-LinkedHashMap-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="toc-text">27.讲讲 LinkedHashMap 怎么实现有序的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%AE%B2%E8%AE%B2-TreeMap-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="toc-text">28.讲讲 TreeMap 怎么实现有序的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-TreeMap-%E5%92%8C-HashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">29.TreeMap 和 HashMap 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E8%AE%B2%E8%AE%B2-HashSet-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">30.讲讲 HashSet 的底层实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">HashSet 和 ArrayList 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%EF%BC%8C%E9%87%8D%E5%A4%8D%E4%BA%86%E6%98%AF%E5%90%A6-put"><span class="toc-text">HashSet 怎么判断元素重复，重复了是否 put</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="八股文系列-Java集合框架"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文系列-Java集合框架"></a><div class="content"><a class="title" href="/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="八股文系列-Java集合框架">八股文系列-Java集合框架</a><time datetime="2024-09-01T05:22:24.000Z" title="发表于 2024-09-01 13:22:24">2024-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/" title="我的博客优化历程—自动初始化Gitalk"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408301832793.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的博客优化历程—自动初始化Gitalk"></a><div class="content"><a class="title" href="/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/" title="我的博客优化历程—自动初始化Gitalk">我的博客优化历程—自动初始化Gitalk</a><time datetime="2024-08-11T13:01:24.000Z" title="发表于 2024-08-11 21:01:24">2024-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/" title="一起写个数据库—10.服务端客户端的实现及其通信规则"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—10.服务端客户端的实现及其通信规则"></a><div class="content"><a class="title" href="/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/" title="一起写个数据库—10.服务端客户端的实现及其通信规则">一起写个数据库—10.服务端客户端的实现及其通信规则</a><time datetime="2024-06-11T13:01:24.000Z" title="发表于 2024-06-11 21:01:24">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/" title="一起写个数据库—9.字段与表管理"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—9.字段与表管理"></a><div class="content"><a class="title" href="/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/" title="一起写个数据库—9.字段与表管理">一起写个数据库—9.字段与表管理</a><time datetime="2024-06-10T13:01:24.000Z" title="发表于 2024-06-10 21:01:24">2024-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/09/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%948.%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E5%99%A8/" title="一起写个数据库—8.索引管理器"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—8.索引管理器"></a><div class="content"><a class="title" href="/2024/06/09/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%948.%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86%E5%99%A8/" title="一起写个数据库—8.索引管理器">一起写个数据库—8.索引管理器</a><time datetime="2024-06-09T13:01:24.000Z" title="发表于 2024-06-09 21:01:24">2024-06-09</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2017 - 2024 By 程月龙</div><div class="footer_custom_text">Copyright© Loong开发-独立开发者的日常总结<br></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liYCRlnpOTAGppwh',
      clientSecret: '5905e4c39a53de631adc5959cec17edba0d64cfe',
      repo: 'ylcheng1789.github.io',
      owner: 'ylcheng1789',
      admin: ['ylcheng1789'],
      id: 'f533cf369e7f28b0ce0e23695cbf9660',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>