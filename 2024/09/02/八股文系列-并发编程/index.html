<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>八股文系列-并发编程 | Loong</title><meta name="author" content="程月龙"><meta name="copyright" content="程月龙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="八股文系列-并发编程">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文系列-并发编程">
<meta property="og:url" content="http://ylcheng1789.github.io/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Loong">
<meta property="og:description" content="八股文系列-并发编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg">
<meta property="article:published_time" content="2024-09-02T15:11:35.000Z">
<meta property="article:modified_time" content="2024-09-02T16:04:26.811Z">
<meta property="article:author" content="程月龙">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://ylcheng1789.github.io/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ae9ce48d24501920dfa510977fa6cdad";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '八股文系列-并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 00:04:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Loong" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cyl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408290048644.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Loong"><img class="site-icon" src="/img/logo.png"><span class="site-name">Loong</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">八股文系列-并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-02T15:11:35.000Z" title="发表于 2024-09-02 23:11:35">2024-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-02T16:04:26.811Z" title="更新于 2024-09-03 00:04:26">2024-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">34.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>117分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="八股文系列-并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408290048644.png');"></div><article class="post-content" id="article-container"><p><a name="MIJch"></a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><a name="WPmsd"></a></p>
<h3 id="1-并行跟并发有什么区别？"><a href="#1-并行跟并发有什么区别？" class="headerlink" title="1.并行跟并发有什么区别？"></a>1.并行跟并发有什么区别？</h3><ul>
<li>并行是指多个处理器同时执行多个任务，每个核心实际上可以在同一时间独立地执行不同的任务。</li>
<li>并发是指系统有处理多个任务的能力，但是任意时刻只有一个任务在执行。在单核处理器上，多个任务是通过时间片轮转的方式实现的。但这种切换非常快，给人感觉是在同时执行。<br><a name="r4gnW"></a></li>
</ul>
<h4 id="你对线程安全的理解是什么？"><a href="#你对线程安全的理解是什么？" class="headerlink" title="你对线程安全的理解是什么？"></a>你对线程安全的理解是什么？</h4><p>线程安全是并发编程中一个重要的概念，如果一段代码块或者一个方法在多线程环境中被多个线程同时执行时能够正确地处理共享数据，那么这段代码块或者方法就是线程安全的。<br>可以从三个要素来确保线程安全：<br><strong>①、原子性</strong>：确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。<br>原子性可以通过互斥锁（如 synchronized）或原子操作（如 AtomicInteger 类中的方法）来保证。<br><strong>②、可见性</strong>：确保一个线程对共享变量的修改可以立即被其他线程看到。<br>volatile 关键字可以保证了变量的修改对所有线程立即可见，并防止编译器优化导致的可见性问题。<br><strong>③、活跃性问题</strong>：要确保线程不会因为死锁、饥饿、活锁等问题导致无法继续执行。<br><a name="VNztG"></a></p>
<h3 id="2-说说什么是进程和线程？"><a href="#2-说说什么是进程和线程？" class="headerlink" title="2.说说什么是进程和线程？"></a>2.说说什么是进程和线程？</h3><p>进程说简单点就是我们在电脑上启动的一个个应用，比如我们启动一个浏览器，就会启动了一个浏览器进程。进程是操作系统资源分配的最小单位，它包括了程序、数据和进程控制块等。<br>线程说简单点就是我们在 Java 程序中启动的一个 main 线程，一个进程至少会有一个线程。当然了，我们也可以启动多个线程，比如说一个线程进行 IO 读写，一个线程进行加减乘除计算，这样就可以充分发挥多核 CPU 的优势，因为 IO 读写相对 CPU 计算来说慢得多。线程是 CPU 分配资源的基本单位。<br>一个进程中可以有多个线程，多个线程共用进程的堆和方法区（Java 虚拟机规范中的一个定义，JDK 8 以后的实现为元空间）资源，但是每个线程都会有自己的程序计数器和栈。<br><a name="qkrVq"></a></p>
<h4 id="如何理解协程？"><a href="#如何理解协程？" class="headerlink" title="如何理解协程？"></a>如何理解协程？</h4><p>协程通常被视为比线程更轻量级的并发单元，它们主要在一些支持异步编程模型的语言中得到了原生支持，如 Kotlin、Go 等。<br>不过，我们可以使用 CompletableFuture 来模拟协程式的异步执行任务。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompletableFutureExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">        <span class="comment">// 异步执行任务1</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步执行任务2</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个任务的结果并计算</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; resultFuture = future1.thenCombine(future2, Integer::sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待最终结果并打印</span></span><br><span class="line">        System.out.println(<span class="string">"结果: "</span> + resultFuture.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个示例中，我们创建了两个 CompletableFuture 对象来异步执行两个简单的数值返回任务。这两个任务都会休眠 1 秒钟来模拟耗时计算。<br>然后我们使用 thenCombine 方法来合并这两个任务的结果。最后，我们通过 get 方法等待最终结果的完成，并打印出来。<br><a name="mKued"></a></p>
<h4 id="说说线程的共享内存？"><a href="#说说线程的共享内存？" class="headerlink" title="说说线程的共享内存？"></a>说说线程的共享内存？</h4><p>线程之间想要进行通信，可以通过消息传递和共享内存两种方法来完成。那 Java 采用的是共享内存的并发模型。<br>这个模型被称为 Java 内存模型，也就是 JMM，JMM 决定了一个线程对共享变量的写入何时对另外一个线程可见。<br>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了共享变量的副本。当然了，本地内存是 JMM 的一个抽象概念，并不真实存在。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240315111143.png"><br>线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p>
<ul>
<li>线程 A 把本地内存 A 中的共享变量副本刷新到主内存中。</li>
<li>线程 B 到主内存中读取线程 A 刷新过的共享变量，再同步到自己的共享变量副本中。</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240315111130.png"><br><a name="H5LUe"></a></p>
<h3 id="3-说说线程有几种创建方式？"><a href="#3-说说线程有几种创建方式？" class="headerlink" title="3.说说线程有几种创建方式？"></a>3.说说线程有几种创建方式？</h3><p>Java 中创建线程主要有三种方式，分别为继承 Thread 类、实现 Runnable 接口、实现 Callable 接口。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407172652.png"><br>第一种，继承 Thread 类，重写 <code>run()</code>方法，调用 <code>start()</code>方法启动线程。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"看完二哥的 Java 进阶之路，上岸了!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ThreadTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTask</span>();</span><br><span class="line">        task.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种方法的缺点是，由于 Java 不支持多重继承，所以如果类已经继承了另一个类，就不能使用这种方法了。<br>第二种，实现 Runnable 接口，重写 <code>run()</code> 方法，然后创建 Thread 对象，将 Runnable 对象作为参数传递给 Thread 对象，调用 <code>start()</code> 方法启动线程。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"看完二哥的 Java 进阶之路，上岸了!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">RunnableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTask</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种方法的优点是可以避免 Java 的单继承限制，并且更符合面向对象的编程思想，因为 Runnable 接口将任务代码和线程控制的代码解耦了。<br>第三种，实现 Callable 接口，重写 <code>call()</code> 方法，然后创建 FutureTask 对象，参数为 Callable 对象；紧接着创建 Thread 对象，参数为 FutureTask 对象，调用 <code>start()</code> 方法启动线程。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"看完二哥的 Java 进阶之路，上岸了!"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">        <span class="type">CallableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTask</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种方法的优点是可以获取线程的执行结果。<br><a name="V2Y0u"></a></p>
<h4 id="一个-8G-内存的系统最多能创建多少线程"><a href="#一个-8G-内存的系统最多能创建多少线程" class="headerlink" title="一个 8G 内存的系统最多能创建多少线程?"></a>一个 8G 内存的系统最多能创建多少线程?</h4><p>推荐阅读：<a href="https://javabetter.cn/jvm/neicun-jiegou.html">深入理解 JVM 的运行时数据区</a><br>在确定一个系统最多可以创建多个线程时，除了需要考虑系统的内存大小外，Java 虚拟机栈的大小也是值得考虑的因素。<br>线程在创建的时候会被分配一个虚拟机栈，在 64 位操作系统中，默认大小为 1M。<br>通过 <code>java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</code> 这个命令可以查看 JVM 栈的默认大小。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/neicun-jiegou-20231225145929.png"><br>其中 ThreadStackSize 的单位是字节，也就是说默认的 JVM 栈大小是 1024 KB，也就是 1M。<br>换句话说，8GB = 8 _ 1024 MB = 8 _ 1024 _ 1024 KB，所以一个 8G 内存的系统可以创建的线程数为 8 _ 1024 = 8192 个。<br>但操作系统本身的运行也需要消耗一定的内存，所以实际上可以创建的线程数肯定会比 8192 少一些。<br>可以通过下面这段代码来验证一下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowErrorTest1</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            testStackOverflowError();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStackOverflowError</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(count.incrementAndGet());</span><br><span class="line">        testStackOverflowError();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="H0vsw"></a></p>
<h4 id="启动一个-Java-程序，你能说说里面有哪些线程吗？"><a href="#启动一个-Java-程序，你能说说里面有哪些线程吗？" class="headerlink" title="启动一个 Java 程序，你能说说里面有哪些线程吗？"></a>启动一个 Java 程序，你能说说里面有哪些线程吗？</h4><p>首先是 main 线程，这是程序开始执行的入口。<br>然后是垃圾回收线程，它是一个后台线程，负责回收不再使用的对象。<br>还有编译器线程，在及时编译中（JIT），负责把一部分热点代码编译后放到 codeCache 中，以提升程序的执行效率。<br>可以通过下面这段代码进行检测：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLister</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 获取所有线程的堆栈跟踪</span></span><br><span class="line">        Map&lt;Thread, StackTraceElement[]&gt; threads = Thread.getAllStackTraces();</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads.keySet()) {</span><br><span class="line">            System.out.println(<span class="string">"Thread: "</span> + thread.getName() + <span class="string">" (ID="</span> + thread.getId() + <span class="string">")"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread: Monitor Ctrl-Break (ID=5)</span><br><span class="line">Thread: Reference Handler (ID=2)</span><br><span class="line">Thread: main (ID=1)</span><br><span class="line">Thread: Signal Dispatcher (ID=4)</span><br><span class="line">Thread: Finalizer (ID=3)</span><br></pre></td></tr></tbody></table></figure>
<p>简单解释下：</p>
<ul>
<li><code>Thread: main (ID=1)</code> - 主线程，Java 程序启动时由 JVM 创建。</li>
<li><code>Thread: Reference Handler (ID=2)</code> - 这个线程是用来处理引用对象的，如软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference）。负责清理被 JVM 回收的对象。</li>
<li><code>Thread: Finalizer (ID=3)</code> - 终结器线程，负责调用对象的 finalize 方法。对象在垃圾回收器标记为可回收之前，由该线程执行其 finalize 方法，用于执行特定的资源释放操作。</li>
<li><code>Thread: Signal Dispatcher (ID=4)</code> - 信号调度线程，处理来自操作系统的信号，将它们转发给 JVM 进行进一步处理，例如响应中断、停止等信号。</li>
<li><code>Thread: Monitor Ctrl-Break (ID=5)</code> - 监视器线程，通常由一些特定的 IDE 创建，用于在开发过程中监控和管理程序执行或者处理中断。<br><a name="qKC4K"></a></li>
</ul>
<h3 id="4-调用-start-方法时会执行-run-方法，那怎么不直接调用-run-方法？"><a href="#4-调用-start-方法时会执行-run-方法，那怎么不直接调用-run-方法？" class="headerlink" title="4.调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？"></a>4.调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？</h3><p>在 Java 中，启动一个新的线程应该调用其<code>start()</code>方法，而不是直接调用<code>run()</code>方法。<br>当调用<code>start()</code>方法时，会启动一个新的线程，并让这个新线程调用<code>run()</code>方法。这样，<code>run()</code>方法就在新的线程中运行，从而实现多线程并发。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start(); <span class="comment">// 正确的方式，创建一个新线程，并在新线程中执行 run()</span></span><br><span class="line">        t1.run(); <span class="comment">// 仅在主线程中执行 run()，没有创建新线程</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果直接调用<code>run()</code>方法，那么<code>run()</code>方法就在当前线程中运行，没有新的线程被创建，也就没有实现多线程的效果。<br>来看输出结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-0</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，<code>start()</code> 方法的调用会告诉 JVM 准备好所有必要的新线程结构，分配其所需资源，并调用线程的 <code>run()</code> 方法在这个新线程中执行。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-5.png"><br><a name="cn0nD"></a></p>
<h3 id="5-线程有哪些常用的调度方法？"><a href="#5-线程有哪些常用的调度方法？" class="headerlink" title="5.线程有哪些常用的调度方法？"></a>5.线程有哪些常用的调度方法？</h3><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-6.png"><br><a name="J9xI2"></a></p>
<h4 id="说说线程等待与通知？"><a href="#说说线程等待与通知？" class="headerlink" title="说说线程等待与通知？"></a>说说线程等待与通知？</h4><p>在 Object 类中有一些方法可以用于线程的等待与通知。<br>①、<code>wait()</code>：当一个线程 A 调用一个共享变量的 <code>wait()</code> 方法时，线程 A 会被阻塞挂起，直到发生下面几种情况才会返回 ：</p>
<ul>
<li>线程 B 调用了共享对象 <code>notify()</code>或者 <code>notifyAll()</code> 方法；</li>
<li>其他线程调用了线程 A 的 <code>interrupt()</code> 方法，线程 A 抛出 InterruptedException 异常返回。</li>
</ul>
<p>②、<code>wait(long timeout)</code> ：这个方法相比 <code>wait()</code> 方法多了一个超时参数，它的不同之处在于，如果线程 A 调用共享对象的 <code>wait(long timeout)</code>方法后，没有在指定的 timeout 时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。<br>③、<code>wait(long timeout, int nanos)</code>，其内部调用的是 <code>wait(long timout)</code> 方法。<br>唤醒线程主要有下面两个方法：<br>①、<code>notify()</code>：一个线程 A 调用共享对象的 <code>notify()</code> 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。<br>一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。<br>②、<code>notifyAll()</code>：不同于在共享变量上调用 <code>notify()</code> 方法会唤醒被阻塞到该共享变量上的一个线程，notifyAll 方法会唤醒所有在该共享变量上调用 wait 系列方法而被挂起的线程。<br>Thread 类还提供了一个 <code>join()</code> 方法，意思是如果一个线程 A 执行了 <code>thread.join()</code>，当前线程 A 会等待 thread 线程终止之后才从 <code>thread.join()</code> 返回。<br><a name="To7O2"></a></p>
<h4 id="说说线程休眠"><a href="#说说线程休眠" class="headerlink" title="说说线程休眠"></a>说说线程休眠</h4><p><code>sleep(long millis)</code>：Thread 类中的静态方法，当一个执行中的线程 A 调用了 Thread 的 sleep 方法后，线程 A 会暂时让出指定时间的执行权。<br>但是线程 A 所拥有的监视器资源，比如锁，还是持有不让出的。指定的睡眠时间到了后该方法会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。<br><a name="wzAa4"></a></p>
<h4 id="说说让出优先权"><a href="#说说让出优先权" class="headerlink" title="说说让出优先权"></a>说说让出优先权</h4><p><code>yield()</code>：Thread 类中的静态方法，当一个线程调用 yield 方法时，实际是在暗示线程调度器，当前线程请求让出自己的 CPU，但是线程调度器可能会“装看不见”忽略这个暗示。<br><a name="LxDGO"></a></p>
<h4 id="说说线程中断"><a href="#说说线程中断" class="headerlink" title="说说线程中断"></a>说说线程中断</h4><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行。被中断的线程会根据中断状态自行处理。</p>
<ul>
<li><code>void interrupt()</code> 方法：中断线程，例如，当线程 A 运行时，线程 B 可以调用线程 <code>interrupt()</code> 方法来设置线程的中断标志为 true 并立即返回。设置标志仅仅是设置标志, 线程 B 实际并没有被中断，会继续往下执行。</li>
<li><code>boolean isInterrupted()</code> 方法： 检测当前线程是否被中断。</li>
<li><code>boolean interrupted()</code> 方法： 检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li>
</ul>
<p>为了响应中断，线程的执行代码应该这样编写：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) {</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        <span class="comment">// 线程被中断时的清理代码</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 线程结束前的清理代码</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>stop 方法用来强制线程停止执行，目前已经处于废弃状态，因为 stop 方法会导致线程立即停止，可能会在不一致的状态下释放锁，破坏对象的一致性，导致难以发现的错误和资源泄漏。<br><a name="CayJ0"></a></p>
<h3 id="6-线程有几种状态？"><a href="#6-线程有几种状态？" class="headerlink" title="6.线程有几种状态？"></a>6.线程有几种状态？</h3><p>在 Java 中，线程共有 6 种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>当线程被创建后，如通过<code>new Thread()</code>，它处于新建状态。此时，线程已经被分配了必要的资源，但还没有开始执行。</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>当调用线程的<code>start()</code>方法后，线程进入可运行状态。在这个状态下，线程可能正在运行也可能正在等待获取 CPU 时间片，具体取决于线程调度器的调度策略。</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>线程在试图获取一个锁以进入同步块/方法时，如果锁被其他线程持有，线程将进入阻塞状态，直到它获取到锁。</td>
</tr>
<tr>
<td>WAITING</td>
<td>线程进入等待状态是因为调用了如下方法之一：<code>Object.wait()</code>或<code>LockSupport.park()</code>。在等待状态下，线程需要其他线程显式地唤醒，否则不会自动执行。</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>当线程调用带有超时参数的方法时，如<code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code> 或<code>LockSupport.parkNanos()</code>，它将进入超时等待状态。线程在指定的等待时间过后会自动返回可运行状态。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>当线程的<code>run()</code>方法执行完毕后，或者因为一个未捕获的异常终止了执行，线程进入终止状态。一旦线程终止，它的生命周期结束，不能再被重新启动。</td>
</tr>
</tbody></table>
<p>线程在自身的生命周期中，并不是固定地处于某个状态，而是在不同的状态之间进行切换：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-7.png"><br><a name="AUFEw"></a></p>
<h3 id="7-什么是线程上下文切换？"><a href="#7-什么是线程上下文切换？" class="headerlink" title="7.什么是线程上下文切换？"></a>7.什么是线程上下文切换？</h3><p>使用多线程的目的是为了充分利用 CPU，但是我们知道，并发其实是一个 CPU 来应付多个线程。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-8.png"><br>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-9.png"><br><a name="Wt7qj"></a></p>
<h4 id="线程可以被多核调度吗？"><a href="#线程可以被多核调度吗？" class="headerlink" title="线程可以被多核调度吗？"></a>线程可以被多核调度吗？</h4><p>当然可以，在现代操作系统和多核处理器的环境中，线程的调度和管理是操作系统内核的重要职责之一。<br>操作系统的调度器负责将线程分配给可用的 CPU 核心，从而实现并行处理。<br>多核处理器提供了并行执行多个线程的能力。每个核心可以独立执行一个或多个线程，操作系统的任务调度器会根据策略和算法，如优先级调度、轮转调度等，决定哪个线程何时在哪个核心上运行。<br><a name="jVrJm"></a></p>
<h3 id="8-守护线程了解吗？"><a href="#8-守护线程了解吗？" class="headerlink" title="8.守护线程了解吗？"></a>8.守护线程了解吗？</h3><p>Java 中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。<br>在 JVM 启动时会调用 main 方法，main 方法所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。<br>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM 会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM 退出。换而言之，只要有一个用户线程还没结束，正常情况下 JVM 就不会退出。<br><a name="bGlth"></a></p>
<h3 id="9-线程间有哪些通信方式？"><a href="#9-线程间有哪些通信方式？" class="headerlink" title="9.线程间有哪些通信方式？"></a>9.线程间有哪些通信方式？</h3><p>线程之间传递信息有多种方式，每种方式适用于不同的场景。比如说使用共享对象、<code>wait()</code> 和 <code>notify()</code>、Exchanger 和 CompletableFuture。<br>①、<strong>使用共享对象</strong>，多个线程可以访问和修改同一个对象，从而实现信息的传递，比如说 volatile 和 synchronized 关键字。<br><a href="https://javabetter.cn/thread/volatile.html">关键字 volatile</a> 用来修饰成员变量，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。<br><a href="https://javabetter.cn/thread/synchronized-1.html">关键字 synchronized</a> 可以修饰方法，或者以同步代码块的形式来使用，确保多个线程在同一个时刻，只能有一个线程在执行某个方法或某个代码块。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedObject</span> {</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">hasMessage</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writeMessage</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="keyword">while</span> (hasMessage) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        hasMessage = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">readMessage</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (!hasMessage) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        hasMessage = <span class="literal">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">SharedObject</span> <span class="variable">sharedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            sharedObject.writeMessage(<span class="string">"Hello from Writer!"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sharedObject.readMessage();</span><br><span class="line">            System.out.println(<span class="string">"Reader received: "</span> + message);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        writer.start();</span><br><span class="line">        reader.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>②、**使用 wait() 和 notify()**，例如，生产者-消费者模式中，生产者生产数据，消费者消费数据，通过 <code>wait()</code> 和 <code>notify()</code> 方法可以实现生产和消费的协调。<br>一个线程调用共享对象的 <code>wait()</code> 方法时，它会进入该对象的等待池，并释放已经持有的该对象的锁，进入等待状态，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。<br>一个线程调用共享对象的 <code>notify()</code> 方法时，它会唤醒在该对象等待池中等待的一个线程，使其进入锁池，等待获取锁。<br><a href="https://javabetter.cn/thread/condition.html">Condition</a> 也提供了类似的方法，<code>await()</code> 负责等待、<code>signal()</code> 和 <code>signalAll()</code> 负责通知。<br>通常与锁（特别是 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a>）一起使用，为线程提供了一种等待某个条件成真的机制，并允许其他线程在该条件变化时通知等待线程。更灵活、更强大。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageBox</span> {</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="keyword">while</span> (!empty) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        empty = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">consume</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">while</span> (empty) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        empty = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MessageBox</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBox</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            box.produce(<span class="string">"Message from producer"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> box.consume();</span><br><span class="line">            System.out.println(<span class="string">"Consumer received: "</span> + message);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>③、<strong>使用 Exchanger</strong>，Exchanger 是一个同步点，可以在两个线程之间交换数据。一个线程调用 exchange() 方法，将数据传递给另一个线程，同时接收另一个线程的数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">"Message from thread1"</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> exchanger.exchange(message);</span><br><span class="line">                System.out.println(<span class="string">"Thread1 received: "</span> + response);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">"Message from thread2"</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> exchanger.exchange(message);</span><br><span class="line">                System.out.println(<span class="string">"Thread2 received: "</span> + response);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>④、<strong>使用 CompletableFuture</strong>，CompletableFuture 是 Java 8 引入的一个类，支持异步编程，允许线程在完成计算后将结果传递给其他线程。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">            <span class="comment">// 模拟长时间计算</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Message from CompletableFuture"</span>;</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        future.thenAccept(message -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"Received: "</span> + message);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为 OD 的面试中出现过该原题。</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里面经同学 1 闲鱼后端一面的原题：线程之间传递信息?</li>
</ol>
</blockquote>
<p><a name="W5DUp"></a></p>
<h3 id="10-请说说-sleep-和-wait-的区别？（补充）"><a href="#10-请说说-sleep-和-wait-的区别？（补充）" class="headerlink" title="10.请说说 sleep 和 wait 的区别？（补充）"></a>10.请说说 sleep 和 wait 的区别？（补充）</h3><blockquote>
<p>2024 年 03 月 21 日增补</p>
</blockquote>
<p>答：<code>sleep()</code> 和 <code>wait()</code> 是 Java 中用于暂停当前线程的两个重要方法，sleep 是让当前线程休眠，不涉及对象类，也不需要获取对象的锁，属于 Thread 类的方法；wait 是让获得对象锁的线程实现等待，前提要获得对象的锁，属于 Object 类的方法。<br>它们之间的区别主要有以下几点：<br>①、所属类不同</p>
<ul>
<li><code>sleep()</code> 方法专属于 <code>Thread</code> 类。</li>
<li><code>wait()</code> 方法专属于 <code>Object</code> 类。</li>
</ul>
<p>②、锁行为不同<br>当线程执行 sleep 方法时，它不会释放任何锁。也就是说，如果一个线程在持有某个对象的锁时调用了 sleep，它在睡眠期间仍然会持有这个锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepDoesNotReleaseLock</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">sleepingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                System.out.println(<span class="string">"Thread 1 会继续持有锁，并且进入睡眠状态"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"Thread 1 醒来了，并且释放了锁"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                System.out.println(<span class="string">"Thread 2 进入同步代码块"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        sleepingThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        waitingThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 会继续持有锁，并且进入睡眠状态</span><br><span class="line">Thread 1 醒来了，并且释放了锁</span><br><span class="line">Thread 2 进入同步代码块</span><br></pre></td></tr></tbody></table></figure>
<p>从输出中我们可以看到，waitingThread 必须等待 sleepingThread 完成睡眠后才能进入同步代码块。<br>而当线程执行 wait 方法时，它会释放它持有的那个对象的锁，这使得其他线程可以有机会获取该对象的锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitReleasesLock</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"Thread 1 持有锁，准备等待 5 秒"</span>);</span><br><span class="line">                    lock.wait(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Thread 1 醒来了，并且退出同步代码块"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">notifyingThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                System.out.println(<span class="string">"Thread 2 尝试唤醒等待中的线程"</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">"Thread 2 执行完了 notify"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        waitingThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        notifyingThread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 持有锁，准备等待 5 秒</span><br><span class="line">Thread 2 尝试唤醒等待中的线程</span><br><span class="line">Thread 2 执行完了 notify</span><br><span class="line">Thread 1 醒来了，并且退出同步代码块</span><br></pre></td></tr></tbody></table></figure>
<p>这表明 waitingThread 在调用 wait 后确实释放了锁。<br>③、使用条件不同</p>
<ul>
<li><code>sleep()</code> 方法可以在任何地方被调用。</li>
<li><code>wait()</code> 方法必须在同步代码块或同步方法中被调用，这是因为调用 <code>wait()</code> 方法的前提是当前线程必须持有对象的锁。否则会抛出 <code>IllegalMonitorStateException</code> 异常。</li>
</ul>
<p>④、唤醒方式不同</p>
<ul>
<li>调用 sleep 方法后，线程会进入 TIMED_WAITING 状态（定时等待状态），即在指定的时间内暂停执行。当指定的时间结束后，线程会自动恢复到 RUNNABLE 状态（就绪状态），等待 CPU 调度再次执行。</li>
<li>调用 wait 方法后，线程会进入 WAITING 状态（无限期等待状态），直到有其他线程在同一对象上调用 notify 或 notifyAll，线程才会从 WAITING 状态转变为 RUNNABLE 状态，准备再次获得 CPU 的执行权。</li>
</ul>
<p>⑤、抛出异常不同</p>
<ul>
<li><code>sleep()</code> 方法在等待期间，如果线程被中断，会抛出 <code>InterruptedException</code>。</li>
<li>如果线程被中断或等待时间到期时，<code>wait()</code> 方法同样会在等待期间抛出 <code>InterruptedException</code>。</li>
</ul>
<p>我们来通过代码再感受一下 <code>sleep()</code> 和 <code>wait()</code> 在用法上的区别，先看 <code>sleep()</code> 的用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"线程准备休眠 2 秒"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 线程将睡眠2秒</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"线程醒来了"</span>);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再来看 <code>wait()</code> 的用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"线程准备等待 2 秒"</span>);</span><br><span class="line">                    lock.wait(<span class="number">2000</span>); <span class="comment">// 线程会等待2秒，或者直到其他线程调用 lock.notify()/notifyAll()</span></span><br><span class="line">                    System.out.println(<span class="string">"线程结束等待"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="RK0s7"></a></p>
<h3 id="11-线程安全，说一个使用场景？（补充）"><a href="#11-线程安全，说一个使用场景？（补充）" class="headerlink" title="11.线程安全，说一个使用场景？（补充）"></a>11.线程安全，说一个使用场景？（补充）</h3><blockquote>
<p>2024 年 05 月 01 日增补</p>
</blockquote>
<p>线程安全是 Java 并发编程中一个非常重要的概念，它指的是多线程环境下，多个线程对共享资源的访问不会导致数据的不一致性。<br>一个常见的使用场景是在实现单例模式时确保线程安全。<br>单例模式确保一个类只有一个实例，并提供一个全局访问点。在多线程环境下，如果多个线程同时尝试创建实例，单例类必须确保只创建一个实例。<br>饿汉式是一种比较直接的实现方式，它通过在类加载时就立即初始化单例对象来保证线程安全。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>懒汉式单例则在第一次使用时初始化，这种方式需要使用双重检查锁定来确保线程安全，volatile 用来保证可见性，syncronized 用来保证同步。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) { <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) { <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="IBOtH"></a></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a name="FrtYg"></a></p>
<h3 id="12-ThreadLocal-是什么？"><a href="#12-ThreadLocal-是什么？" class="headerlink" title="12.ThreadLocal 是什么？"></a>12.ThreadLocal 是什么？</h3><p><a href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-11.png"><br>在 Web 应用中，可以使用 ThreadLocal 存储用户会话信息，这样每个线程在处理用户请求时都能方便地访问当前用户的会话信息。<br>在数据库操作中，可以使用 ThreadLocal 存储数据库连接对象，每个线程有自己独立的数据库连接，从而避免了多线程竞争同一数据库连接的问题。<br>在格式化操作中，例如日期格式化，可以使用 ThreadLocal 存储 SimpleDateFormat 实例，避免多线程共享同一实例导致的线程安全问题。<br>使用 ThreadLocal 通常分为四步：<br>①、创建 ThreadLocal</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ThreadLocal变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure>
<p>②、设置 ThreadLocal 的值</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置ThreadLocal变量的值</span></span><br><span class="line">localVariable.set(<span class="string">"沉默王二是沙雕"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>③、获取 ThreadLocal 的值</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal变量的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> localVariable.get();</span><br></pre></td></tr></tbody></table></figure>
<p>④、删除 ThreadLocal 的值</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除ThreadLocal变量的值</span></span><br><span class="line">localVariable.remove();</span><br></pre></td></tr></tbody></table></figure>
<p><a name="KpXJD"></a></p>
<h4 id="除了-ThreadLocal，还有什么解决线程安全问题的方法？"><a href="#除了-ThreadLocal，还有什么解决线程安全问题的方法？" class="headerlink" title="除了 ThreadLocal，还有什么解决线程安全问题的方法？"></a>除了 ThreadLocal，还有什么解决线程安全问题的方法？</h4><p>①、Java 中的 synchronized 关键字可以用于方法和代码块，确保同一时间只有一个线程可以执行特定的代码段。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 线程安全的操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>②、Java 并发包（java.util.concurrent.locks）中提供了 Lock 接口和一些实现类，如 ReentrantLock。相比于 synchronized，ReentrantLock 提供了公平锁和非公平锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 线程安全的操作</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>③、Java 并发包还提供了一组原子变量类（如 AtomicInteger，AtomicLong 等），它们利用 CAS（比较并交换），实现了无锁的原子操作，适用于简单的计数器场景。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">    atomicInteger.incrementAndGet();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>④、Java 并发包提供了一些线程安全的集合类，如 ConcurrentHashMap，CopyOnWriteArrayList 等。这些集合类内部实现了必要的同步策略，提供了更高效的并发访问。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure>
<p>⑤、volatile 变量保证了变量的可见性，修改操作是立即同步到主存的，读操作从主存中读取。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure>
<p><a name="UNHik"></a></p>
<h3 id="13-你在工作中用到过-ThreadLocal-吗？"><a href="#13-你在工作中用到过-ThreadLocal-吗？" class="headerlink" title="13.你在工作中用到过 ThreadLocal 吗？"></a>13.你在工作中用到过 ThreadLocal 吗？</h3><p>有用到过，用来存储用户信息。<br><a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>是典型的 MVC 架构，登录后的用户每次访问接口，都会在请求头中携带一个 token，在控制层可以根据这个 token，解析出用户的基本信息。<br>假如在服务层和持久层也要用到用户信息，就可以在控制层拦截请求把用户信息存入 ThreadLocal。<br>这样我们在任何一个地方，都可以取出 ThreadLocal 中存的用户信息。<br>很多其它场景的 cookie、session 等等数据隔离都可以通过 ThreadLocal 去实现。<br>数据库连接池也可以用 ThreadLocal，将数据库连接池的连接交给 ThreadLocal 进行管理，能够保证当前线程的操作都是同一个 Connnection。<br><a name="UBzMw"></a></p>
<h3 id="14-ThreadLocal-怎么实现的呢？"><a href="#14-ThreadLocal-怎么实现的呢？" class="headerlink" title="14.ThreadLocal 怎么实现的呢？"></a>14.ThreadLocal 怎么实现的呢？</h3><p>ThreadLocal 本身并不存储任何值，它只是作为一个映射，来映射线程的局部变量。当一个线程调用 ThreadLocal 的 set 或 get 方法时，实际上是访问线程自己的 ThreadLocal.ThreadLocalMap。<br>ThreadLocalMap 是 ThreadLocal 的静态内部类，它内部维护了一个 Entry 数组，key 是 ThreadLocal 对象，value 是线程的局部变量本身。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-13.png"><br>早期的 ThreadLocal 不是这样的，它的 ThreadLocalMap 中使用 Thread 作为 key，这也是最简单的实现方式。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240429112840.png"><br>优化后的方案有两个好处，一个是 Map 中存储的键值对变少了；另一个是 ThreadLocalMap 的生命周期和线程一样长，线程销毁的时候，ThreadLocalMap 也会被销毁。<br>Entry 继承了 WeakReference，它限定了 key 是一个弱引用，弱引用的好处是当内存不足时，JVM 会回收 ThreadLocal 对象，并且将其对应的 Entry 的 value 设置为 null，这样在很大程度上可以避免内存泄漏。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">        <span class="comment">//key赋值</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="comment">//value赋值</span></span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ThreadLocal 的实现原理就是，每个线程维护一个 Map，key 为 ThreadLocal 对象，value 为想要实现线程隔离的对象。<br>1、当需要存线程隔离的对象时，通过 ThreadLocal 的 set 方法将对象存入 Map 中。<br>2、当需要取线程隔离的对象时，通过 ThreadLocal 的 get 方法从 Map 中取出对象。<br>3、Map 的大小由 ThreadLocal 对象的多少决定。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407205747.png"><br><a name="zklfM"></a></p>
<h4 id="什么是弱引用，什么是强引用？"><a href="#什么是弱引用，什么是强引用？" class="headerlink" title="什么是弱引用，什么是强引用？"></a>什么是弱引用，什么是强引用？</h4><p>强引用，比如说 <code>User user = new User("沉默王二")</code> 中，user 就是一个强引用，<code>new User("沉默王二")</code> 就是一个强引用对象。<br>当 user 被置为 null 时（<code>user = null</code>），<code>new User("沉默王二")</code> 将会被垃圾回收；如果 user 不被置为 null，即便是内存空间不足，JVM 也不会回收 <code>new User("沉默王二")</code> 这个强引用对象，宁愿抛出 OutOfMemoryError。<br>弱引用，比如说下面这段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;User&gt; userThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">userThreadLocal.set(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"沉默王二"</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>①、userThreadLocal 是一个强引用，<code>new ThreadLocal&lt;&gt;()</code> 是一个强引用对象；<br>②、<code>new User("沉默王二")</code> 是一个强引用对象。<br>③、在 ThreadLocalMap 中，<code>key = new ThreadLocal&lt;&gt;()</code> 是一个弱引用对象。当 JVM 进行垃圾回收时，如果发现了弱引用对象，就会将其回收。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-14.png"><br>其关系链就是：</p>
<ul>
<li>ThreadLocal 强引用 -&gt; ThreadLocal 对象。</li>
<li>Thread 强引用 -&gt; ThreadLocalMap。</li>
<li><code>ThreadLocalMap[i]</code> 强引用了 -&gt; Entry。</li>
<li>Entry.key 弱引用 -&gt; ThreadLocal 对象。</li>
<li>Entry.value 强引用 -&gt; 线程的局部变量对象。<br><a name="QBSyz"></a></li>
</ul>
<h3 id="15-ThreadLocal-内存泄露是怎么回事？"><a href="#15-ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="15.ThreadLocal 内存泄露是怎么回事？"></a>15.ThreadLocal 内存泄露是怎么回事？</h3><p>通常情况下，随着线程 Thread 的结束，其内部的 ThreadLocalMap 也会被回收，从而避免了内存泄漏。<br>但如果一个线程一直在运行，并且其 <code>ThreadLocalMap</code> 中的 Entry.value 一直指向某个强引用对象，那么这个对象就不会被回收，从而导致内存泄漏。当 Entry 非常多时，可能就会引发更严重的内存溢出问题。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407212932.png"><br><a name="q8zaj"></a></p>
<h4 id="那怎么解决内存泄漏问题呢？"><a href="#那怎么解决内存泄漏问题呢？" class="headerlink" title="那怎么解决内存泄漏问题呢？"></a>那怎么解决内存泄漏问题呢？</h4><p>很简单，使用完 ThreadLocal 后，及时调用 <code>remove()</code> 方法释放内存空间。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    threadLocal.set(value);</span><br><span class="line">    <span class="comment">// 执行业务操作</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    threadLocal.remove(); <span class="comment">// 确保能够执行清理</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>remove()</code> 方法会将当前线程的 ThreadLocalMap 中的所有 key 为 null 的 Entry 全部清除，这样就能避免内存泄漏问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">            e != <span class="literal">null</span>;</span><br><span class="line">            e = tab[i = nextIndex(i, len)]) {</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) {</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">this</span>.referent = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="eJezc"></a></p>
<h4 id="那为什么-key-要设计成弱引用？"><a href="#那为什么-key-要设计成弱引用？" class="headerlink" title="那为什么 key 要设计成弱引用？"></a>那为什么 key 要设计成弱引用？</h4><p>弱引用的好处是，当内存不足的时候，JVM 会主动回收掉弱引用的对象。<br>比如说：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WeakReference</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>());</span><br></pre></td></tr></tbody></table></figure>
<p>key 是弱引用，<code>new WeakReference(new ThreadLocal())</code> 是弱引用对象，当 JVM 进行垃圾回收时，如果发现了弱引用对象，就会将其回收。<br>一旦 key 被回收，ThreadLocalMap 在进行 set、get 的时候就会对 key 为 null 的 Entry 进行清理。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240407214616.png"><br>总结一下，在 ThreadLocal 被垃圾收集后，下一次访问 ThreadLocalMap 时，Java 会自动清理那些键为 null 的条目（参照源码中的 replaceStaleEntry 方法），这个过程会在执行 ThreadLocalMap 相关操作（如 <code>get()</code>, <code>set()</code>, <code>remove()</code>）时触发。<br><a name="M5eXD"></a></p>
<h4 id="你了解哪些-ThreadLocal-的改进方案？"><a href="#你了解哪些-ThreadLocal-的改进方案？" class="headerlink" title="你了解哪些 ThreadLocal 的改进方案？"></a>你了解哪些 ThreadLocal 的改进方案？</h4><p>在 JDK 20 Early-Access Build 28 版本中，出现了 ThreadLocal 的改进方案，即 <code>ScopedValue</code>。<br>还有 Netty 中的 FastThreadLocal，它是 Netty 对 ThreadLocal 的优化，它内部维护了一个索引常量 index，每次创建 FastThreadLocal 中都会自动+1，用来取代 hash 冲突带来的损耗，用空间换时间。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FastThreadLocal</span><span class="params">()</span> {</span><br><span class="line">    index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextVariableIndex</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nextIndex.getAndIncrement();</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) {</span><br><span class="line">        nextIndex.decrementAndGet();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="u5Yfg"></a></p>
<h3 id="16-ThreadLocalMap-的源码看过吗？"><a href="#16-ThreadLocalMap-的源码看过吗？" class="headerlink" title="16.ThreadLocalMap 的源码看过吗？"></a>16.ThreadLocalMap 的源码看过吗？</h3><p>ThreadLocalMap 虽然被叫做 Map，其实它是没有实现 Map 接口的，但是结构还是和 HashMap 比较类似的，主要关注的是两个要素：<code>元素数组</code>和<code>散列方法</code>。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-15.png"></p>
<ul>
<li><p>元素数组一个 table 数组，存储 Entry 类型的元素，Entry 是 ThreaLocal 弱引用作为 key，Object 作为 value 的结构。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>散列方法散列方法就是怎么把对应的 key 映射到 table 数组的相应下标，ThreadLocalMap 用的是哈希取余法，取出 key 的 threadLocalHashCode，然后和 table 数组长度减一&amp;运算（相当于取余）。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>这里的 threadLocalHashCode 计算有点东西，每创建一个 ThreadLocal 对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="l4mVp"></a></p>
</li>
</ul>
<h3 id="17-ThreadLocalMap-怎么解决-Hash-冲突的？"><a href="#17-ThreadLocalMap-怎么解决-Hash-冲突的？" class="headerlink" title="17.ThreadLocalMap 怎么解决 Hash 冲突的？"></a>17.ThreadLocalMap 怎么解决 Hash 冲突的？</h3><p>我们可能都知道 HashMap 使用了链表来解决冲突，也就是所谓的链地址法。<br>ThreadLocalMap 没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——<strong>开放定址法</strong>。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-16.png"><br>如上图所示，如果我们插入一个 value=27 的数据，通过 hash 计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry 数据，而且 Entry 数据的 key 和当前不相等。此时就会线性向后查找，一直找到 Entry 为 null 的槽位才会停止查找，把元素放到空的槽中。<br>在 get 的时候，也会根据 ThreadLocal 对象的 hash 值，定位到 table 中的位置，然后判断该槽位 Entry 对象中的 key 是否和 get 的 key 一致，如果不一致，就判断下一个位置。<br><a name="xDx9g"></a></p>
<h3 id="18-ThreadLocalMap-扩容机制了解吗？"><a href="#18-ThreadLocalMap-扩容机制了解吗？" class="headerlink" title="18.ThreadLocalMap 扩容机制了解吗？"></a>18.ThreadLocalMap 扩容机制了解吗？</h3><p>在 ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></tbody></table></figure>
<p>再着看 rehash()具体实现：这里会先去清理过期的 Entry，然后还要根据条件判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code>来决定是否需要扩容。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//清理过期Entry</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理过期Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) {</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>接着看看具体的<code>resize()</code>方法，扩容后的<code>newTab</code>的大小为老数组的两倍，然后遍历老的 table 数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code>，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后 table 引用指向<code>newTab</code><br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-17.png"><br><a name="Ccihf"></a></p>
<h3 id="19-父子线程怎么共享数据？"><a href="#19-父子线程怎么共享数据？" class="headerlink" title="19.父子线程怎么共享数据？"></a>19.父子线程怎么共享数据？</h3><p>父线程能用 ThreadLocal 来给子线程传值吗？毫无疑问，不能。那该怎么办？<br>这时候可以用到另外一个类——<code>InheritableThreadLocal </code>。<br>使用起来很简单，在主线程的 InheritableThreadLocal 实例设置值，在子线程中就可以拿到了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        threadLocal.set(<span class="string">"不擅技术"</span>);</span><br><span class="line">        <span class="comment">//子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">                System.out.println(<span class="string">"鄙人三某 ，"</span> + threadLocal.get());</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        t.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>那原理是什么呢？</p>
</blockquote>
<p>原理很简单，在 Thread 类里还有另外一个变量：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在 Thread.init 的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals </code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></tbody></table></figure>
<p><a name="N6dCa"></a></p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><a name="Ykt8F"></a></p>
<h3 id="20-说一下你对-Java-内存模型的理解？"><a href="#20-说一下你对-Java-内存模型的理解？" class="headerlink" title="20.说一下你对 Java 内存模型的理解？"></a>20.说一下你对 Java 内存模型的理解？</h3><p>推荐阅读：<a href="https://javabetter.cn/thread/jmm.html">说说 Java 的内存模型</a><br>Java 内存模型（Java Memory Model）是一种抽象的模型，简称 JMM，主要用来定义多线程中变量的访问规则，用来解决变量的可见性、有序性和原子性问题，确保在并发环境中安全地访问共享变量。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2.jpeg"><br>JMM 定义了线程内存和主内存之间的抽象关系：线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了共享变量的副本，用来进行线程内部的读写操作。</p>
<ul>
<li>当一个线程更改了本地内存中共享变量的副本后，它需要将这些更改刷新到主内存中，以确保其他线程可以看到这些更改。</li>
<li>当一个线程需要读取共享变量时，它可能首先从本地内存中读取。如果本地内存中的副本是过时的，线程将从主内存中重新加载共享变量的最新值到本地内存中。</li>
</ul>
<p>本地内存是 JMM 中的一个抽象概念，并不真实存在。实际上，本地内存可能对应于 CPU 缓存、寄存器或者其他硬件和编译器优化。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20.png"><br>对于一个双核 CPU 的系统架构，每个核都有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。<br>每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。<br>Java 内存模型里面的本地内存，可能对应的是 L1 缓存或者 L2 缓存或者 CPU 寄存器。<br><a name="NFqcs"></a></p>
<h4 id="为什么线程要用自己的内存？"><a href="#为什么线程要用自己的内存？" class="headerlink" title="为什么线程要用自己的内存？"></a>为什么线程要用自己的内存？</h4><p>第一，在多线程环境中，如果所有线程都直接操作主内存中的共享变量，会引发更多的内存访问竞争，这不仅影响性能，还增加了线程安全问题的复杂度。通过让每个线程使用本地内存，可以减少对主内存的直接访问和竞争，从而提高程序的并发性能。<br>第二，现代 CPU 为了优化执行效率，可能会对指令进行乱序执行（指令重排序）。使用本地内存（CPU 缓存和寄存器）可以在不影响最终执行结果的前提下，使得 CPU 有更大的自由度来乱序执行指令，从而提高执行效率。<br><a name="IqiCC"></a></p>
<h3 id="21-说说你对原子性、可见性、有序性的理解？"><a href="#21-说说你对原子性、可见性、有序性的理解？" class="headerlink" title="21.说说你对原子性、可见性、有序性的理解？"></a>21.说说你对原子性、可见性、有序性的理解？</h3><ul>
<li><strong>原子性</strong>：指的是一个操作是不可分割的，要么全部执行成功，要么完全不执行。</li>
<li><strong>可见性</strong>：指的是一个线程对共享变量的修改，能够被其他线程及时看见。</li>
<li><strong>有序性</strong>：指的是程序代码的执行顺序与代码中的顺序一致。在没有同步机制的情况下，编译器可能会对指令进行重排序，以优化性能。这种重排序可能会导致多线程的执行结果与预期不符。<br><a name="yjNaR"></a></li>
</ul>
<h4 id="原子性、可见性、有序性都应该怎么保证呢？"><a href="#原子性、可见性、有序性都应该怎么保证呢？" class="headerlink" title="原子性、可见性、有序性都应该怎么保证呢？"></a>原子性、可见性、有序性都应该怎么保证呢？</h4><ul>
<li>原子性：JMM 只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<code>synchronized </code>。</li>
<li>可见性：Java 是利用<code>volatile</code>关键字来保证可见性的，除此之外，<code>final</code>和<code>synchronized</code>也能保证可见性。</li>
<li>有序性：<code>synchronized</code>或者<code>volatile</code>都可以保证多线程之间操作的有序性。<br><a name="f8mxL"></a></li>
</ul>
<h4 id="i-是原子操作吗？"><a href="#i-是原子操作吗？" class="headerlink" title="i++是原子操作吗？"></a>i++是原子操作吗？</h4><p>i++ 不是一个原子操作，它包括三个步骤：</p>
<ol>
<li>从内存中读取 i 的值。</li>
<li>对 i 进行加 1 操作。</li>
<li>将新的值写入内存。</li>
</ol>
<p>假如两个线程同时对 i 进行 i++ 操作时，可能会发生以下情况：</p>
<ol>
<li>线程 A 读取 i 的值（假设 i 的初始值为 1）。</li>
<li>线程 B 也读取 i 的值（值仍然是 1）。</li>
<li>线程 A 将 i 增加到 2，并将其写回内存。</li>
<li>线程 B 也将 i 增加到 2，并将其写回内存。</li>
</ol>
<p>尽管进行了两次递增操作，i 的值只增加了 1 而不是 2。可以使用 synchronized 或 AtomicInteger 确保操作的原子性。<br><a name="GdE4p"></a></p>
<h3 id="22-那说说什么是指令重排？"><a href="#22-那说说什么是指令重排？" class="headerlink" title="22.那说说什么是指令重排？"></a>22.那说说什么是指令重排？</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分 3 种类型。</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面 3 种重排序，如图：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-21.png"><br>我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，<code>Singleton instance=new Singleton()；</code>对应的 JVM 指令分为三步：分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-22.png"><br>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。<br><a name="LxXOf"></a></p>
<h3 id="23-指令重排有限制吗？happens-before-了解吗？"><a href="#23-指令重排有限制吗？happens-before-了解吗？" class="headerlink" title="23.指令重排有限制吗？happens-before 了解吗？"></a>23.指令重排有限制吗？happens-before 了解吗？</h3><p>指令重排也是有一些限制的，有两个规则<code>happens-before</code>和<code>as-if-serial</code>来约束。<br>happens-before 的定义：</p>
<ul>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法</li>
</ul>
<p>happens-before 和我们息息相关的有六大规则：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-23.png"></p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li>
<li><strong>volatile 变量规则</strong>：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li>
<li><strong>传递性</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li>
<li><strong>start()规则</strong>：如果线程 A 执行操作 ThreadB.start()（启动线程 B），那么 A 线程的 ThreadB.start()操作 happens-before 于线程 B 中的任意操作。</li>
<li><strong>join()规则</strong>：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。<br><a name="pBa34"></a></li>
</ul>
<h3 id="24-as-if-serial-又是什么？单线程的程序一定是顺序的吗？"><a href="#24-as-if-serial-又是什么？单线程的程序一定是顺序的吗？" class="headerlink" title="24.as-if-serial 又是什么？单线程的程序一定是顺序的吗？"></a>24.as-if-serial 又是什么？单线程的程序一定是顺序的吗？</h3><p>as-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），<strong>单线程程序的执行结果不能被改变</strong>。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。<br>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;   <span class="comment">// A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1.0</span>;   <span class="comment">// B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   <span class="comment">// C</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面 3 个操作的数据依赖关系：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-24.png"><br>A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。<br>所以最终，程序可能会有两种执行顺序：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-25.png"><br>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器、runtime 和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial 语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。<br><a name="J62kQ"></a></p>
<h3 id="25-volatile-实现原理了解吗？"><a href="#25-volatile-实现原理了解吗？" class="headerlink" title="25.volatile 实现原理了解吗？"></a>25.volatile 实现原理了解吗？</h3><p>volatile 关键字主要有两个作用，一个是保证变量的内存可见性，一个是禁止指令重排序。<br><a name="ZKPT7"></a></p>
<h4 id="volatile-怎么保证可见性的呢？"><a href="#volatile-怎么保证可见性的呢？" class="headerlink" title="volatile 怎么保证可见性的呢？"></a>volatile 怎么保证可见性的呢？</h4><p>当一个变量被声明为 volatile 时，Java 内存模型会确保所有线程看到该变量时的值是一致的。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2.jpeg"><br>也就是说，当线程对 volatile 变量进行写操作时，JMM 会在写入这个变量之后插入一个 Store-Barrier（写屏障）指令，这个指令会强制将本地内存中的变量值刷新到主内存中。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-28.png"><br>当线程对 volatile 变量进行读操作时，JMM 会插入一个 Load-Barrier（读屏障）指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-29.png"><br>例如，我们声明一个 volatile 变量 x：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>线程 A 对 x 写入后会将其最新的值刷新到主内存中，线程 B 读取 x 时由于本地内存中的 x 失效了，就会从主内存中读取最新的值，内存可见性达成！<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-26.png"><br><a name="QqUeL"></a></p>
<h4 id="volatile-怎么保证有序性的呢？"><a href="#volatile-怎么保证有序性的呢？" class="headerlink" title="volatile 怎么保证有序性的呢？"></a>volatile 怎么保证有序性的呢？</h4><p>在程序执行期间，为了提高性能，编译器和处理器会对指令进行重排序。但涉及到 volatile 变量时，它们必须遵循一定的规则：</p>
<ul>
<li>写 volatile 变量的操作之前的操作不会被编译器重排序到写操作之后。</li>
<li>读 volatile 变量的操作之后的操作不会被编译器重排序到读操作之前。</li>
</ul>
<p>这意味着 volatile 变量的写操作总是发生在任何后续读操作之前。<br><a name="Y1iyq"></a></p>
<h4 id="volatile-和-synchronized-的区别"><a href="#volatile-和-synchronized-的区别" class="headerlink" title="volatile 和 synchronized 的区别"></a>volatile 和 synchronized 的区别</h4><p>volatile 关键字用于修饰变量，确保该变量的更新操作对所有线程是可见的，即一旦某个线程修改了 volatile 变量，其他线程会立即看到最新的值。<br>synchronized 关键字用于修饰方法或代码块，确保同一时刻只有一个线程能够执行该方法或代码块，从而实现互斥访问。<br><a name="xmrsW"></a></p>
<h4 id="volatile-加在基本类型和对象上的区别？"><a href="#volatile-加在基本类型和对象上的区别？" class="headerlink" title="volatile 加在基本类型和对象上的区别？"></a>volatile 加在基本类型和对象上的区别？</h4><p>当 <code>volatile</code> 用于基本数据类型时，能确保该变量的读写操作是直接从主内存中读取或写入的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>当 <code>volatile</code> 用于引用类型时，它确保引用本身的可见性，即确保引用指向的对象地址是最新的。<br>但是，<code>volatile</code> 并不能保证引用对象内部状态的线程安全性。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">SomeObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeObject</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>虽然 <code>volatile</code> 确保了 <code>obj</code> 引用的可见性，但对 <code>obj</code> 引用的具体对象的操作并不受 <code>volatile</code> 保护。如果需要保证引用对象内部状态的线程安全，需要使用其他同步机制（如 <code>synchronized</code> 或 <code>ReentrantLock</code>）。<br><a name="BiWhR"></a></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a name="p0TpD"></a></p>
<h3 id="26-synchronized-用过吗？怎么使用？"><a href="#26-synchronized-用过吗？怎么使用？" class="headerlink" title="26.synchronized 用过吗？怎么使用？"></a>26.synchronized 用过吗？怎么使用？</h3><p>在 Java 中，synchronized 是最常用的锁，它使用简单，并且可以保证线程安全，避免多线程并发访问时出现数据不一致的情况。<br>随着 JDK 版本的进化，synchronized 的性能也得到了进一步的提升，不再像以前样重量级了。<br>synchronized 可以用在方法和代码块中。<br>①、修饰方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当在方法声明中使用了 synchronized 关键字，就表示该方法是同步的，也就是说，线程在执行这个方法的时候，其他线程不能同时执行，需要等待锁释放。<br>如果是静态方法的话，锁的是这个类的 Class 对象，因为静态方法是属于类级别的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">    count++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>②、修饰代码块</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同步代码块可以减少需要同步的代码量，颗粒度更低，更灵活。synchronized 后面的括号中指定了要锁定的对象，可以是 this，也可以是其他对象。<br><a name="raVrI"></a></p>
<h3 id="27-synchronized-的实现原理？"><a href="#27-synchronized-的实现原理？" class="headerlink" title="27.synchronized 的实现原理？"></a>27.synchronized 的实现原理？</h3><p><a name="yEPd2"></a></p>
<h4 id="synchronized-是怎么加锁的呢？"><a href="#synchronized-是怎么加锁的呢？" class="headerlink" title="synchronized 是怎么加锁的呢？"></a>synchronized 是怎么加锁的呢？</h4><p>synchronized 是 JVM 帮我们实现的，因此在使用的时候不用手动去 lock 和 unlock，JVM 会帮我们自动加锁和解锁。<br>①、synchronized 修饰代码块时，JVM 会通过 <code>monitorenter</code>、<code>monitorexit</code> 两个指令来实现同步：</p>
<ul>
<li><code>monitorenter</code> 指向同步代码块的开始位置</li>
<li><code>monitorexit</code> 指向同步代码块的结束位置。</li>
</ul>
<p>使用 <code>javap -c -s -v -l SynchronizedDemo.class</code> 反编译一段 synchronized 代码块时，可以看到 monitorenter 和 monitorexit 指令。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-30.png"><br>②、synchronized 修饰方法时，JVM 会通过 <code>ACC_SYNCHRONIZED</code> 标记符来实现同步。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-31.png"><br><a name="zd0u4"></a></p>
<h4 id="synchronized-锁住的是什么呢？"><a href="#synchronized-锁住的是什么呢？" class="headerlink" title="synchronized 锁住的是什么呢？"></a>synchronized 锁住的是什么呢？</h4><p>monitorenter、monitorexit 或者 ACC_SYNCHRONIZED 都是<strong>基于 Monitor 实现</strong>的。<br>实例对象结构里有对象头，对象头里面有一块结构叫 Mark Word，Mark Word 指针指向了<strong>monitor</strong>。<br>所谓的 Monitor 其实是一种<strong>同步工具</strong>，也可以说是一种<strong>同步机制</strong>。在 Java 虚拟机（HotSpot）中，Monitor 是由<strong>ObjectMonitor 实现</strong>的，可以叫做内部锁，或者 Monitor 锁。<br>ObjectMonitor 的工作原理：</p>
<ul>
<li><p>ObjectMonitor 有两个队列：_WaitSet、_EntryList，用来保存 ObjectWaiter 对象列表。</p>
</li>
<li><p>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() {</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录线程获取锁的次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//锁的重入次数</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  <span class="comment">// 指向持有ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = NULL;  <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;  <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p>所以我们就知道了，同步是锁住的什么东西：</p>
</li>
<li><p>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</p>
</li>
<li><p>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。<br><a name="ca0Dz"></a></p>
</li>
</ul>
<h4 id="会不会牵扯到-os-层面呢？"><a href="#会不会牵扯到-os-层面呢？" class="headerlink" title="会不会牵扯到 os 层面呢？"></a>会不会牵扯到 os 层面呢？</h4><p>会，synchronized 升级为重量级锁时，依赖于操作系统的互斥量（mutex）来实现，mutex 用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段。<br><a name="Btdtg"></a></p>
<h3 id="28-除了原子性，synchronized-可见性，有序性，可重入性怎么实现？"><a href="#28-除了原子性，synchronized-可见性，有序性，可重入性怎么实现？" class="headerlink" title="28.除了原子性，synchronized 可见性，有序性，可重入性怎么实现？"></a>28.除了原子性，synchronized 可见性，有序性，可重入性怎么实现？</h3><p><a name="FDYvU"></a></p>
<h4 id="synchronized-怎么保证可见性？"><a href="#synchronized-怎么保证可见性？" class="headerlink" title="synchronized 怎么保证可见性？"></a>synchronized 怎么保证可见性？</h4><ul>
<li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li>
<li>线程加锁后，其它线程无法获取主内存中的共享变量。</li>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中。<br><a name="YMmYX"></a></li>
</ul>
<h4 id="synchronized-怎么保证有序性？"><a href="#synchronized-怎么保证有序性？" class="headerlink" title="synchronized 怎么保证有序性？"></a>synchronized 怎么保证有序性？</h4><p>synchronized 同步的代码块，具有排他性，一次只能被一个线程拥有，所以 synchronized 保证同一时刻，代码是单线程执行的。<br>因为 as-if-serial 语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。<br>所以 synchronized 保证的有序是执行结果的有序性，而不是防止指令重排的有序性。<br><a name="UepPI"></a></p>
<h4 id="synchronized-怎么实现可重入的呢？"><a href="#synchronized-怎么实现可重入的呢？" class="headerlink" title="synchronized 怎么实现可重入的呢？"></a>synchronized 怎么实现可重入的呢？</h4><p>可重入意味着同一个线程可以多次获得同一个锁，而不会被阻塞。具体来说，如果一个线程已经持有某个锁，那么它可以再次进入该锁保护的代码块或方法，而不会被阻塞。<br>synchronized 之所以支持可重入，是因为 Java 的对象头包含了一个 Mark Word，用于存储对象的状态，包括锁信息。<br>当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。<br>如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。如果 ID 匹配，表示的是同一个线程，锁计数器递增。<br>当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。<br><a name="lopyl"></a></p>
<h3 id="29-锁升级？synchronized-优化了解吗？"><a href="#29-锁升级？synchronized-优化了解吗？" class="headerlink" title="29.锁升级？synchronized 优化了解吗？"></a>29.锁升级？synchronized 优化了解吗？</h3><p>推荐阅读：<a href="https://javabetter.cn/thread/synchronized.html">偏向锁、轻量级锁、重量级锁到底是什么？</a><br><a name="m5LOP"></a></p>
<h4 id="什么是锁升级？"><a href="#什么是锁升级？" class="headerlink" title="什么是锁升级？"></a>什么是锁升级？</h4><p>锁升级是 Java 虚拟机中的一个优化机制，用于提高多线程环境下 synchronized 的并发性能。锁升级涉及从较轻的锁状态（如无锁或偏向锁）逐步升级到较重的锁状态（如轻量级锁和重量级锁），以适应不同程度的竞争情况。<br>Java 对象头里的 <code>Mark Word</code> 会记录锁的状态，一共有四种状态：<br>①、无锁状态，在这个状态下，没有线程试图获取锁。<br>②、偏向锁，当第一个线程访问同步块时，锁会进入偏向模式。Mark Word 会被设置为偏向模式，并且存储了获取它的线程 ID。<br>偏向锁的目的是消除同一线程的后续锁获取和释放的开销。如果同一线程再次请求锁，就无需再次同步。<br>③、当有多个线程竞争锁，但没有锁竞争的强烈迹象（即线程交替执行同步块）时，偏向锁会升级为轻量级锁。<br>线程尝试通过<a href="https://javabetter.cn/thread/cas.html">CAS 操作</a>（Compare-And-Swap）将对象头的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获取轻量级锁；如果失败，说明有竞争。<br>④、重量级锁，当锁竞争激烈时，轻量级锁会膨胀为重量级锁。<br>重量级锁通过将对象头的 Mark Word 指向监视器（Monitor）对象来实现，该对象包含了锁的持有者、锁的等待队列等信息。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-34.png"><br><a name="J0dgX"></a></p>
<h4 id="synchronized-做了哪些优化？"><a href="#synchronized-做了哪些优化？" class="headerlink" title="synchronized 做了哪些优化？"></a>synchronized 做了哪些优化？</h4><p>在 JDK1.6 之前，synchronized 是直接调用 ObjectMonitor 的 enter 和 exit 实现的，这种锁也被称为<strong>重量级锁</strong>。这也是为什么很多声音说不要用 synchronized 的原因，有点“谈虎色变”的感觉。<br>从 JDK 1.6 开始，HotSpot 对 Java 中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，极大提升了 synchronized 的性能。<br><strong>①、偏向锁</strong>：当一个线程首次获得锁时，JVM 会将锁标记为偏向这个线程，将锁的标志位设置为偏向模式，并且在对象头中记录下该线程的 ID。<br>之后，当相同的线程再次请求这个锁时，就无需进行额外的同步。如果另一个线程尝试获取这个锁，偏向模式会被撤销，并且锁会升级为轻量级锁。<br><strong>②、轻量级锁</strong>：多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。<br>当一个线程尝试获取轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record），然后尝试使用 CAS 操作将对象头的 Mark Word 替换为指向锁记录的指针。<br>如果成功，该线程持有锁；如果失败，表示有其他线程竞争，锁会升级为重量级锁。<br><strong>③、自旋锁</strong>：当线程尝试获取轻量级锁失败时，它会进行自旋，即循环检查锁是否可用，以避免立即进入阻塞状态。<br>自旋的次数不是固定的，而是根据之前在同一个锁上的自旋时间和锁的状态动态调整的。<br><strong>④、锁粗化</strong>：如果 JVM 检测到一系列连续的锁操作实际上是在单一线程中完成的，则会将多个锁操作合并为一个更大范围的锁操作，这可以减少锁请求的次数。<br>锁粗化主要针对循环内连续加锁解锁的情况进行优化。<br><strong>⑤、锁消除</strong>：JVM 的即时编译器（<a href="https://javabetter.cn/jvm/jit.html">JIT</a>）可以在运行时进行代码分析，如果发现某些锁操作不可能被多个线程同时访问，那么这些锁操作就会被完全消除。锁消除可以减少不必要的同步开销。<br><a name="QDTKM"></a></p>
<h4 id="锁升级的过程是什么样的？"><a href="#锁升级的过程是什么样的？" class="headerlink" title="锁升级的过程是什么样的？"></a>锁升级的过程是什么样的？</h4><p>无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-35.png"><br>大体上省简的升级过程是这样的：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-36.png"><br>完整的升级过程是这样的：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-37.png"><br><strong>①、从无锁到偏向锁：</strong><br>当一个线程首次访问同步块时，如果此对象无锁状态且偏向锁未被禁用，JVM 会将该对象头的锁标记改为偏向锁状态，并记录下当前线程的 ID。此时，对象头中的 Mark Word 中存储了持有偏向锁的线程 ID。<br>如果另一个线程尝试获取这个已被偏向的锁，JVM 会检查当前持有偏向锁的线程是否活跃。如果持有偏向锁的线程不活跃，则可以将锁重偏向至新的线程；如果持有偏向锁的线程还活跃，则需要撤销偏向锁，升级为轻量级锁。<br><strong>②、偏向锁的轻量级锁：</strong><br>进行偏向锁撤销时，会遍历堆栈的所有锁记录，暂停拥有偏向锁的线程，并检查锁对象。如果这个过程中发现有其他线程试图获取这个锁，JVM 会撤销偏向锁，并将锁升级为轻量级锁。<br>当有两个或以上线程竞争同一个偏向锁时，偏向锁模式不再有效，此时偏向锁会被撤销，对象的锁状态会升级为轻量级锁。<br><strong>③、轻量级锁到重量级锁：</strong><br>轻量级锁通过线程自旋来等待锁释放。如果自旋超过预定次数（自旋次数是可调的，并且自适应的），表明锁竞争激烈，轻量级锁的自旋已经不再高效。<br>当自旋等待失败，或者有线程在等待队列中等待相同的轻量级锁时，轻量级锁会升级为重量级锁。在这种情况下，JVM 会在操作系统层面创建一个互斥锁（Mutex），所有进一步尝试获取该锁的线程将会被阻塞，直到锁被释放。<br><a name="Jf4rR"></a></p>
<h3 id="30-说说-synchronized-和-ReentrantLock-的区别？"><a href="#30-说说-synchronized-和-ReentrantLock-的区别？" class="headerlink" title="30.说说 synchronized 和 ReentrantLock 的区别？"></a>30.说说 synchronized 和 ReentrantLock 的区别？</h3><p><a href="https://javabetter.cn/thread/synchronized-1.html">synchronized</a> 是一个关键字，而 Lock 属于一个接口，其实现类主要有 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a>、<a href="https://javabetter.cn/thread/ReentrantReadWriteLock.html">ReentrantReadWriteLock</a>。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-38.png"><br><a name="ade9b"></a></p>
<h4 id="使用方式有什么不同？"><a href="#使用方式有什么不同？" class="headerlink" title="使用方式有什么不同？"></a>使用方式有什么不同？</h4><p>synchronized 可以直接在方法上加锁，也可以在代码块上加锁（无需手动释放锁，锁会自动释放），而 ReentrantLock 必须手动声明来加锁和释放锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 修饰方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized 修饰代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock 加锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>随着 JDK 版本的升级，synchronized 的性能已经可以媲美 ReentrantLock 了，加入了偏向锁、轻量级锁和重量级锁的自适应优化等，所以可以大胆地用。<br><a name="YlZgd"></a></p>
<h4 id="功能特点有什么不同？"><a href="#功能特点有什么不同？" class="headerlink" title="功能特点有什么不同？"></a>功能特点有什么不同？</h4><p>如果需要更细粒度的控制（如可中断的锁操作、尝试非阻塞获取锁、超时获取锁或者使用公平锁等），可以使用 Lock。</p>
<ul>
<li>ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code>来实现这个机制。</li>
<li>ReentrantLock 可以指定是公平锁还是非公平锁。</li>
<li>ReentrantReadWriteLock 读写锁，读锁是共享锁，写锁是独占锁，读锁可以同时被多个线程持有，写锁只能被一个线程持有。这种锁的设计可以提高性能，特别是在读操作的数量远远超过写操作的情况下。</li>
</ul>
<p>Lock 还提供了<code>newCondition()</code>方法来创建等待通知条件<a href="https://javabetter.cn/thread/condition.html">Condition</a>，比 synchronized 与 <code>wait()</code>、 <code>notify()/notifyAll()</code>方法的组合更强大。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></tbody></table></figure>
<p><a name="yDrU3"></a></p>
<h4 id="并发量大的情况下，使用-synchronized-还是-ReentrantLock？"><a href="#并发量大的情况下，使用-synchronized-还是-ReentrantLock？" class="headerlink" title="并发量大的情况下，使用 synchronized 还是 ReentrantLock？"></a>并发量大的情况下，使用 synchronized 还是 ReentrantLock？</h4><p>在并发量特别高的情况下，ReentrantLock 的性能可能会优于 synchronized，原因包括：</p>
<ul>
<li>ReentrantLock 提供了超时和公平锁等特性，可以更好地应对复杂的并发场景 。</li>
<li>ReentrantLock 允许更细粒度的锁控制，可以有效减少锁竞争。</li>
<li>ReentrantLock 支持条件变量 Condition，可以实现比 synchronized 更复杂的线程间通信机制。<br><a name="KV0pZ"></a></li>
</ul>
<h3 id="31-AQS-了解多少？"><a href="#31-AQS-了解多少？" class="headerlink" title="31.AQS 了解多少？"></a>31.AQS 了解多少？</h3><p>AQS，全称是 AbstractQueuedSynchronizer，中文意思是抽象队列同步器，由 Doug Lea 设计，是 Java 并发包<code>java.util.concurrent</code>的核心框架类，许多同步类的实现都依赖于它，如 ReentrantLock、Semaphore、CountDownLatch 等。<br>AQS 的思想是，如果被请求的共享资源空闲，则当前线程能够成功获取资源；否则，它将进入一个等待队列，当有其他线程释放资源时，系统会挑选等待队列中的一个线程，赋予其资源。<br>整个过程通过维护一个 int 类型的状态和一个先进先出（FIFO）的队列，来实现对共享资源的管理。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-39.png"><br>①、同步状态 state 由 volatile 修饰，保证了多线程之间的可见性；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></tbody></table></figure>
<p>②、同步队列是通过内部定义的 Node 类来实现的，每个 Node 包含了等待状态、前后节点、线程的引用等。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AQS 支持两种同步方式：</p>
<ul>
<li>独占模式：这种方式下，每次只能有一个线程持有锁，例如 ReentrantLock。</li>
<li>共享模式：这种方式下，多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。</li>
</ul>
<p>子类可以通过继承 AQS 并实现它的方法来管理同步状态，这些方法包括：</p>
<ul>
<li><code>tryAcquire</code>：独占方式尝试获取资源，成功则返回 true，失败则返回 false；</li>
<li><code>tryRelease</code>：独占方式尝试释放资源；</li>
<li><code>tryAcquireShared(int arg)</code>：共享方式尝试获取资源；</li>
<li><code>tryReleaseShared(int arg)</code>：共享方式尝试释放资源；</li>
<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。</li>
</ul>
<p>如果共享资源被占用，需要一种特定的阻塞等待唤醒机制来保证锁的分配，AQS 会将竞争共享资源失败的线程添加到一个 CLH 队列中。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-40.png"><br>在 CLH 锁中，当一个线程尝试获取锁并失败时，它会将自己添加到队列的尾部并自旋，等待前一个节点的线程释放锁。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-41.png"><br><a name="PHRJv"></a></p>
<h3 id="32-ReentrantLock-实现原理？"><a href="#32-ReentrantLock-实现原理？" class="headerlink" title="32.ReentrantLock 实现原理？"></a>32.ReentrantLock 实现原理？</h3><p><a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a> 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞。<br>可重入表示当前线程获取该锁后再次获取不会被阻塞，也就意味着同一个线程可以多次获得同一个锁而不会发生死锁。<br>ReentrantLock 的加锁和解锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建非公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 获取锁操作</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 执行代码逻辑</span></span><br><span class="line">} <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="comment">// 解锁操作</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>new ReentrantLock() </code>默认创建的是非公平锁 NonfairSync。在非公平锁模式下，锁可能会授予刚刚请求它的线程，而不考虑等待时间。<br>ReentrantLock 也支持公平锁，该模式下，锁会授予等待时间最长的线程。<br>ReentrantLock 内部通过一个计数器来跟踪锁的持有次数。<br>当线程调用<code>lock()</code>方法获取锁时，ReentrantLock 会检查当前状态，判断锁是否已经被其他线程持有。如果没有被持有，则当前线程将获得锁；如果锁已被其他线程持有，则当前线程将根据锁的公平性策略，可能会被加入到等待队列中。<br>线程首次获取锁时，计数器值变为 1；如果同一线程再次获取锁，计数器增加；每释放一次锁，计数器减 1。<br>当线程调用<code>unlock()</code>方法时，ReentrantLock 会将持有锁的计数减 1，如果计数到达 0，则释放锁，并唤醒等待队列中的线程来竞争锁。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-42.png"><br><a name="ZLHSR"></a></p>
<h3 id="33-ReentrantLock-怎么实现公平锁的？"><a href="#33-ReentrantLock-怎么实现公平锁的？" class="headerlink" title="33.ReentrantLock 怎么实现公平锁的？"></a>33.ReentrantLock 怎么实现公平锁的？</h3><p>ReentrantLock 的默认构造方法创建的是非公平锁 NonfairSync。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> {</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以通过有参构造方法传递 true 参数来创建公平锁 FairSync。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">--- ReentrantLock</span><br><span class="line"><span class="comment">// true 代表公平锁，false 代表非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> {</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>FairSync、NonfairSync 都是 ReentrantLock 的内部类，分别实现了公平锁和非公平锁的逻辑。<br><a name="EG6E8"></a></p>
<h4 id="非公平锁和公平锁有什么不同？"><a href="#非公平锁和公平锁有什么不同？" class="headerlink" title="非公平锁和公平锁有什么不同？"></a>非公平锁和公平锁有什么不同？</h4><p>①、公平锁意味着在多个线程竞争锁时，获取锁的顺序与线程请求锁的顺序相同，即先来先服务（FIFO）。<br>虽然能保证锁的顺序，但实现起来比较复杂，因为需要额外维护一个有序队列。<br>②、非公平锁不保证线程获取锁的顺序，当锁被释放时，任何请求锁的线程都有机会获取锁，而不是按照请求的顺序。<br><a name="fToDV"></a></p>
<h4 id="怎么实现一个非公平锁呢？"><a href="#怎么实现一个非公平锁呢？" class="headerlink" title="怎么实现一个非公平锁呢？"></a>怎么实现一个非公平锁呢？</h4><p>要实现一个非公平锁，只需要在创建 ReentrantLock 实例时，不传递任何参数或者传递 false 给它的构造方法就好了。<br><a name="dpEsX"></a></p>
<h3 id="34-CAS-了解多少？"><a href="#34-CAS-了解多少？" class="headerlink" title="34.CAS 了解多少？"></a>34.CAS 了解多少？</h3><p>CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为“比较并交换”，是一种无锁的原子操作。<br>在 Java 中，我们可以使用 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized</a>关键字和 <code>CAS</code> 来实现加锁效果。<br>synchronized 是悲观锁，尽管随着 JDK 版本的升级，synchronized 关键字已经“轻量级”了很多，但依然是悲观锁，线程开始执行第一步就要获取锁，一旦获得锁，其他的线程进入后就会阻塞并等待锁。<br>CAS 是乐观锁，线程执行的时候不会加锁，它会假设此时没有冲突，然后完成某项操作；如果因为冲突失败了就重试，直到成功为止。<br>在 CAS 中，有这样三个值：</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)</li>
<li>N：新值(new)</li>
</ul>
<p>比较并交换的过程如下：<br>判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。<br>这里的预期值 E 本质上指的是“旧值”。<br>这个比较和替换的操作是原子的，即不可中断，确保了数据的一致性。<br>举个例子，变量当前的值为 0，需要将其更新为 1，可以借助 AtomicInteger 类的 compareAndSet 方法来实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">expect</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">atomicInteger.compareAndSet(expect, update);</span><br></pre></td></tr></tbody></table></figure>
<p>compareAndSet 就是一个 CAS 方法，它调用的是 Unsafe 的 compareAndSwapInt。<br>Unsafe 对 CAS 的实现是通过 C++ 实现的，它的具体实现和操作系统、CPU 都有关系。<br>Linux 的 X86 下主要是通过 cmpxchgl 这个指令在 CPU 上完成 CAS 操作的，但在多处理器情况下，必须使用 lock 指令加锁来完成。当然，不同的操作系统和处理器在实现方式上肯定会有所不同。<br><a name="nxbBe"></a></p>
<h3 id="35-CAS-有什么问题？如何解决？"><a href="#35-CAS-有什么问题？如何解决？" class="headerlink" title="35.CAS 有什么问题？如何解决？"></a>35.CAS 有什么问题？如何解决？</h3><p>CAS 存在三个经典问题。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-44.png"><br><a name="ESPBt"></a></p>
<h4 id="什么是-ABA-问题？如何解决？"><a href="#什么是-ABA-问题？如何解决？" class="headerlink" title="什么是 ABA 问题？如何解决？"></a>什么是 ABA 问题？如何解决？</h4><p>如果一个位置的值原来是 A，后来被改为 B，再后来又被改回 A，那么进行 CAS 操作的线程将无法知晓该位置的值在此期间已经被修改过。<br>可以使用版本号/时间戳的方式来解决 ABA 问题。<br>比如说，每次变量更新时，不仅更新变量的值，还更新一个版本号。CAS 操作时不仅要求值匹配，还要求版本号匹配。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticLockExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">updateValue</span><span class="params">(<span class="type">int</span> newValue, <span class="type">int</span> currentVersion)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.version == currentVersion) {</span><br><span class="line">            <span class="built_in">this</span>.value = newValue;</span><br><span class="line">            <span class="built_in">this</span>.version++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Java 的 AtomicStampedReference 类就实现了这种机制，它会同时检查引用值和 stamp 是否都相等。<br><a name="ivaiE"></a></p>
<h4 id="循环性能开销"><a href="#循环性能开销" class="headerlink" title="循环性能开销"></a>循环性能开销</h4><p>自旋 CAS，如果一直循环执行，一直不成功，会给 CPU 带来非常大的执行开销。<br>在 Java 中，很多使用自旋 CAS 的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。<br><a name="AaqZm"></a></p>
<h4 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a>只能保证一个变量的原子操作</h4><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p>
<ul>
<li>可以考虑改用锁来保证操作的原子性</li>
<li>可以考虑合并多个变量，将多个变量封装成一个对象，通过 AtomicReference 来保证原子性。<br><a name="v09Cs"></a></li>
</ul>
<h3 id="36-Java-有哪些保证原子性的方法？如何保证多线程下-i-结果正确？"><a href="#36-Java-有哪些保证原子性的方法？如何保证多线程下-i-结果正确？" class="headerlink" title="36.Java 有哪些保证原子性的方法？如何保证多线程下 i++ 结果正确？"></a>36.Java 有哪些保证原子性的方法？如何保证多线程下 i++ 结果正确？</h3><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-45.png"></p>
<ul>
<li>使用循环原子类，例如 AtomicInteger，实现 i++原子操作</li>
<li>使用 juc 包下的锁，如 ReentrantLock ，对 i++操作加锁 lock.lock()来实现原子性</li>
<li>使用 synchronized，对 i++操作加锁<br><a name="kN7OP"></a></li>
</ul>
<h3 id="37-原子操作类了解多少？"><a href="#37-原子操作类了解多少？" class="headerlink" title="37.原子操作类了解多少？"></a>37.原子操作类了解多少？</h3><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量 i=1，A 线程更新 i+1，B 线程也更新 i+1，经过两个线程操作之后可能 i 不等于 3，而是等于 2。因为 A 和 B 线程在更新变量 i 的时候拿到的 i 都是 1，这就是线程不安全的更新操作，一般我们会使用 synchronized 来解决这个问题，synchronized 会保证多线程不会同时更新变量 i。<br>其实除此之外，还有更轻量级的选择，Java 从 JDK 1.5 开始提供了 java.util.concurrent.atomic 包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<br>因为变量的类型有很多种，所以在 Atomic 包里一共提供了 13 个类，属于 4 种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-46.png"><br>Atomic 包里的类基本都是使用 Unsafe 实现的包装类。<br>使用原子的方式更新基本类型，Atomic 包提供了以下 3 个类：</p>
<ul>
<li>AtomicBoolean：原子更新布尔类型。</li>
<li>AtomicInteger：原子更新整型。</li>
<li>AtomicLong：原子更新长整型。</li>
</ul>
<p>通过原子的方式更新数组里的某个元素，Atomic 包提供了以下 4 个类：</p>
<ul>
<li>AtomicIntegerArray：原子更新整型数组里的元素。</li>
<li>AtomicLongArray：原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li>
<li>AtomicIntegerArray 类主要是提供原子的方式更新数组里的整型</li>
</ul>
<p>原子更新基本类型的 AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic 包提供了以下 3 个类：</p>
<ul>
<li>AtomicReference：原子更新引用类型。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是 AtomicMarkableReference（V initialRef，boolean initialMark）。</li>
</ul>
<p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic 包提供了以下 3 个类进行原子字段更新：</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br><a name="hkgi0"></a></li>
</ul>
<h3 id="38-AtomicInteger-的原理？"><a href="#38-AtomicInteger-的原理？" class="headerlink" title="38.AtomicInteger 的原理？"></a>38.AtomicInteger 的原理？</h3><p>一句话概括：<strong>使用 CAS 实现</strong>。<br>以 AtomicInteger 的添加方法为例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过<code>Unsafe</code>类的实例来进行添加操作，来看看具体的 CAS 操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> {</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    } <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>compareAndSwapInt 是一个 native 方法，基于 CAS 来操作 int 类型变量。其它的原子操作类基本都是大同小异。<br><a name="cT2E6"></a></p>
<h3 id="39-线程死锁了解吗？该如何避免？"><a href="#39-线程死锁了解吗？该如何避免？" class="headerlink" title="39.线程死锁了解吗？该如何避免？"></a>39.线程死锁了解吗？该如何避免？</h3><p>死锁发生在多个线程相互等待对方释放锁资源，导致所有线程都无法继续执行。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-47.png"><br><a name="aA6oQ"></a></p>
<h4 id="那么为什么会产生死锁呢？"><a href="#那么为什么会产生死锁呢？" class="headerlink" title="那么为什么会产生死锁呢？"></a>那么为什么会产生死锁呢？</h4><p>讲个笑话，死锁的产生也不是你想产生就产生的，它是有条件的：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-48.png"></p>
<ul>
<li><strong>互斥条件</strong>：资源不能被多个线程共享，一次只能由一个线程使用。如果一个线程已经占用了一个资源，其他请求该资源的线程必须等待，直到资源被释放。</li>
<li><strong>持有并等待条件</strong>：一个线程至少已经持有至少一个资源，且正在等待获取额外的资源，这些额外的资源被其他线程占有。</li>
<li><strong>不可剥夺条件</strong>：资源不能被强制从一个线程中抢占过来，只能由持有资源的线程主动释放。</li>
<li><strong>循环等待条件</strong>：存在一种线程资源的循环链，每个线程至少持有一个其他线程所需要的资源，然后又等待下一个线程所占有的资源。这形成了一个循环等待的环路。<br><a name="zvGHG"></a></li>
</ul>
<h4 id="该如何避免死锁呢？"><a href="#该如何避免死锁呢？" class="headerlink" title="该如何避免死锁呢？"></a>该如何避免死锁呢？</h4><p>理解产生死锁的这四个必要条件后，就可以采取相应的措施来避免死锁，换句话说，就是<strong>至少破坏死锁发生的一个条件</strong>。</p>
<ul>
<li><strong>破坏互斥条件</strong>：这通常不可行，因为加锁就是为了互斥。</li>
<li><strong>破坏持有并等待条件</strong>：一种方法是要求线程在开始执行前一次性地申请所有需要的资源。</li>
<li><strong>破坏非抢占条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：对所有资源类型进行排序，强制每个线程按顺序申请资源，这样可以避免循环等待的发生。<br><a name="chJ0U"></a></li>
</ul>
<h3 id="40-那死锁问题怎么排查呢？"><a href="#40-那死锁问题怎么排查呢？" class="headerlink" title="40.那死锁问题怎么排查呢？"></a>40.那死锁问题怎么排查呢？</h3><p>首先从系统级别上排查，比如说在 Linux 生产环境中，可以先使用 top ps 等命令查看进程状态，看看是否有进程占用了过多的资源。<br>接着，使用 JDK 自带的一些性能监控工具进行排查，比如说 jps、jstat、jinfo、jmap、jstack、jcmd 等等。<br>比如说，使用 <code>jps -l</code> 查看当前 Java 进程，然后使用 <code>jstack 进程号</code> 查看当前 Java 进程的线程堆栈信息，看看是否有线程在等待锁资源。<br>来编写一个死锁程序：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) {</span><br><span class="line">                System.out.println(<span class="string">"线程1获取到了锁1"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) {</span><br><span class="line">                    System.out.println(<span class="string">"线程1获取到了锁2"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) {</span><br><span class="line">                System.out.println(<span class="string">"线程2获取到了锁2"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) {</span><br><span class="line">                    System.out.println(<span class="string">"线程2获取到了锁1"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>创建了两个线程，每个线程都试图按照不同的顺序获取两个<a href="https://javabetter.cn/thread/thread-bring-some-problem.html#%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98">锁（lock1 和 lock2）</a>。这种锁的获取顺序不一致很容易导致死锁。<br>运行这段代码，果然卡住了。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/console-tools-20240106192010.png"><br>运行 <code>jstack pid</code> 命令，可以看到死锁的线程信息。诚不欺我！<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/console-tools-20240106192123.png"><br>也可以使用一些可视化的性能监控工具，比如说 JConsole、VisualVM 等。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-49.png"><br><a name="tyGAM"></a></p>
<h3 id="41-聊聊如何进行线程同步？（补充）"><a href="#41-聊聊如何进行线程同步？（补充）" class="headerlink" title="41.聊聊如何进行线程同步？（补充）"></a>41.聊聊如何进行线程同步？（补充）</h3><p>所谓同步，即协同步调，按预定的先后次序访问共享资源，以免造成混乱。<br>线程同步是多线程编程中的一个核心概念，它涉及到在多线程环境下如何安全地访问和修改共享资源的问题。<br>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作。<br>如果多个线程同时读写某个共享资源（如变量、文件等），而没有适当的同步机制，就可能导致数据不一致、数据损坏等问题的出现。<br>线程同步的实现方式有 6 种：互斥量、读写锁、条件变量、自旋锁、屏障、信号量。</p>
<ul>
<li><strong>互斥量</strong>：互斥量（mutex）是一种最基本的同步手段，本质上是一把锁，在访问共享资源前先对互斥量进行加锁，访问完后再解锁。对互斥量加锁后，任何其他试图再次对互斥量加锁的线程都会被阻塞，直到当前线程解锁。</li>
<li><strong>读写锁</strong>：<a href="https://javabetter.cn/thread/ReentrantReadWriteLock.html">读写锁</a>有三种状态，读模式加锁、写模式加锁和不加锁；一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。非常适合读多写少的场景。</li>
<li><strong>条件变量</strong>：<a href="https://javabetter.cn/thread/condition.html">条件变量</a>是一种同步手段，它允许线程在满足特定条件时才继续执行，否则进入等待状态。条件变量通常与互斥量一起使用，以防止竞争条件的发生。</li>
<li><strong>自旋锁</strong>：自旋锁是一种锁的实现方式，它不会让线程进入睡眠状态，而是一直循环检测锁是否被释放。自旋锁适用于锁的持有时间非常短的情况。</li>
<li>信号量：信号量（<a href="https://javabetter.cn/thread/CountDownLatch.html">Semaphore</a>）本质上是一个计数器，用于为多个进程提供共享数据对象的访问。</li>
</ul>
<p>在 Java 中，<a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>和 Lock 接口是用来实现线程同步的常用方式，我就以它俩来举例说明。<br><a name="J88oE"></a></p>
<h4 id="简单说说-synchronized-关键字"><a href="#简单说说-synchronized-关键字" class="headerlink" title="简单说说 synchronized 关键字"></a>简单说说 synchronized 关键字</h4><p>当一个线程访问某对象的 synchronized 方法或代码块时，其他线程对该对象的所有 synchronized 方法或代码块的访问将被阻塞，直到第一个线程完成操作。<br>synchronized 关键字就属于典型的互斥量，它保证了同一时间只有一个线程可以访问共享资源。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用synchronized方法保证线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，increment 方法和 getCount 方法都被标记为 synchronized。这意味着同一时间内只有一个线程可以执行这两个方法中的任意一个。<br>在 JVM 的早期版本中，synchronized 是重量级的，因为线程阻塞和唤醒需要操作系统的介入。但在 JVM 的后续版本中，对 synchronized 进行了大量优化，如偏向锁、轻量级锁和适应性自旋等，所以现在的 synchronized 并不一定是重量级的，其性能在许多情况下都很好，可以大胆地用。<br><a name="rdslP"></a></p>
<h4 id="简单说说-Lock-接口？"><a href="#简单说说-Lock-接口？" class="headerlink" title="简单说说 Lock 接口？"></a>简单说说 Lock 接口？</h4><p>Lock 接口提供了比 synchronized 关键字更灵活的锁操作。比如说我们可以用重入锁 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a> 来实现同样的功能。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterWithLock</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            count++;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>increment 方法先上锁，然后尝试增加 count 的值，在完成操作后释放锁。这样就可以保证 count 的操作是线程安全的。<br>ReentrantLock 和 synchronized 都可以用来实现同步，但它们之间也存在一些区别：</p>
<ul>
<li><strong>ReentrantLock 是一个类，而 synchronized 是 Java 中的关键字</strong>；</li>
<li>**ReentrantLock 可以实现多路选择通知（可以绑定多个 **<a href="https://javabetter.cn/thread/condition.html">Condition</a><strong>），而 synchronized 只能通过 wait 和 notify/notifyAll 方法唤醒一个线程或者唤醒全部线程（单路通知）</strong>；</li>
<li>ReentrantLock 必须手动释放锁。通常需要在 finally 块中调用 unlock 方法以确保锁被正确释放。</li>
<li>synchronized 会自动释放锁，当同步块执行完毕时，由 JVM 自动释放，不需要手动操作。</li>
<li>ReentrantLock: 通常提供更好的性能，特别是在高竞争环境下。</li>
<li>synchronized: 在某些情况下，性能可能稍差一些，但随着 JDK 版本的升级，性能差距已经不大了。<br><a name="nUCM6"></a></li>
</ul>
<h3 id="42-聊聊悲观锁和乐观锁？（补充）"><a href="#42-聊聊悲观锁和乐观锁？（补充）" class="headerlink" title="42.聊聊悲观锁和乐观锁？（补充）"></a>42.聊聊悲观锁和乐观锁？（补充）</h3><p>对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。<br>悲观锁的代表有 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>和 <a href="https://javabetter.cn/thread/reentrantLock.html">Lock 接口</a>。<br>乐观锁，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 <a href="https://javabetter.cn/thread/cas.html">CAS</a> 的技术来保证线程执行的安全性。<br>由于乐观锁假想操作中没有锁的存在，因此不太可能出现死锁的情况，换句话说，乐观锁天生免疫死锁。</p>
<ul>
<li>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；</li>
<li>悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。<br><a name="IY53t"></a></li>
</ul>
<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p><a name="zYluk"></a></p>
<h3 id="43-CountDownLatch（倒计数器）了解吗？"><a href="#43-CountDownLatch（倒计数器）了解吗？" class="headerlink" title="43.CountDownLatch（倒计数器）了解吗？"></a>43.CountDownLatch（倒计数器）了解吗？</h3><p>推荐阅读：<a href="https://javabetter.cn/thread/CountDownLatch.html">Java 并发编程通信工具类 Semaphore、Exchanger、CountDownLatch、CyclicBarrier、Phaser 等一网打尽</a><br>CountDownLatch 是 JUC 包中的一个同步工具类，用于协调多个线程之间的同步。它允许一个或多个线程等待，直到其他线程中执行的一组操作完成。它通过一个计数器来实现，该计数器由线程递减，直到到达零。</p>
<ul>
<li>初始化：创建 CountDownLatch 对象时，指定计数器的初始值。</li>
<li>等待（await）：一个或多个线程调用 await 方法，进入等待状态，直到计数器的值变为零。</li>
<li>倒计数（countDown）：其他线程在完成各自任务后调用 countDown 方法，将计数器的值减一。当计数器的值减到零时，所有在 await 上等待的线程会被唤醒，继续执行。</li>
</ul>
<p>当等待多个线程完成各自的启动任务后再启动主线程的任务，就可以使用 CountDownLatch。<br>CountDownLatch 的<strong>核心方法</strong>也不多：</p>
<ul>
<li><code>CountDownLatch(int count)</code>：创建一个带有给定计数器的 CountDownLatch。</li>
<li><code>void await()</code>：阻塞当前线程，直到计数器为零。</li>
<li><code>void countDown()</code>：递减计数器的值，如果计数器值变为零，则释放所有等待的线程。<br><a name="Eaenv"></a></li>
</ul>
<h3 id="44-CyclicBarrier（同步屏障）了解吗？"><a href="#44-CyclicBarrier（同步屏障）了解吗？" class="headerlink" title="44.CyclicBarrier（同步屏障）了解吗？"></a>44.CyclicBarrier（同步屏障）了解吗？</h3><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>它和 CountDownLatch 类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有 CyclicBarrier，自然是它有和 CountDownLatch 不同的地方。<br>我们拿代码模拟这一场景，发现 CountDownLatch 无能为力了，因为 CountDownLatch 的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用 CyclicBarrier 就可以实现，因为它可以重复利用。<br>CyclicBarrier 最最核心的方法，仍然是 await()：</p>
<ul>
<li>如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生<strong>被中断</strong>、<strong>屏障被拆除</strong>、<strong>屏障被重设</strong>等情况；</li>
</ul>
<p>上面的例子抽象一下，本质上它的流程就是这样就是这样：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-55.png"><br><a name="GpDQR"></a></p>
<h3 id="45-CyclicBarrier-和-CountDownLatch-有什么区别？"><a href="#45-CyclicBarrier-和-CountDownLatch-有什么区别？" class="headerlink" title="45.CyclicBarrier 和 CountDownLatch 有什么区别？"></a>45.CyclicBarrier 和 CountDownLatch 有什么区别？</h3><p>两者最核心的区别[18]：</p>
<ul>
<li>CountDownLatch 是一次性的，而 CyclicBarrier 则可以多次设置屏障，实现重复利用；</li>
<li>CountDownLatch 中的各个子线程不可以等待其他线程，只能完成自己的任务；而 CyclicBarrier 中的各个线程可以等待其他线程</li>
</ul>
<p>它们区别用一个表格整理：</p>
<table>
<thead>
<tr>
<th>CyclicBarrier</th>
<th>CountDownLatch</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier 是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</td>
<td>CountDownLatch 是一次性的，不同的线程在同一个计数器上工作，直到计数器为 0.</td>
</tr>
<tr>
<td>CyclicBarrier 面向的是线程数</td>
<td>CountDownLatch 面向的是任务数</td>
</tr>
<tr>
<td>在使用 CyclicBarrier 时，你必须在构造中指定参与协作的线程数，这些线程必须调用 await()方法</td>
<td>使用 CountDownLatch 时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要</td>
</tr>
<tr>
<td>CyclicBarrier 可以在所有的线程释放后重新使用</td>
<td>CountDownLatch 在计数器为 0 时不能再使用</td>
</tr>
<tr>
<td>在 CyclicBarrier 中，如果某个线程遇到了中断、超时等问题时，则处于 await 的线程都会出现问题</td>
<td>在 CountDownLatch 中，如果某个线程出现问题，其他线程不受影响</td>
</tr>
</tbody></table>
<p><a name="gyS1n"></a></p>
<h3 id="46-Semaphore（信号量）了解吗？"><a href="#46-Semaphore（信号量）了解吗？" class="headerlink" title="46.Semaphore（信号量）了解吗？"></a>46.Semaphore（信号量）了解吗？</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<br>我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore 的本质就是<strong>协调多个线程对共享资源的获取</strong>。<br>我们再来看一个 Semaphore 的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。<br>在代码中，虽然有 30 个线程在执行，但是只允许 10 个并发执行。Semaphore 的构造方法<code> Semaphore（int permits</code>）接受一个整型的数字，表示可用的许可证数量。<code>Semaphore（10）</code>表示允许 10 个线程获取许可证，也就是最大并发数是 10。Semaphore 的用法也很简单，首先线程使用 Semaphore 的 acquire()方法获取一个许可证，使用完之后调用 release()方法归还许可证。还可以用 tryAcquire()方法尝试获取许可证。<br><a name="D5Sj9"></a></p>
<h3 id="47-Exchanger-了解吗？"><a href="#47-Exchanger-了解吗？" class="headerlink" title="47.Exchanger 了解吗？"></a>47.Exchanger 了解吗？</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger 用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-58.jpeg"><br>这两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange()方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<br>Exchanger 可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出 2 个交配结果。Exchanger 也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用 AB 岗两人进行录入，录入到 Excel 之后，系统需要加载这两个 Excel，并对两个 Excel 数据进行校对，看看是否录入一致。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">"银行流水A"</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">"银行流水B"</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></span><br><span class="line">                            + A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>假如两个线程有一个没有执行 exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeOut, TimeUnit unit) </code>设置最大等待时长。<br><a name="WdZ1E"></a></p>
<h3 id="48-能说一下-ConcurrentHashMap-的实现吗？（补充）"><a href="#48-能说一下-ConcurrentHashMap-的实现吗？（补充）" class="headerlink" title="48.能说一下 ConcurrentHashMap 的实现吗？（补充）"></a>48.能说一下 ConcurrentHashMap 的实现吗？（补充）</h3><p><a href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a> 在 JDK 7 时采用的是分段锁机制（Segment Locking），整个 Map 被分为若干段，每个段都可以独立地加锁。因此，不同的线程可以同时操作不同的段，从而实现并发访问。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/map-20230816155810.png"><br>在 JDK 8 及以上版本中，ConcurrentHashMap 的实现进行了优化，不再使用分段锁，而是使用了一种更加精细化的锁——桶锁，以及 CAS 无锁算法。每个桶（Node 数组的每个元素）都可以独立地加锁，从而实现更高级别的并发访问。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/map-20230816155924.png"><br>同时，对于读操作，通常不需要加锁，可以直接读取，因为 ConcurrentHashMap 内部使用了 volatile 变量来保证内存可见性。<br>对于写操作，ConcurrentHashMap 使用 CAS 操作来实现无锁的更新，这是一种乐观锁的实现，因为它假设没有冲突发生，在实际更新数据时才检查是否有其他线程在尝试修改数据，如果有，采用悲观的锁策略，如 synchronized 代码块来保证数据的一致性。<br><a name="LFA40"></a></p>
<h4 id="说一下-JDK-7-中的-ConcurrentHashMap-的实现原理？"><a href="#说一下-JDK-7-中的-ConcurrentHashMap-的实现原理？" class="headerlink" title="说一下 JDK 7 中的 ConcurrentHashMap 的实现原理？"></a>说一下 JDK 7 中的 ConcurrentHashMap 的实现原理？</h4><p>JDK 7 的 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组构成的。Segment 是一种可重入的锁 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a>，HashEntry 则用于存储键值对数据。<br>一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/collection-31.png"><br><strong>①、put 流程</strong><br>ConcurrentHashMap 的 put 流程和 HashMap 非常类似，只不过是先定位到具体的 Segment，然后通过 ReentrantLock 去操作而已。</p>
<ol>
<li>计算 hash，定位到 segment，segment 如果是空就先初始化；</li>
<li>使用 ReentrantLock 加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定能获取到锁；</li>
<li>遍历 HashEntry，key 相同就直接替换，不存在就插入。</li>
<li>释放锁。</li>
</ol>
<p><strong>②、get 流程</strong><br>get 也很简单，通过 <code>hash(key)</code> 定位到 segment，再遍历链表定位到具体的元素上，需要注意的是 value 是 <a href="https://javabetter.cn/thread/volatile.html">volatile 的</a>，所以 get 是不需要加锁的。<br><a name="wHDJr"></a></p>
<h4 id="说一下-JDK-8-中的-ConcurrentHashMap-的实现原理？"><a href="#说一下-JDK-8-中的-ConcurrentHashMap-的实现原理？" class="headerlink" title="说一下 JDK 8 中的 ConcurrentHashMap 的实现原理？"></a>说一下 JDK 8 中的 ConcurrentHashMap 的实现原理？</h4><p>JDK 8 中的 ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS + synchronized 来保证并发安全性，整个容器只分为一个 Segment，即 table 数组。<br>Node 和 JDK 7 一样，使用 volatile 关键字，保证多线程操作时，变量的可见性。<br>ConcurrentHashMap 实现线程安全的关键点在于 put 流程。<br><strong>①、put 流程</strong><br>第一步，计算 hash，遍历 node 数组，如果 node 是空的话，就通过 CAS+自旋的方式初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备初始化</span></span><br><span class="line">tab = initTable();</span><br><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() {</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">//如果正在初始化或者扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) {   <span class="comment">//CAS操作</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第二步，如果当前数组位置是空，直接通过 CAS 自旋写入数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> {</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第三步，如果 <code>hash==MOVED</code>，说明需要扩容。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">    tab = helpTransfer(tab, f);</span><br></pre></td></tr></tbody></table></figure>
<p>扩容的具体实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="comment">// 下一个表的引用，即新的扩容后的数组</span></span><br><span class="line">    <span class="type">int</span> sc; <span class="comment">// 用于缓存sizeCtl的值</span></span><br><span class="line">    <span class="comment">// 检查条件：传入的表不为空，节点f是ForwardingNode类型，且f中的nextTable不为空</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length); <span class="comment">// 根据当前表长度计算resize stamp</span></span><br><span class="line">        <span class="comment">// 检查循环条件：nextTab等于nextTable，table等于传入的tab，且sizeCtl为负数（表示正在进行或准备进行扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 检查是否应该停止扩容（比如：resize stamp不匹配，或者已达到最大并发扩容线程数，或者transferIndex已经不大于0）</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 尝试通过CAS增加sizeCtl的值，以表示有更多线程参与扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) {</span><br><span class="line">                transfer(tab, nextTab); <span class="comment">// 调用transfer方法，实际进行数据迁移</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nextTab; <span class="comment">// 返回新的表引用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> table; <span class="comment">// 如果不符合扩容协助条件，返回当前表引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第四步，如果都不满足，就使用 synchronized 写入数据，和 HashMap 一样，key 的 hash 一样就覆盖，反之使用拉链法解决哈希冲突，当链表长度超过 8 就转换成红黑树。<br><strong>②、get 查询</strong><br>get 查询的时候，也是通过 key 的 hash 进行定位，需要注意的是 ConcurrentHashMap 会判断 hash 值是否小于 0。<br>如果小于 0，说明是个特殊节点，会调用节点的 find 方法进行查找，比如说 ForwardingNode 的 find 方法或者 TreeNode 的 find 方法。<br><a name="GLWbK"></a></p>
<h4 id="总结一下-HashMap-和-ConcurrentHashMap-的区别？"><a href="#总结一下-HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="总结一下 HashMap 和 ConcurrentHashMap 的区别？"></a>总结一下 HashMap 和 ConcurrentHashMap 的区别？</h4><p>①、HashMap 是非线程安全的，多线程环境下应该使用 ConcurrentHashMap。<br>②、由于 HashMap 仅在单线程环境下使用，所以不需要考虑同步问题，因此效率高于 ConcurrentHashMap。<br><a name="lajbm"></a></p>
<h4 id="你项目中怎么使用-ConcurrentHashMap-的？"><a href="#你项目中怎么使用-ConcurrentHashMap-的？" class="headerlink" title="你项目中怎么使用 ConcurrentHashMap 的？"></a>你项目中怎么使用 ConcurrentHashMap 的？</h4><p>在<a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，很多地方都用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，使用 ConcurrentHashMap 来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。<br><a name="sYdoB"></a></p>
<h4 id="ConcurrentHashMap-对-HashMap-的优化？"><a href="#ConcurrentHashMap-对-HashMap-的优化？" class="headerlink" title="ConcurrentHashMap 对 HashMap 的优化？"></a>ConcurrentHashMap 对 HashMap 的优化？</h4><p>ConcurrentHashMap 是 HashMap 的线程安全版本，使用了 CAS、synchronized、volatile 来确保线程安全。<br>首先是 hash 的计算方法上，ConcurrentHashMap 的 spread 方法接收一个已经计算好的 hashCode，然后将这个哈希码的高 16 位与自身进行异或运算，这里的 HASH_BITS 是一个常数，值为 0x7fffffff，它确保结果是一个非负整数。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> {</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>比 HashMap 的 hash 计算多了一个 <code>&amp; HASH_BITS</code> 的操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>另外，ConcurrentHashMap 对节点 Node 做了进一步的封装，比如说用 Forwarding Node 来表示正在进行扩容的节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; {</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) {</span><br><span class="line">        <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后就是 put 方法，通过 CAS + synchronized 来保证线程安全。<br><a name="ayK6x"></a></p>
<h4 id="为什么-ConcurrentHashMap-在-JDK-1-7-中要用-ReentrantLock，而在-JDK-1-8-要用-synchronized"><a href="#为什么-ConcurrentHashMap-在-JDK-1-7-中要用-ReentrantLock，而在-JDK-1-8-要用-synchronized" class="headerlink" title="为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized"></a>为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized</h4><p>ConcurrentHashMap 在 JDK 1.7 和 JDK 1.8 中的实现机制不同，主要体现在锁的机制上。<br>JDK 1.7 中的 ConcurrentHashMap 使用了分段锁机制，即 Segment 锁，每个 Segment 都是一个 ReentrantLock，这样可以保证每个 Segment 都可以独立地加锁，从而实现更高级别的并发访问。<br>而在 JDK 1.8 中，ConcurrentHashMap 取消了 Segment 分段锁，采用了更加精细化的锁——桶锁，以及 CAS 无锁算法，每个桶（Node 数组的每个元素）都可以独立地加锁，从而实现更高级别的并发访问。<br>再加上 JVM 对 synchronized 做了大量优化，如锁消除、锁粗化、自旋锁和偏向锁等，在低中等的竞争情况下，synchronized 的性能并不比 ReentrantLock 差，并且使用 synchronized 可以简化代码实现。<br><a name="MQXvB"></a></p>
<h3 id="49-ConcurrentHashMap-怎么保证可见性？"><a href="#49-ConcurrentHashMap-怎么保证可见性？" class="headerlink" title="49.ConcurrentHashMap 怎么保证可见性？"></a>49.ConcurrentHashMap 怎么保证可见性？</h3><p>ConcurrentHashMap 保证可见性主要通过使用 volatile 关键字和 synchronized 同步块。<br>在 Java 中，volatile 关键字保证了变量的可见性，即一个线程修改了一个 volatile 变量后，其他线程可以立即看到这个修改。在 ConcurrentHashMap 的内部实现中，有些关键的变量被声明为 volatile，比如 Segment 数组和 Node 数组等。<br>此外，ConcurrentHashMap 还使用了 synchronized 同步块来保证复合操作的原子性。当一个线程进入 synchronized 同步块时，它会获得锁，然后执行同步块内的代码。当它退出 synchronized 同步块时，它会释放锁，并将在同步块内对共享变量的所有修改立即刷新到主内存，这样其他线程就可以看到这些修改了。<br>通过这两种机制，ConcurrentHashMap 保证了在并发环境下的可见性，从而确保了线程安全。<br><a name="WmRXr"></a></p>
<h3 id="50-为什么-ConcurrentHashMap-比-Hashtable-效率高"><a href="#50-为什么-ConcurrentHashMap-比-Hashtable-效率高" class="headerlink" title="50.为什么 ConcurrentHashMap 比 Hashtable 效率高"></a>50.为什么 ConcurrentHashMap 比 Hashtable 效率高</h3><blockquote>
<p>2024 年 03 月 26 日增补，从集合框架移动到并发编程这里</p>
</blockquote>
<p>Hashtable 在任何时刻只允许一个线程访问整个 Map，通过对整个 Map 加锁来实现线程安全。<br>而 ConcurrentHashMap（尤其是在 JDK 8 及之后版本）通过锁分离和 CAS 操作实现更细粒度的锁定策略，允许更高的并发。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> {</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>CAS 操作是一种乐观锁，它不会阻塞线程，而是在更新时检查是否有其他线程已经修改了数据，如果没有就更新，如果有就重试。<br>ConcurrentHashMap 允许多个读操作并发进行而不加锁，因为它通过 <a href="https://javabetter.cn/thread/volatile.html">volatile 变量</a>来保证读取操作的内存可见性。相比之下，Hashtable 对读操作也加锁，增加了开销。<br><a name="jzwGI"></a></p>
<h3 id="51-能说一下-CopyOnWriteArrayList-的实现原理吗？"><a href="#51-能说一下-CopyOnWriteArrayList-的实现原理吗？" class="headerlink" title="51.能说一下 CopyOnWriteArrayList 的实现原理吗？"></a>51.能说一下 CopyOnWriteArrayList 的实现原理吗？</h3><p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，它遵循写时复制（Copy-On-Write）的原则，即在写操作时，会先复制一个新的数组，然后在新的数组上进行写操作，写完之后再将原数组引用指向新数组。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CopyOnWriteArrayList-01.png"><br>这样，读操作总是在一个不变的数组版本上进行的，就不需要同步了。<br><a name="VrLsY"></a></p>
<h3 id="52-能说一下-BlockingQueue-吗？"><a href="#52-能说一下-BlockingQueue-吗？" class="headerlink" title="52. 能说一下 BlockingQueue 吗？"></a>52. 能说一下 BlockingQueue 吗？</h3><p><a href="https://javabetter.cn/thread/BlockingQueue.html">BlockingQueue</a> 代表的是线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。<br>阻塞队列（BlockingQueue）被广泛用于“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。<br>BlockingQueue 接口的实现类有 ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、LinkedBlockingQueue、LinkedTransferQueue、PriorityBlockingQueue、SynchronousQueue 等。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/BlockingQueue-20230818153420.png"><br>阻塞指的是一种程序执行状态，其中某个线程在等待某个条件满足时暂停其执行（即阻塞），直到条件满足时恢复其执行。<br><a name="h9Tkq"></a></p>
<h4 id="阻塞队列是如何实现的？"><a href="#阻塞队列是如何实现的？" class="headerlink" title="阻塞队列是如何实现的？"></a>阻塞队列是如何实现的？</h4><p>就拿 ArrayBlockingQueue 来说，它是一个基于数组的有界阻塞队列，采用 <a href="https://javabetter.cn/thread/reentrantLock.html">ReentrantLock</a> 锁来实现线程的互斥，而 ReentrantLock 底层采用的是 AQS 实现的队列同步，线程的阻塞调用 <a href="https://javabetter.cn/thread/LockSupport.html">LockSupport.park</a> 实现，唤醒调用 LockSupport.unpark 实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 使用ReentrantLock锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 如果队列已满，阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> {</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 插入元素后，通知消费者线程可以继续取元素</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 如果队列为空，阻塞，等待生产者线程放入元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 移除元素并返回</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素并返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 数组是循环队列，如果到达数组末尾，从头开始</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 移除元素后，通知生产者线程可以继续放入元素</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="n0oU7"></a></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a name="KFS0h"></a></p>
<h3 id="53-什么是线程池？"><a href="#53-什么是线程池？" class="headerlink" title="53.什么是线程池？"></a>53.什么是线程池？</h3><p>线程池，简单来说，就是一个管理线程的池子。<br>①、频繁地创建和销毁线程会消耗系统资源，线程池能够复用已创建的线程。<br>②、提高响应速度，当任务到达时，任务可以不需要等待线程创建就立即执行。<br>③、线程池支持定时执行、周期性执行、单线程执行和并发数控制等功能。<br><a name="fmkCH"></a></p>
<h3 id="54-能说说工作中线程池的应用吗？"><a href="#54-能说说工作中线程池的应用吗？" class="headerlink" title="54.能说说工作中线程池的应用吗？"></a>54.能说说工作中线程池的应用吗？</h3><p>推荐阅读：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">线程池在美团业务中的应用</a><br>为了最大程度利用 CPU 的多核性能，并行运算的能力是不可获取的，通过线程池来管理线程是一个非常基础的操作。<br><strong>①、快速响应用户请求</strong><br>当用户发起一个实时请求，服务器需要快速响应，此时如果每次请求都直接创建一个线程，那么线程的创建和销毁会消耗大量的系统资源。<br>使用线程池，可以预先创建一定数量的线程，当用户请求到来时，直接从线程池中获取一个空闲线程，执行用户请求，执行完毕后，线程不销毁，而是继续保留在线程池中，等待下一个请求。<br>注意：这种场景下需要调高 corePoolSize 和 maxPoolSize，尽可能多创建线程，避免使用队列去缓存任务。<br>比如说，在项目中，当用户请求首页时，就使用了线程池去加载首页的热门文章、置顶文章、侧边栏、用户登录信息等。<br>我们封装了一个异步类 AsyncUtil，内部的静态类 CompletableFutureBridge 是通过 <a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture</a> 实现的，其中的 <code>runAsyncWithTimeRecord()</code> 方法就是使用线程池去执行任务的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFutureBridge <span class="title function_">runAsyncWithTimeRecord</span><span class="params">(Runnable run, String name)</span> {</span><br><span class="line">    <span class="keyword">return</span> runAsyncWithTimeRecord(run, name, executorService);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中线程池的初始化中，corePoolSize 为 CPU 核心数的两倍，因为技术派中的大多数任务都是 IO 密集型的，maxPoolSize 设置为 50，是一个比较理想的值，尤其是在本地环境中；阻塞队列为 SynchronousQueue，这意味着任务被创建后直接提交给等待的线程处理，而不是放入队列中。<br><strong>②、快速处理批量任务</strong><br>这种场景也需要处理大量的任务，但可能不需要立即响应，这时候就应该设置队列去缓冲任务，corePoolSize 不需要设置得太高，避免线程上下文切换引起的频繁切换问题。<br><a name="Qas0s"></a></p>
<h3 id="55-能简单说一下线程池的工作流程吗？"><a href="#55-能简单说一下线程池的工作流程吗？" class="headerlink" title="55.能简单说一下线程池的工作流程吗？"></a>55.能简单说一下线程池的工作流程吗？</h3><p>当应用程序提交一个任务时，线程池会根据当前线程的状态和参数决定如何处理这个任务。</p>
<ul>
<li>如果线程池中的核心线程都在忙，并且线程池未达到最大线程数，新提交的任务会被放入队列中进行等待。</li>
<li>如果任务队列已满，且当前线程数量小于最大线程数，线程池会创建新的线程来处理任务。</li>
</ul>
<p>空闲的线程会从任务队列中取出任务来执行，当任务执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。<br>当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。<br>举例：</p>
<ol>
<li>corePoolSize 对应营业窗口数 3</li>
<li>maximumPoolSize 对应最大窗口数 6</li>
<li>workQueue 对应排队区</li>
<li>handler 对应接待员小美<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">6</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">0</span>, <span class="comment">// 线程空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), <span class="comment">// 等待队列</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 模拟 10 个顾客来银行办理业务</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">                threadPool.execute(() -&gt; {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"办理业务"</span> + tempInt);</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
好，我再来梳理一下线程池的整个工作流程。<br>第一步，创建线程池。<br>第二步，调用线程池的 <code>execute()</code>方法，提交任务。</li>
</ol>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么线程池会创建一个新的线程来执行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么线程池会将这个任务放入等待队列；</li>
<li>如果等待队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么线程池会创建新的线程来执行这个任务；</li>
<li>如果等待队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会执行拒绝策略。</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-66.png"><br>第三步，线程执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。<br>第四步，当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。<br><a name="hFeW2"></a></p>
<h3 id="56-线程池主要参数有哪些？"><a href="#56-线程池主要参数有哪些？" class="headerlink" title="56.线程池主要参数有哪些？"></a>56.线程池主要参数有哪些？</h3><p>线程池有 7 个参数，需要重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>、<code>handler</code> 这四个。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-67.png"><br>我一一说一下：<br><strong>①、corePoolSize</strong><br>定义了线程池中的核心线程数量。即使这些线程处于空闲状态，它们也不会被回收。这是线程池保持在等待状态下的线程数。<br><strong>②、maximumPoolSize</strong><br>线程池允许的最大线程数量。当工作队列满了之后，线程池会创建新线程来处理任务，直到线程数达到这个最大值。<br><strong>③、workQueue</strong><br>用于存放待处理任务的阻塞队列。当所有核心线程都忙时，新任务会被放在这个队列里等待执行。<br><strong>④、handler</strong><br>拒绝策略 RejectedExecutionHandler，定义了当线程池和工作队列都满了之后对新提交的任务的处理策略。常见的拒绝策略包括抛出异常、直接丢弃、丢弃队列中最老的任务、由提交任务的线程来直接执行任务等。<br><strong>⑤、threadFactory</strong><br>一个创建新线程的工厂。它用于创建线程池中的线程。可以通过自定义 ThreadFactory 来给线程池中的线程设置有意义的名字，或设置优先级等。<br><strong>⑥、keepAliveTime</strong><br>非核心线程的空闲存活时间。如果线程池中的线程数量超过了 corePoolSize，那么这些多余的线程在空闲时间超过 keepAliveTime 时会被终止。<br><strong>⑦、unit</strong><br>keepAliveTime 参数的时间单位：</p>
<ul>
<li>TimeUnit.DAYS; 天</li>
<li>TimeUnit.HOURS; 小时</li>
<li>TimeUnit.MINUTES; 分钟</li>
<li>TimeUnit.SECONDS; 秒</li>
<li>TimeUnit.MILLISECONDS; 毫秒</li>
<li>TimeUnit.MICROSECONDS; 微秒</li>
<li>TimeUnit.NANOSECONDS; 纳秒<br><a name="diMLJ"></a></li>
</ul>
<h4 id="能简单说一下参数之间的关系吗？"><a href="#能简单说一下参数之间的关系吗？" class="headerlink" title="能简单说一下参数之间的关系吗？"></a>能简单说一下参数之间的关系吗？</h4><p>①、corePoolSize 和 maximumPoolSize 共同定义了线程池的规模。</p>
<ul>
<li>当提交的任务数不足以填满核心线程时，线程池只会创建足够的线程来处理任务。</li>
<li>当任务数增多，超过核心线程的处理能力时，任务会被加入 workQueue。</li>
<li>如果 workQueue 已满，而当前线程数又小于 maximumPoolSize，线程池会尝试创建新的线程来处理任务。</li>
</ul>
<p>②、keepAliveTime 和 unit 决定了非核心线程可以空闲存活多久。这会影响了线程池的资源回收策略。<br>③、workQueue 的选择对线程池的行为有重大影响。不同类型的队列（如无界队列、有界队列）会导致线程池在任务增多时的反应不同。<br>④、handler 定义了线程池的饱和策略，即当线程池无法接受新任务时的行为。决定了系统在极限情况下的表现。<br><a name="LSwoj"></a></p>
<h4 id="核心线程数不够会怎么进行处理？"><a href="#核心线程数不够会怎么进行处理？" class="headerlink" title="核心线程数不够会怎么进行处理？"></a>核心线程数不够会怎么进行处理？</h4><p>当提交的任务数超过了 corePoolSize，但是小于 maximumPoolSize 时，线程池会创建新的线程来处理任务。<br>当提交的任务数超过了 maximumPoolSize 时，线程池会根据拒绝策略来处理任务。<br><a name="JPh1y"></a></p>
<h4 id="举个例子说一下这些参数的变化"><a href="#举个例子说一下这些参数的变化" class="headerlink" title="举个例子说一下这些参数的变化"></a>举个例子说一下这些参数的变化</h4><p>假设一个场景，线程池的配置如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize = <span class="number">5</span></span><br><span class="line">maximumPoolSize = <span class="number">10</span></span><br><span class="line">keepAliveTime = <span class="number">60</span>秒</span><br><span class="line">workQueue = LinkedBlockingQueue（容量为<span class="number">100</span>）</span><br><span class="line">默认的<span class="type">threadFactory</span></span><br><span class="line"><span class="variable">handler</span> <span class="operator">=</span> ThreadPoolExecutor.AbortPolicy()</span><br></pre></td></tr></tbody></table></figure>
<p><strong>场景一</strong>：当系统启动后，逐渐有 10 个任务提交到线程池。</p>
<ul>
<li>前 5 个任务会立即执行，因为它们会占用所有的核心线程。</li>
<li>随后的 5 个任务会被放入工作队列中等待执行。</li>
</ul>
<p><strong>场景二</strong>：如果此时再有 100 个任务提交到线程池。</p>
<ul>
<li>工作队列已满，线程池会创建额外的线程来执行这些任务，直到线程总数达到 maximumPoolSize（10 个线程）。</li>
<li>如果任务继续增加，超过了工作队列和最大线程数的限制，新来的任务将会根据拒绝策略（AbortPolicy）被拒绝，抛出 RejectedExecutionException 异常。</li>
</ul>
<p><strong>场景三</strong>：如果任务突然减少，只有少量的任务需要执行：<br>核心线程会一直运行，而超出核心线程数的线程，如果空闲时间超过 keepAliveTime，将会被终止，直到线程池的线程数减少到 corePoolSize。<br><a name="pS3Qq"></a></p>
<h3 id="57-线程池的拒绝策略有哪些？"><a href="#57-线程池的拒绝策略有哪些？" class="headerlink" title="57.线程池的拒绝策略有哪些？"></a>57.线程池的拒绝策略有哪些？</h3><p>主要有四种：</p>
<ul>
<li>AbortPolicy：这是默认的拒绝策略。该策略会抛出一个 RejectedExecutionException 异常。也就对应着“我们系统瘫痪了”。</li>
<li>CallerRunsPolicy：该策略不会抛出异常，而是会让提交任务的线程（即调用 execute 方法的线程）自己来执行这个任务。也就对应着“谁叫你来办的你找谁去”。</li>
<li>DiscardOldestPolicy：策略会丢弃队列中最老的一个任务（即队列中等待最久的任务），然后尝试重新提交被拒绝的任务。也就对应着“看你比较急，去队里加个塞”。</li>
<li>DiscardPolicy：策略会默默地丢弃被拒绝的任务，不做任何处理也不抛出异常。也就对应着“今天没办法，不行你看改一天”。</li>
</ul>
<p>如果想实现自己的拒绝策略，实现 RejectedExecutionHandler 接口即可。<br><a name="KDkx5"></a></p>
<h3 id="58-线程池有哪几种阻塞队列？"><a href="#58-线程池有哪几种阻塞队列？" class="headerlink" title="58.线程池有哪几种阻塞队列？"></a>58.线程池有哪几种阻塞队列？</h3><p>在 Java 中，线程池（ThreadPoolExecutor）使用阻塞队列（BlockingQueue）来存储待处理的任务。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-69.png"><br>①、ArrayBlockingQueue：一个有界的先进先出的阻塞队列，底层是一个数组，适合固定大小的线程池。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">10</span>, <span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>②、LinkedBlockingQueue：底层数据结构是链表，如果不指定大小，默认大小是 Integer.MAX_VALUE，相当于一个无界队列。项目中，就使用了 LinkedBlockingQueue 来配置 RabbitMQ 的消息队列。<br>③、PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。任务按照其自然顺序或通过构造器给定的 Comparator 来排序。<br>适用于需要按照给定优先级处理任务的场景，比如优先处理紧急任务。<br>④、DelayQueue：类似于 PriorityBlockingQueue，由二叉堆实现的无界优先级阻塞队列。<br>Executors 中的 <code>newScheduledThreadPool()</code> 就使用了 DelayQueue 来实现延迟执行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>⑤、SynchronousQueue：实际上它不是一个真正的队列，因为没有容量。每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都必须等待另一个线程的插入操作。<br><code>Executors.newCachedThreadPool()</code> 就使用了 SynchronousQueue，这个线程池会根据需要创建新线程，如果有空闲线程则会重复使用，线程空闲 60 秒后会被回收。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="LBG9F"></a></p>
<h3 id="59-线程池提交-execute-和-submit-有什么区别？"><a href="#59-线程池提交-execute-和-submit-有什么区别？" class="headerlink" title="59.线程池提交 execute 和 submit 有什么区别？"></a>59.线程池提交 execute 和 submit 有什么区别？</h3><ol>
<li><p>execute 用于提交不需要返回值的任务</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub }</span></span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>submit()方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get()方法来获取返回值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(haveReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> { <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> future.get(); } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">} <span class="keyword">catch</span> (ExecutionException e) {</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="comment">// 关闭线程池 executor.shutdown();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a name="NWi54"></a></p>
</li>
</ol>
<h3 id="60-线程池怎么关闭知道吗？"><a href="#60-线程池怎么关闭知道吗？" class="headerlink" title="60.线程池怎么关闭知道吗？"></a>60.线程池怎么关闭知道吗？</h3><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。<br><strong>shutdown() 将线程池状态置为 shutdown,并不会立即停止</strong>：</p>
<ol>
<li>停止接收外部 submit 的任务</li>
<li>内部正在跑的任务和队列里等待的任务，会执行完</li>
<li>等到第二步完成后，才真正停止</li>
</ol>
<p><strong>shutdownNow() 将线程池状态置为 stop。一般会立即停止，事实上不一定</strong>：</p>
<ol>
<li>和 shutdown()一样，先停止接收外部提交的任务</li>
<li>忽略队列里等待的任务</li>
<li>尝试将正在跑的任务 interrupt 中断</li>
<li>返回未执行的任务列表</li>
</ol>
<p>shutdown 和 shutdownnow 简单来说区别如下：</p>
<ul>
<li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li>
<li>shutdown()只是关闭了提交通道，用 submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。<br><a name="ve21h"></a></li>
</ul>
<h3 id="61-线程池的线程数应该怎么配置？"><a href="#61-线程池的线程数应该怎么配置？" class="headerlink" title="61.线程池的线程数应该怎么配置？"></a>61.线程池的线程数应该怎么配置？</h3><p>首先，我会分析线程池中执行的任务类型是 CPU 密集型还是 IO 密集型？<br>①、对于 CPU 密集型任务，我的目标是尽量减少线程上下文切换，以优化 CPU 使用率。一般来说，核心线程数设置为处理器的核心数或核心数加一（以备不时之需，如某些线程因等待系统资源而阻塞时）是较理想的选择。<br>②、对于 IO 密集型任务，由于线程经常处于等待状态（等待 IO 操作完成），可以设置更多的线程来提高并发性（比如说 2 倍），从而增加 CPU 利用率。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-70.png"><br>核心数可以通过 Java 的<code>Runtime.getRuntime().availableProcessors()</code>方法获取。<br>此外，每个线程都会占用一定的内存，因此我需要确保线程池的规模不会耗尽 JVM 内存，避免频繁的垃圾回收或内存溢出。<br>最后，我会根据业务需求和系统资源来调整线程池的参数，比如核心线程数、最大线程数、非核心线程的空闲存活时间、任务队列容量等。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    cores, <span class="comment">// 核心线程数设置为CPU核心数</span></span><br><span class="line">    cores * <span class="number">2</span>, <span class="comment">// 最大线程数为核心数的两倍</span></span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">// 非核心线程的空闲存活时间</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>) <span class="comment">// 任务队列容量</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p><a name="feMke"></a></p>
<h3 id="62-有哪几种常见的线程池？"><a href="#62-有哪几种常见的线程池？" class="headerlink" title="62.有哪几种常见的线程池？"></a>62.有哪几种常见的线程池？</h3><p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-71.png"><br>可以通过 Executors 工厂类来创建四种常见的线程池：</p>
<ul>
<li>newFixedThreadPool (固定线程数目的线程池)</li>
<li>newCachedThreadPool (可缓存线程的线程池)</li>
<li>newSingleThreadExecutor (单线程的线程池)</li>
<li>newScheduledThreadPool (定时及周期执行的线程池)<br><a name="ULwjL"></a></li>
</ul>
<h3 id="63-能说一下四种常见线程池的原理吗？"><a href="#63-能说一下四种常见线程池的原理吗？" class="headerlink" title="63.能说一下四种常见线程池的原理吗？"></a>63.能说一下四种常见线程池的原理吗？</h3><p>前三种线程池的构造直接调用 ThreadPoolExecutor 的构造方法。<br><a name="hrYdn"></a></p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>线程池特点</strong></p>
<ul>
<li>核心线程数为 1</li>
<li>最大线程数也为 1</li>
<li>阻塞队列是无界队列 LinkedBlockingQueue，可能会导致 OOM</li>
<li>keepAliveTime 为 0</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-72.png"><br>工作流程：</p>
<ul>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，将任务加到阻塞队列</li>
<li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</li>
</ul>
<p><strong>适用场景</strong><br>适用于串行执行任务的场景，一个任务一个任务地执行。<br><a name="aXPIN"></a></p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>线程池特点：</strong></p>
<ul>
<li>核心线程数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即 keepAliveTime 为 0</li>
<li>阻塞队列为无界队列 LinkedBlockingQueue，可能会导致 OOM</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-73.png"><br>工作流程：</p>
<ul>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程，把任务添加到 LinkedBlockingQueue 阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li>
</ul>
<p><strong>使用场景</strong><br>FixedThreadPool 适用于处理 CPU 密集型的任务，确保 CPU 在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。<br><a name="QS2H8"></a></p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>线程池特点：</strong></p>
<ul>
<li>核心线程数为 0</li>
<li>最大线程数为 Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致 OOM</li>
<li>阻塞队列是 SynchronousQueue</li>
<li>非核心线程空闲存活时间为 60 秒</li>
</ul>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-74.png"><br>工作流程：</p>
<ul>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到 SynchronousQueue 队列。</li>
<li>判断是否有空闲线程，如果有，就去取出任务执行。</li>
<li>如果没有空闲线程，就新建一个线程执行。</li>
<li>执行完任务的线程，还可以存活 60 秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li>
</ul>
<p><strong>适用场景</strong><br>用于并发执行大量短期的小任务。<br><a name="TfZGO"></a></p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>线程池特点</strong></p>
<ul>
<li>最大线程数为 Integer.MAX_VALUE，也有 OOM 的风险</li>
<li>阻塞队列是 DelayedWorkQueue</li>
<li>keepAliveTime 为 0</li>
<li>scheduleAtFixedRate() ：按某种速率周期执行</li>
<li>scheduleWithFixedDelay()：在某个延迟后执行</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-75.png"><br><strong>工作机制</strong></p>
<ul>
<li>线程从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前时间。</li>
<li>线程执行这个 ScheduledFutureTask。</li>
<li>线程修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间。</li>
<li>线程把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。</li>
</ul>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-76.png"><br><strong>使用场景</strong><br>周期性执行任务的场景，需要限制线程数量的场景</p>
<blockquote>
<p>使用无界队列的线程池会导致什么问题吗？</p>
</blockquote>
<p>例如 newFixedThreadPool 使用了无界的阻塞队列 LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致 OOM。<br><a name="xe9ES"></a></p>
<h3 id="64-线程池异常怎么处理知道吗？"><a href="#64-线程池异常怎么处理知道吗？" class="headerlink" title="64.线程池异常怎么处理知道吗？"></a>64.线程池异常怎么处理知道吗？</h3><p>在使用线程池处理任务的时候，任务代码可能抛出 RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。<br>常见的异常处理方式：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-77.png"><br><a name="kAW1S"></a></p>
<h3 id="65-能说一下线程池有几种状态吗？"><a href="#65-能说一下线程池有几种状态吗？" class="headerlink" title="65.能说一下线程池有几种状态吗？"></a>65.能说一下线程池有几种状态吗？</h3><p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></tbody></table></figure>
<p>线程池各个状态切换图：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-78.png"><br><strong>RUNNING</strong></p>
<ul>
<li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li>
<li>调用线程池的 shutdown()方法，可以切换到 SHUTDOWN 状态;</li>
<li>调用线程池的 shutdownNow()方法，可以切换到 STOP 状态;</li>
</ul>
<p><strong>SHUTDOWN</strong></p>
<ul>
<li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li>
<li>队列为空，并且线程池中执行的任务也为空,进入 TIDYING 状态;</li>
</ul>
<p><strong>STOP</strong></p>
<ul>
<li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li>
<li>线程池中执行的任务为空,进入 TIDYING 状态;</li>
</ul>
<p><strong>TIDYING</strong></p>
<ul>
<li>该状态表明所有的任务已经运行终止，记录的任务数量为 0。</li>
<li>terminated()执行完毕，进入 TERMINATED 状态</li>
</ul>
<p><strong>TERMINATED</strong></p>
<ul>
<li>该状态表示线程池彻底终止<br><a name="GmKN3"></a></li>
</ul>
<h3 id="66-线程池如何实现参数的动态修改？"><a href="#66-线程池如何实现参数的动态修改？" class="headerlink" title="66.线程池如何实现参数的动态修改？"></a>66.线程池如何实现参数的动态修改？</h3><p>线程池提供了几个 setter 方法来设置线程池的参数。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-79.png"><br>这里主要有两个思路：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-80.png"></p>
<ul>
<li>在我们微服务的架构下，可以利用配置中心如 Nacos、Apollo 等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。</li>
<li>如果限制了配置中心的使用，也可以自己去扩展<strong>ThreadPoolExecutor</strong>，重写方法，监听线程池参数变化，来动态修改线程池参数。<br><a name="ELeMo"></a></li>
</ul>
<h3 id="67-线程池调优了解吗？（补充）"><a href="#67-线程池调优了解吗？（补充）" class="headerlink" title="67.线程池调优了解吗？（补充）"></a>67.线程池调优了解吗？（补充）</h3><blockquote>
<p>2024 年 03 月 16 日增补</p>
</blockquote>
<p>线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-81.png"><br>上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。<br>事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。<br>事后要注意仔细观察，随时调整。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-82.png"><br>具体的调优案例可以查看参考[7]美团技术博客。<br><a name="IEq26"></a></p>
<h3 id="68-线程池在使用的时候需要注意什么？（补充）"><a href="#68-线程池在使用的时候需要注意什么？（补充）" class="headerlink" title="68.线程池在使用的时候需要注意什么？（补充）"></a>68.线程池在使用的时候需要注意什么？（补充）</h3><blockquote>
<p>2024 年 03 月 16 日增补</p>
</blockquote>
<p>我认为比较重要的关注点有 3 个：<br>①、选择合适的线程池大小</p>
<ul>
<li><strong>过小</strong>的线程池可能会导致任务一直在排队</li>
<li><strong>过大</strong>的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销</li>
</ul>
<p>可以根据业务是 IO 密集型还是 CPU 密集型来选择线程池大小：</p>
<ul>
<li>CPU 密集型：指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为 CPU 核心数+1。</li>
<li>IO 密集型：当执行任务需要大量的 io，比如磁盘 io，网络 io，可能会存在大量的阻塞，所以在 IO 密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 2*CPU 核心数。</li>
</ul>
<p>②、任务队列的选择</p>
<ul>
<li>使用有界队列可以避免资源耗尽的风险，但是可能会导致任务被拒绝</li>
<li>使用无界队列虽然可以避免任务被拒绝，但是可能会导致内存耗尽</li>
</ul>
<p>一般需要设置有界队列的大小，比如 LinkedBlockingQueue 在构造的时候可以传入参数来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的 oom。<br>③、尽量使用自定义的线程池，而不是使用 Executors 创建的线程池，因为 newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，队列的容量默认无限大，实际使用中出现任务过多时会导致内存溢出；newCachedThreadPool 线程池由于核心线程数无限大，当任务过多的时候会导致创建大量的线程，可能机器负载过高导致服务宕机。<br><a name="JyDvu"></a></p>
<h3 id="69-你能设计实现一个线程池吗？"><a href="#69-你能设计实现一个线程池吗？" class="headerlink" title="69.你能设计实现一个线程池吗？"></a>69.你能设计实现一个线程池吗？</h3><p>推荐阅读：<a href="https://mp.weixin.qq.com/s/Exy7pRGND9TCjRd9TZK4jg">三分恶线程池原理</a><br>线程池的设计需要考虑这几个关键因素：</p>
<ol>
<li>核心线程池类：包含核心线程数、最大线程数。</li>
<li>工作线程：线程池中实际工作的线程，从任务队列中获取任务并执行。</li>
<li>任务队列：存放待执行任务的队列，可以使用阻塞队列实现。</li>
<li>拒绝策略：当任务队列满时，处理新任务的策略。</li>
</ol>
<p><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-83.png"><br>核心线程池类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CustomThreadPoolExecutor is a simple implementation of a thread pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolExecutor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isShutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentPoolSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a CustomThreadPoolExecutor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize    the number of core threads.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime   the time to keep extra threads alive.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit            the time unit for keepAliveTime.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue       the queue to hold runnable tasks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler         the handler to use when execution is blocked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit,</span></span><br><span class="line"><span class="params">                                    BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> {</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes a given task using the thread pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to execute.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isShutdown) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">"ThreadPool is shutdown"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">            <span class="comment">// If current pool size is less than core pool size, create a new worker thread</span></span><br><span class="line">            <span class="keyword">if</span> (currentPoolSize &lt; corePoolSize) {</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Worker</span>(task).start();</span><br><span class="line">                currentPoolSize++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to add task to the queue, if full create a new worker thread if possible</span></span><br><span class="line">            <span class="keyword">if</span> (!workQueue.offer(task)) {</span><br><span class="line">                <span class="keyword">if</span> (currentPoolSize &lt; maximumPoolSize) {</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Worker</span>(task).start();</span><br><span class="line">                    currentPoolSize++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// If maximum pool size reached, apply the rejection handler</span></span><br><span class="line">                    handler.rejectedExecution(task, <span class="literal">null</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shuts down the thread pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> {</span><br><span class="line">        isShutdown = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker is an internal class that represents a worker thread in the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> {</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable task) {</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task.run();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Gets a task from the work queue, waiting up to keepAliveTime if necessary.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a task to run, or null if the keepAliveTime expires.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">return</span> workQueue.poll(keepAliveTime, unit);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>拒绝策略：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CustomRejectedExecutionHandler contains several common rejection policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbortPolicy throws a RuntimeException when the task is rejected.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"Task "</span> + r.toString() + <span class="string">" rejected from "</span> + e.toString());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DiscardPolicy silently discards the rejected task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> {</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CallerRunsPolicy runs the rejected task in the caller's thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> {</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) {</span><br><span class="line">                r.run();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.paicoding.forum.web.javabetter.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// Create a thread pool with core size 2, max size 4, and a queue capacity of 2</span></span><br><span class="line">        <span class="type">CustomThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CustomRejectedExecutionHandler</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Submit 10 tasks to the pool</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; {</span><br><span class="line">                System.out.println(<span class="string">"Task "</span> + index + <span class="string">" is running"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shutdown the thread pool</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-20240727230303.png"><br><a name="Mc61k"></a></p>
<h3 id="70-单机线程池执行断电了应该怎么处理？"><a href="#70-单机线程池执行断电了应该怎么处理？" class="headerlink" title="70.单机线程池执行断电了应该怎么处理？"></a>70.单机线程池执行断电了应该怎么处理？</h3><p>我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理</code>的已经执行成功的操作。然后重新执行整个阻塞队列。<br>也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。<br><a name="RqB1i"></a></p>
<h2 id="并发容器和框架"><a href="#并发容器和框架" class="headerlink" title="并发容器和框架"></a>并发容器和框架</h2><p>关于一些并发容器，可以去看看 <a href="https://mp.weixin.qq.com/s/SHkQ7LEOT0itt4bXMoDBPw">面渣逆袭：Java 集合连环三十问 </a>，里面有<code>CopyOnWriteArrayList</code>和<code>ConcurrentHashMap</code>这两种线程安全容器类的问答。。<br><a name="EaRcS"></a></p>
<h3 id="71-Fork-Join-框架了解吗？"><a href="#71-Fork-Join-框架了解吗？" class="headerlink" title="71.Fork/Join 框架了解吗？"></a>71.Fork/Join 框架了解吗？</h3><p>Fork/Join 框架是 Java7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>要想掌握 Fork/Join 框架，首先需要理解两个点，<strong>分而治之</strong>和<strong>工作窃取算法</strong>。<br><strong>分而治之</strong><br>Fork/Join 框架的定义，其实就体现了分治思想：将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-85.png"><br><strong>工作窃取算法</strong><br>大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。<br>那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的<strong>工作窃取</strong>。<br>工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。<br><img src="/./img/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/javathread-86.png"><br>看一个 Fork/Join 框架应用的例子，计算 1~n 之间的和：1+2+3+…+n</p>
<ul>
<li>设置一个分割阈值，任务大于阈值就拆分任务</li>
<li>任务有结果，所以需要继承 RecursiveTask<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canCompute</span> <span class="operator">=</span> (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) {</span><br><span class="line">                sum += i;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(start, middle);</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork(); <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.join(); <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(); <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        <span class="type">CountTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        } <span class="keyword">catch</span> (ExecutionException e) {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
ForkJoinTask 与一般 Task 的主要区别在于它需要实现 compute 方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用 fork 方法时，又会进 compute 方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用 join 方法会等待子任务执行完并得到其结果。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://ylcheng1789.github.io">程月龙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://ylcheng1789.github.io/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://ylcheng1789.github.io/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ylcheng1789.github.io" target="_blank">Loong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg" data-sites="weibo,wechat,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏一下~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_trade.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_trade.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay_trade.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay_trade.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="八股文系列-Java集合框架"><img class="cover" src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">八股文系列-Java集合框架</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cyl.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">程月龙</div><div class="author-info__description">技术博客、独立开发者、Java开发、Python开发、人工智能</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://github.com/ylcheng1789"><i class="fas fa-video"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ylcheng1789" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/ylcheng1789@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/19834521789" target="_blank" title="Phone"><i class="fas fa-square-phone-flip" style="color: #00c4b6;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Loong开发，致力于为猿友们提供有价值的内容</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B9%B6%E8%A1%8C%E8%B7%9F%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.并行跟并发有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">你对线程安全的理解是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.说说什么是进程和线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">如何理解协程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">说说线程的共享内存？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3.说说线程有几种创建方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-8G-%E5%86%85%E5%AD%98%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%A4%9A%E8%83%BD%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">一个 8G 内存的系统最多能创建多少线程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA-Java-%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">启动一个 Java 程序，你能说说里面有哪些线程吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E9%82%A3%E6%80%8E%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4.调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5.线程有哪些常用的调度方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E9%80%9A%E7%9F%A5%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">说说线程等待与通知？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="toc-number">1.5.2.</span> <span class="toc-text">说说线程休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E8%AE%A9%E5%87%BA%E4%BC%98%E5%85%88%E6%9D%83"><span class="toc-number">1.5.3.</span> <span class="toc-text">说说让出优先权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.4.</span> <span class="toc-text">说说线程中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.线程有几种状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7.什么是线程上下文切换？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%A4%9A%E6%A0%B8%E8%B0%83%E5%BA%A6%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">线程可以被多核调度吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">8.守护线程了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9.线程间有哪些通信方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%AF%B7%E8%AF%B4%E8%AF%B4-sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">10.请说说 sleep 和 wait 的区别？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">11.线程安全，说一个使用场景？（补充）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">2.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-ThreadLocal-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">12.ThreadLocal 是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86-ThreadLocal%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">除了 ThreadLocal，还有什么解决线程安全问题的方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BD%A0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%94%A8%E5%88%B0%E8%BF%87-ThreadLocal-%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">13.你在工作中用到过 ThreadLocal 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-ThreadLocal-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">14.ThreadLocal 怎么实现的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是弱引用，什么是强引用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">15.ThreadLocal 内存泄露是怎么回事？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-number">2.4.1.</span> <span class="toc-text">那怎么解决内存泄漏问题呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88-key-%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">那为什么 key 要设计成弱引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B-ThreadLocal-%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">2.4.3.</span> <span class="toc-text">你了解哪些 ThreadLocal 的改进方案？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ThreadLocalMap-%E7%9A%84%E6%BA%90%E7%A0%81%E7%9C%8B%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">16.ThreadLocalMap 的源码看过吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ThreadLocalMap-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-Hash-%E5%86%B2%E7%AA%81%E7%9A%84%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">17.ThreadLocalMap 怎么解决 Hash 冲突的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-ThreadLocalMap-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">18.ThreadLocalMap 扩容机制了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E7%88%B6%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">19.父子线程怎么共享数据？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Java 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">20.说一下你对 Java 内存模型的理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E8%A6%81%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">为什么线程要用自己的内存？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">21.说说你对原子性、可见性、有序性的理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E9%83%BD%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%91%A2%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">原子性、可见性、有序性都应该怎么保证呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i-%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.2.</span> <span class="toc-text">i++是原子操作吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%82%A3%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">22.那说说什么是指令重排？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E6%9C%89%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9Fhappens-before-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">23.指令重排有限制吗？happens-before 了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-as-if-serial-%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%80%E5%AE%9A%E6%98%AF%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">24.as-if-serial 又是什么？单线程的程序一定是顺序的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-volatile-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">25.volatile 实现原理了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">3.6.1.</span> <span class="toc-text">volatile 怎么保证可见性的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">3.6.2.</span> <span class="toc-text">volatile 怎么保证有序性的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%92%8C-synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.3.</span> <span class="toc-text">volatile 和 synchronized 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%8A%A0%E5%9C%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.6.4.</span> <span class="toc-text">volatile 加在基本类型和对象上的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-synchronized-%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">26.synchronized 用过吗？怎么使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">27.synchronized 的实现原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">synchronized 是怎么加锁的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E9%94%81%E4%BD%8F%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">synchronized 锁住的是什么呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E4%B8%8D%E4%BC%9A%E7%89%B5%E6%89%AF%E5%88%B0-os-%E5%B1%82%E9%9D%A2%E5%91%A2%EF%BC%9F"><span class="toc-number">4.2.3.</span> <span class="toc-text">会不会牵扯到 os 层面呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E9%99%A4%E4%BA%86%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8Csynchronized-%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">28.除了原子性，synchronized 可见性，有序性，可重入性怎么实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">synchronized 怎么保证可见性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-number">4.3.2.</span> <span class="toc-text">synchronized 怎么保证有序性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">4.3.3.</span> <span class="toc-text">synchronized 怎么实现可重入的呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%9Fsynchronized-%E4%BC%98%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">29.锁升级？synchronized 优化了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E5%8D%87%E7%BA%A7%EF%BC%9F"><span class="toc-number">4.4.1.</span> <span class="toc-text">什么是锁升级？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">4.4.2.</span> <span class="toc-text">synchronized 做了哪些优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.4.3.</span> <span class="toc-text">锁升级的过程是什么样的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E8%AF%B4%E8%AF%B4-synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">30.说说 synchronized 和 ReentrantLock 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">4.5.1.</span> <span class="toc-text">使用方式有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%89%B9%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">4.5.2.</span> <span class="toc-text">功能特点有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%87%8F%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8-synchronized-%E8%BF%98%E6%98%AF-ReentrantLock%EF%BC%9F"><span class="toc-number">4.5.3.</span> <span class="toc-text">并发量大的情况下，使用 synchronized 还是 ReentrantLock？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-AQS-%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">31.AQS 了解多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-ReentrantLock-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">32.ReentrantLock 实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-ReentrantLock-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">33.ReentrantLock 怎么实现公平锁的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E5%85%AC%E5%B9%B3%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">4.8.1.</span> <span class="toc-text">非公平锁和公平锁有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%91%A2%EF%BC%9F"><span class="toc-number">4.8.2.</span> <span class="toc-text">怎么实现一个非公平锁呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-CAS-%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">34.CAS 了解多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">35.CAS 有什么问题？如何解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ABA-%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">4.10.1.</span> <span class="toc-text">什么是 ABA 问题？如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="toc-number">4.10.2.</span> <span class="toc-text">循环性能开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">4.10.3.</span> <span class="toc-text">只能保证一个变量的原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-Java-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B-i-%E7%BB%93%E6%9E%9C%E6%AD%A3%E7%A1%AE%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">36.Java 有哪些保证原子性的方法？如何保证多线程下 i++ 结果正确？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">37.原子操作类了解多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-AtomicInteger-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">38.AtomicInteger 的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">39.线程死锁了解吗？该如何避免？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E5%91%A2%EF%BC%9F"><span class="toc-number">4.14.1.</span> <span class="toc-text">那么为什么会产生死锁呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A5%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E5%91%A2%EF%BC%9F"><span class="toc-number">4.14.2.</span> <span class="toc-text">该如何避免死锁呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E9%82%A3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E5%91%A2%EF%BC%9F"><span class="toc-number">4.15.</span> <span class="toc-text">40.那死锁问题怎么排查呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">4.16.</span> <span class="toc-text">41.聊聊如何进行线程同步？（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.16.1.</span> <span class="toc-text">简单说说 synchronized 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4-Lock-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">4.16.2.</span> <span class="toc-text">简单说说 Lock 接口？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E8%81%8A%E8%81%8A%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">4.17.</span> <span class="toc-text">42.聊聊悲观锁和乐观锁？（补充）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#43-CountDownLatch%EF%BC%88%E5%80%92%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">43.CountDownLatch（倒计数器）了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-CyclicBarrier%EF%BC%88%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C%EF%BC%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">44.CyclicBarrier（同步屏障）了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-CyclicBarrier-%E5%92%8C-CountDownLatch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">45.CyclicBarrier 和 CountDownLatch 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-Semaphore%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">46.Semaphore（信号量）了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-Exchanger-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">47.Exchanger 了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">48.能说一下 ConcurrentHashMap 的实现吗？（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-7-%E4%B8%AD%E7%9A%84-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">5.6.1.</span> <span class="toc-text">说一下 JDK 7 中的 ConcurrentHashMap 的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-JDK-8-%E4%B8%AD%E7%9A%84-ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">5.6.2.</span> <span class="toc-text">说一下 JDK 8 中的 ConcurrentHashMap 的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B-HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.6.3.</span> <span class="toc-text">总结一下 HashMap 和 ConcurrentHashMap 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-ConcurrentHashMap-%E7%9A%84%EF%BC%9F"><span class="toc-number">5.6.4.</span> <span class="toc-text">你项目中怎么使用 ConcurrentHashMap 的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-%E5%AF%B9-HashMap-%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">5.6.5.</span> <span class="toc-text">ConcurrentHashMap 对 HashMap 的优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E5%9C%A8-JDK-1-7-%E4%B8%AD%E8%A6%81%E7%94%A8-ReentrantLock%EF%BC%8C%E8%80%8C%E5%9C%A8-JDK-1-8-%E8%A6%81%E7%94%A8-synchronized"><span class="toc-number">5.6.6.</span> <span class="toc-text">为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-ConcurrentHashMap-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">49.ConcurrentHashMap 怎么保证可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E6%AF%94-Hashtable-%E6%95%88%E7%8E%87%E9%AB%98"><span class="toc-number">5.8.</span> <span class="toc-text">50.为什么 ConcurrentHashMap 比 Hashtable 效率高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-CopyOnWriteArrayList-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">51.能说一下 CopyOnWriteArrayList 的实现原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B-BlockingQueue-%E5%90%97%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">52. 能说一下 BlockingQueue 吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">5.10.1.</span> <span class="toc-text">阻塞队列是如何实现的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">53.什么是线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">54.能说说工作中线程池的应用吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">55.能简单说一下线程池的工作流程吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">56.线程池主要参数有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%90%97%EF%BC%9F"><span class="toc-number">6.4.1.</span> <span class="toc-text">能简单说一下参数之间的关系吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9F%E4%BC%9A%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">6.4.2.</span> <span class="toc-text">核心线程数不够会怎么进行处理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">6.4.3.</span> <span class="toc-text">举个例子说一下这些参数的变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">57.线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">58.线程池有哪几种阻塞队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4-execute-%E5%92%8C-submit-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">59.线程池提交 execute 和 submit 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%8E%E4%B9%88%E5%85%B3%E9%97%AD%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">60.线程池怎么关闭知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">61.线程池的线程数应该怎么配置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.10.</span> <span class="toc-text">62.有哪几种常见的线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">6.11.</span> <span class="toc-text">63.能说一下四种常见线程池的原理吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">6.11.1.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">6.11.2.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">6.11.3.</span> <span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newScheduledThreadPool"><span class="toc-number">6.11.4.</span> <span class="toc-text">newScheduledThreadPool</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">6.12.</span> <span class="toc-text">64.线程池异常怎么处理知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%E5%90%97%EF%BC%9F"><span class="toc-number">6.13.</span> <span class="toc-text">65.能说一下线程池有几种状态吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-number">6.14.</span> <span class="toc-text">66.线程池如何实现参数的动态修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">6.15.</span> <span class="toc-text">67.线程池调优了解吗？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">6.16.</span> <span class="toc-text">68.线程池在使用的时候需要注意什么？（补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-%E4%BD%A0%E8%83%BD%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97%EF%BC%9F"><span class="toc-number">6.17.</span> <span class="toc-text">69.你能设计实现一个线程池吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E5%8D%95%E6%9C%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%96%AD%E7%94%B5%E4%BA%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">6.18.</span> <span class="toc-text">70.单机线程池执行断电了应该怎么处理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6"><span class="toc-number">7.</span> <span class="toc-text">并发容器和框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71-Fork-Join-%E6%A1%86%E6%9E%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">71.Fork/Join 框架了解吗？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="八股文系列-并发编程"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文系列-并发编程"></a><div class="content"><a class="title" href="/2024/09/02/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="八股文系列-并发编程">八股文系列-并发编程</a><time datetime="2024-09-02T15:11:35.000Z" title="发表于 2024-09-02 23:11:35">2024-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="八股文系列-Java集合框架"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202409011332227.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文系列-Java集合框架"></a><div class="content"><a class="title" href="/2024/09/01/%E5%85%AB%E8%82%A1%E6%96%87%E7%B3%BB%E5%88%97-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" title="八股文系列-Java集合框架">八股文系列-Java集合框架</a><time datetime="2024-09-01T05:22:24.000Z" title="发表于 2024-09-01 13:22:24">2024-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/" title="我的博客优化历程—自动初始化Gitalk"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408301832793.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的博客优化历程—自动初始化Gitalk"></a><div class="content"><a class="title" href="/2024/08/11/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk/" title="我的博客优化历程—自动初始化Gitalk">我的博客优化历程—自动初始化Gitalk</a><time datetime="2024-08-11T13:01:24.000Z" title="发表于 2024-08-11 21:01:24">2024-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/" title="一起写个数据库—10.服务端客户端的实现及其通信规则"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—10.服务端客户端的实现及其通信规则"></a><div class="content"><a class="title" href="/2024/06/11/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%9410.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/" title="一起写个数据库—10.服务端客户端的实现及其通信规则">一起写个数据库—10.服务端客户端的实现及其通信规则</a><time datetime="2024-06-11T13:01:24.000Z" title="发表于 2024-06-11 21:01:24">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/" title="一起写个数据库—9.字段与表管理"><img src="https://raw.githubusercontent.com/ylcheng2022/pic_bed/main/img/202408291840928.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一起写个数据库—9.字段与表管理"></a><div class="content"><a class="title" href="/2024/06/10/%E4%B8%80%E8%B5%B7%E5%86%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%949.%E5%AD%97%E6%AE%B5%E4%B8%8E%E8%A1%A8%E7%AE%A1%E7%90%86/" title="一起写个数据库—9.字段与表管理">一起写个数据库—9.字段与表管理</a><time datetime="2024-06-10T13:01:24.000Z" title="发表于 2024-06-10 21:01:24">2024-06-10</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2017 - 2024 By 程月龙</div><div class="footer_custom_text">Copyright© Loong开发-独立开发者的日常总结<br></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liYCRlnpOTAGppwh',
      clientSecret: '5905e4c39a53de631adc5959cec17edba0d64cfe',
      repo: 'ylcheng1789.github.io',
      owner: 'ylcheng1789',
      admin: ['ylcheng1789'],
      id: '27c459c2545a7fcfa12de36a9f82dd04',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>